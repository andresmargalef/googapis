// This file is @generated by prost-build.
/// Orchestration cluster represents a GKE cluster with config controller and
/// TNA specific components installed on it.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OrchestrationCluster {
    /// Name of the orchestration cluster. The name of orchestration cluster cannot
    /// be more than 24 characters.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Management configuration of the underlying GKE cluster.
    #[prost(message, optional, tag = "5")]
    pub management_config: ::core::option::Option<ManagementConfig>,
    /// Output only. \[Output only\] Create time stamp.
    #[prost(message, optional, tag = "2")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. \[Output only\] Update time stamp.
    #[prost(message, optional, tag = "3")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Labels as key value pairs.
    #[prost(map = "string, string", tag = "4")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Output only. Provides the TNA version installed on the cluster.
    #[prost(string, tag = "6")]
    pub tna_version: ::prost::alloc::string::String,
    /// Output only. State of the Orchestration Cluster.
    #[prost(enumeration = "orchestration_cluster::State", tag = "7")]
    pub state: i32,
}
/// Nested message and enum types in `OrchestrationCluster`.
pub mod orchestration_cluster {
    /// Possible states that the Orchestration Cluster can be in.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        /// Unspecified state.
        Unspecified = 0,
        /// OrchestrationCluster is being created.
        Creating = 1,
        /// OrchestrationCluster has been created and is ready for use.
        Active = 2,
        /// OrchestrationCluster is being deleted.
        Deleting = 3,
        /// OrchestrationCluster encountered an error and is in an indeterministic
        /// state. User can still initiate a delete operation on this state.
        Failed = 4,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                State::Unspecified => "STATE_UNSPECIFIED",
                State::Creating => "CREATING",
                State::Active => "ACTIVE",
                State::Deleting => "DELETING",
                State::Failed => "FAILED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "CREATING" => Some(Self::Creating),
                "ACTIVE" => Some(Self::Active),
                "DELETING" => Some(Self::Deleting),
                "FAILED" => Some(Self::Failed),
                _ => None,
            }
        }
    }
}
/// EdgeSlm represents an SLM instance which manages the lifecycle of edge
/// components installed on Workload clusters managed by an Orchestration
/// Cluster.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EdgeSlm {
    /// Name of the EdgeSlm resource.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Immutable. Reference to the orchestration cluster on which templates for
    /// this resources will be applied. This should be of format
    /// projects/{project}/locations/{location}/orchestrationClusters/{orchestration_cluster}.
    #[prost(string, tag = "5")]
    pub orchestration_cluster: ::prost::alloc::string::String,
    /// Output only. \[Output only\] Create time stamp.
    #[prost(message, optional, tag = "2")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. \[Output only\] Update time stamp.
    #[prost(message, optional, tag = "3")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Optional. Labels as key value pairs. The key and value should contain
    /// characters which are UTF-8 compliant and less than 50 characters.
    #[prost(map = "string, string", tag = "4")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Output only. Provides the active TNA version for this resource.
    #[prost(string, tag = "6")]
    pub tna_version: ::prost::alloc::string::String,
    /// Output only. State of the EdgeSlm resource.
    #[prost(enumeration = "edge_slm::State", tag = "7")]
    pub state: i32,
    /// Optional. Type of workload cluster for which an EdgeSLM resource is
    /// created.
    #[prost(enumeration = "edge_slm::WorkloadClusterType", tag = "8")]
    pub workload_cluster_type: i32,
}
/// Nested message and enum types in `EdgeSlm`.
pub mod edge_slm {
    /// Possible states of the resource.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        /// Unspecified state.
        Unspecified = 0,
        /// EdgeSlm is being created.
        Creating = 1,
        /// EdgeSlm has been created and is ready for use.
        Active = 2,
        /// EdgeSlm is being deleted.
        Deleting = 3,
        /// EdgeSlm encountered an error and is in an indeterministic
        /// state. User can still initiate a delete operation on this state.
        Failed = 4,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                State::Unspecified => "STATE_UNSPECIFIED",
                State::Creating => "CREATING",
                State::Active => "ACTIVE",
                State::Deleting => "DELETING",
                State::Failed => "FAILED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "CREATING" => Some(Self::Creating),
                "ACTIVE" => Some(Self::Active),
                "DELETING" => Some(Self::Deleting),
                "FAILED" => Some(Self::Failed),
                _ => None,
            }
        }
    }
    /// Workload clusters supported by TNA. New values will be added to the enum
    /// list as TNA adds supports for new workload clusters in future.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum WorkloadClusterType {
        /// Unspecified workload cluster.
        Unspecified = 0,
        /// Workload cluster is a GDCE cluster.
        Gdce = 1,
        /// Workload cluster is a GKE cluster.
        Gke = 2,
    }
    impl WorkloadClusterType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                WorkloadClusterType::Unspecified => "WORKLOAD_CLUSTER_TYPE_UNSPECIFIED",
                WorkloadClusterType::Gdce => "GDCE",
                WorkloadClusterType::Gke => "GKE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "WORKLOAD_CLUSTER_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "GDCE" => Some(Self::Gdce),
                "GKE" => Some(Self::Gke),
                _ => None,
            }
        }
    }
}
/// A Blueprint contains a collection of kubernetes resources in the form of
/// YAML files. The file contents of a blueprint are collectively known as
/// package. A blueprint can be
/// a) imported from TNA's public catalog
/// b) modified as per a user's need
/// c) proposed and approved.
/// On approval, a revision of blueprint is created which can be used to
/// create a deployment on Orchestration or Workload Cluster.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Blueprint {
    /// The name of the blueprint. If unspecified, the name will be autogenerated
    /// from server side. Name of the blueprint must not contain `@` character.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. Immutable. The revision ID of the blueprint.
    /// A new revision is committed whenever a blueprint is approved.
    #[prost(string, tag = "2")]
    pub revision_id: ::prost::alloc::string::String,
    /// Required. Immutable. The public blueprint ID from which this blueprint was
    /// created.
    #[prost(string, tag = "3")]
    pub source_blueprint: ::prost::alloc::string::String,
    /// Output only. The timestamp that the revision was created.
    #[prost(message, optional, tag = "5")]
    pub revision_create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. Approval state of the blueprint (DRAFT, PROPOSED, APPROVED)
    #[prost(enumeration = "blueprint::ApprovalState", tag = "6")]
    pub approval_state: i32,
    /// Optional. Human readable name of a Blueprint.
    #[prost(string, tag = "7")]
    pub display_name: ::prost::alloc::string::String,
    /// Output only. Name of the repository where the blueprint files are stored.
    #[prost(string, tag = "8")]
    pub repository: ::prost::alloc::string::String,
    /// Optional. Files present in a blueprint.
    /// When invoking UpdateBlueprint API, only the modified files should be
    /// included in this. Files that are not included in the update of a blueprint
    /// will not be changed.
    #[prost(message, repeated, tag = "9")]
    pub files: ::prost::alloc::vec::Vec<File>,
    /// Optional. Labels are key-value attributes that can be set on a blueprint
    /// resource by the user.
    #[prost(map = "string, string", tag = "10")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Output only. Blueprint creation time.
    #[prost(message, optional, tag = "11")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The timestamp when the blueprint was updated.
    #[prost(message, optional, tag = "12")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. Source provider is the author of a public blueprint, from
    /// which this blueprint is created.
    #[prost(string, tag = "13")]
    pub source_provider: ::prost::alloc::string::String,
    /// Output only. DeploymentLevel of a blueprint signifies where the blueprint
    /// will be applied. e.g. \[HYDRATION, SINGLE_DEPLOYMENT, MULTI_DEPLOYMENT\]
    #[prost(enumeration = "DeploymentLevel", tag = "14")]
    pub deployment_level: i32,
    /// Output only. Indicates if the deployment created from this blueprint can be
    /// rolled back.
    #[prost(bool, tag = "15")]
    pub rollback_support: bool,
}
/// Nested message and enum types in `Blueprint`.
pub mod blueprint {
    /// Approval state indicates the state of a Blueprint in its approval
    /// lifecycle.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ApprovalState {
        /// Unspecified state.
        Unspecified = 0,
        /// A blueprint starts in DRAFT state once it is created. All edits are made
        /// to the blueprint in DRAFT state.
        Draft = 1,
        /// When the edits are ready for review, blueprint can be proposed and moves
        /// to PROPOSED state. Edits cannot be made to a blueprint in PROPOSED state.
        Proposed = 2,
        /// When a proposed blueprint is approved, it moves to APPROVED state. A new
        /// revision is committed. The latest committed revision can be used to
        /// create a deployment on Orchestration or Workload Cluster. Edits to an
        /// APPROVED blueprint changes its state back to DRAFT. The last committed
        /// revision of a blueprint represents its latest APPROVED state.
        Approved = 3,
    }
    impl ApprovalState {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ApprovalState::Unspecified => "APPROVAL_STATE_UNSPECIFIED",
                ApprovalState::Draft => "DRAFT",
                ApprovalState::Proposed => "PROPOSED",
                ApprovalState::Approved => "APPROVED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "APPROVAL_STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "DRAFT" => Some(Self::Draft),
                "PROPOSED" => Some(Self::Proposed),
                "APPROVED" => Some(Self::Approved),
                _ => None,
            }
        }
    }
}
/// A Blueprint contains a collection of kubernetes resources in the form of
/// YAML files. The file contents of a blueprint are collectively known as
/// package.
/// Public blueprint is a TNA provided blueprint that in present in TNA's public
/// catalog. A user can copy the public blueprint to their private catalog for
/// further modifications.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PublicBlueprint {
    /// Name of the public blueprint.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// The display name of the public blueprint.
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    /// The description of the public blueprint.
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
    /// DeploymentLevel of a blueprint signifies where the blueprint will be
    /// applied. e.g. \[HYDRATION, SINGLE_DEPLOYMENT, MULTI_DEPLOYMENT\]
    #[prost(enumeration = "DeploymentLevel", tag = "4")]
    pub deployment_level: i32,
    /// Source provider is the author of a public blueprint. e.g. Google, vendors
    #[prost(string, tag = "5")]
    pub source_provider: ::prost::alloc::string::String,
    /// Output only. Indicates if the deployment created from this blueprint can be
    /// rolled back.
    #[prost(bool, tag = "15")]
    pub rollback_support: bool,
}
/// Deployment contains a collection of YAML files (This collection is also known
/// as package) that can to applied on an orchestration cluster (GKE cluster with
/// TNA addons) or a workload cluster.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Deployment {
    /// The name of the deployment.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. Immutable. The revision ID of the deployment.
    /// A new revision is committed whenever a change in deployment is applied.
    #[prost(string, tag = "2")]
    pub revision_id: ::prost::alloc::string::String,
    /// Required. The blueprint revision from which this deployment was created.
    #[prost(string, tag = "3")]
    pub source_blueprint_revision: ::prost::alloc::string::String,
    /// Output only. The timestamp that the revision was created.
    #[prost(message, optional, tag = "4")]
    pub revision_create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. State of the deployment (DRAFT, APPLIED, DELETING).
    #[prost(enumeration = "deployment::State", tag = "5")]
    pub state: i32,
    /// Optional. Human readable name of a Deployment.
    #[prost(string, tag = "6")]
    pub display_name: ::prost::alloc::string::String,
    /// Output only. Name of the repository where the deployment package files are
    /// stored.
    #[prost(string, tag = "7")]
    pub repository: ::prost::alloc::string::String,
    /// Optional. Files present in a deployment.
    /// When invoking UpdateDeployment API, only the modified files should be
    /// included in this. Files that are not included in the update of a deployment
    /// will not be changed.
    #[prost(message, repeated, tag = "8")]
    pub files: ::prost::alloc::vec::Vec<File>,
    /// Optional. Labels are key-value attributes that can be set on a deployment
    /// resource by the user.
    #[prost(map = "string, string", tag = "9")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Output only. Deployment creation time.
    #[prost(message, optional, tag = "10")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The timestamp when the deployment was updated.
    #[prost(message, optional, tag = "11")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. Source provider is the author of a public blueprint, from
    /// which this deployment is created.
    #[prost(string, tag = "12")]
    pub source_provider: ::prost::alloc::string::String,
    /// Optional. Immutable. The WorkloadCluster on which to create the Deployment.
    /// This field should only be passed when the deployment_level of the source
    /// blueprint specifies deployments on workload clusters e.g.
    /// WORKLOAD_CLUSTER_DEPLOYMENT.
    #[prost(string, tag = "13")]
    pub workload_cluster: ::prost::alloc::string::String,
    /// Output only. Attributes to where the deployment can inflict changes. The
    /// value can only be \[SINGLE_DEPLOYMENT, MULTI_DEPLOYMENT\].
    #[prost(enumeration = "DeploymentLevel", tag = "14")]
    pub deployment_level: i32,
    /// Output only. Indicates if the deployment can be rolled back, exported from
    /// public blueprint.
    #[prost(bool, tag = "15")]
    pub rollback_support: bool,
}
/// Nested message and enum types in `Deployment`.
pub mod deployment {
    /// State defines which state the current deployment is in.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        /// Unspecified state.
        Unspecified = 0,
        /// A deployment starts in DRAFT state. All edits are made in DRAFT state. A
        /// deployment opened for editing after applying will be in draft state,
        /// while its prevision revision will be its current applied version.
        Draft = 1,
        /// This state means that the contents (YAML files containing kubernetes
        /// resources) of the deployment have been applied to an Orchestration or
        /// Workload Cluster. A revision is created when a deployment is applied.
        /// This revision will represent the latest view of what is applied on the
        /// cluster until the deployment is modified and applied again, which will
        /// create a new revision.
        Applied = 2,
        /// A deployment in DELETING state has been marked for deletion. Its
        /// deletion status can be queried using `ComputeDeploymentStatus` API. No
        /// updates are allowed to a deployment in DELETING state.
        Deleting = 3,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                State::Unspecified => "STATE_UNSPECIFIED",
                State::Draft => "DRAFT",
                State::Applied => "APPLIED",
                State::Deleting => "DELETING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "DRAFT" => Some(Self::Draft),
                "APPLIED" => Some(Self::Applied),
                "DELETING" => Some(Self::Deleting),
                _ => None,
            }
        }
    }
}
/// A collection of kubernetes yaml files which are deployed on a Workload
/// Cluster. Hydrated Deployments are created by TNA intent based automation.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HydratedDeployment {
    /// Output only. The name of the hydrated deployment.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. State of the hydrated deployment (DRAFT, APPLIED).
    #[prost(enumeration = "hydrated_deployment::State", tag = "2")]
    pub state: i32,
    /// Optional. File contents of a hydrated deployment.
    /// When invoking UpdateHydratedBlueprint API, only the modified files should
    /// be included in this. Files that are not included in the update of a
    /// hydrated deployment will not be changed.
    #[prost(message, repeated, tag = "3")]
    pub files: ::prost::alloc::vec::Vec<File>,
    /// Output only. WorkloadCluster identifies which workload cluster will the
    /// hydrated deployment will be deployed on.
    #[prost(string, tag = "4")]
    pub workload_cluster: ::prost::alloc::string::String,
}
/// Nested message and enum types in `HydratedDeployment`.
pub mod hydrated_deployment {
    /// State defines which state the current hydrated deployment is in.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        /// Unspecified state.
        Unspecified = 0,
        /// A hydrated deployment starts in DRAFT state. All edits are made in DRAFT
        /// state.
        Draft = 1,
        /// When the edit is applied, the hydrated deployment moves to APPLIED
        /// state. No changes can be made once a hydrated deployment is applied.
        Applied = 2,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                State::Unspecified => "STATE_UNSPECIFIED",
                State::Draft => "DRAFT",
                State::Applied => "APPLIED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "DRAFT" => Some(Self::Draft),
                "APPLIED" => Some(Self::Applied),
                _ => None,
            }
        }
    }
}
/// Message for requesting list of OrchestrationClusters.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListOrchestrationClustersRequest {
    /// Required. Parent value for ListOrchestrationClustersRequest
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Requested page size. Server may return fewer items than requested.
    /// If unspecified, server will pick an appropriate default.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// A token identifying a page of results the server should return.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Filtering results.
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    /// Hint for how to order the results.
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
/// Message for response to listing OrchestrationClusters.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListOrchestrationClustersResponse {
    /// The list of OrchestrationCluster
    #[prost(message, repeated, tag = "1")]
    pub orchestration_clusters: ::prost::alloc::vec::Vec<OrchestrationCluster>,
    /// A token identifying a page of results the server should return.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    /// Locations that could not be reached.
    #[prost(string, repeated, tag = "3")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Message for getting a OrchestrationCluster.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetOrchestrationClusterRequest {
    /// Required. Name of the resource
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Message for creating a OrchestrationCluster.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateOrchestrationClusterRequest {
    /// Required. Value for parent.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. Id of the requesting object
    /// If auto-generating Id server-side, remove this field and
    /// orchestration_cluster_id from the method_signature of Create RPC
    #[prost(string, tag = "2")]
    pub orchestration_cluster_id: ::prost::alloc::string::String,
    /// Required. The resource being created
    #[prost(message, optional, tag = "3")]
    pub orchestration_cluster: ::core::option::Option<OrchestrationCluster>,
    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[prost(string, tag = "4")]
    pub request_id: ::prost::alloc::string::String,
}
/// Message for deleting a OrchestrationCluster.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteOrchestrationClusterRequest {
    /// Required. Name of the resource
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[prost(string, tag = "2")]
    pub request_id: ::prost::alloc::string::String,
}
/// Message for requesting list of EdgeSlms
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListEdgeSlmsRequest {
    /// Required. Parent value for ListEdgeSlmsRequest
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Requested page size. Server may return fewer items than requested.
    /// If unspecified, server will pick an appropriate default.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// A token identifying a page of results the server should return.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Filtering results
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    /// Hint for how to order the results
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
/// Message for response to listing EdgeSlms.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListEdgeSlmsResponse {
    /// The list of EdgeSlm
    #[prost(message, repeated, tag = "1")]
    pub edge_slms: ::prost::alloc::vec::Vec<EdgeSlm>,
    /// A token identifying a page of results the server should return.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    /// Locations that could not be reached.
    #[prost(string, repeated, tag = "3")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Message for getting a EdgeSlm.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetEdgeSlmRequest {
    /// Required. Name of the resource
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Message for creating a EdgeSlm.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateEdgeSlmRequest {
    /// Required. Value for parent.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. Id of the requesting object
    /// If auto-generating Id server-side, remove this field and
    /// edge_slm_id from the method_signature of Create RPC
    #[prost(string, tag = "2")]
    pub edge_slm_id: ::prost::alloc::string::String,
    /// Required. The resource being created
    #[prost(message, optional, tag = "3")]
    pub edge_slm: ::core::option::Option<EdgeSlm>,
    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[prost(string, tag = "4")]
    pub request_id: ::prost::alloc::string::String,
}
/// Message for deleting a EdgeSlm.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteEdgeSlmRequest {
    /// Required. Name of the resource
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[prost(string, tag = "2")]
    pub request_id: ::prost::alloc::string::String,
}
/// Request object for `CreateBlueprint`.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateBlueprintRequest {
    /// Required. The name of parent resource.
    /// Format should be -
    /// "projects/{project_id}/locations/{location_name}/orchestrationClusters/{orchestration_cluster}".
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. The name of the blueprint.
    #[prost(string, tag = "2")]
    pub blueprint_id: ::prost::alloc::string::String,
    /// Required. The `Blueprint` to create.
    #[prost(message, optional, tag = "3")]
    pub blueprint: ::core::option::Option<Blueprint>,
}
/// Request object for `UpdateBlueprint`.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateBlueprintRequest {
    /// Required. The `blueprint` to update.
    #[prost(message, optional, tag = "1")]
    pub blueprint: ::core::option::Option<Blueprint>,
    /// Required. Update mask is used to specify the fields to be overwritten in
    /// the `blueprint` resource by the update.
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
/// Request object for `GetBlueprint`.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetBlueprintRequest {
    /// Required. The name of the blueprint.
    /// Case 1: If the name provided in the request is
    /// {blueprint_id}@{revision_id}, then the revision with revision_id will be
    /// returned. Case 2: If the name provided in the request is {blueprint}, then
    /// the current state of the blueprint is returned.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. Defines the type of view of the blueprint.
    /// When field is not present BLUEPRINT_VIEW_BASIC is considered as default.
    #[prost(enumeration = "BlueprintView", tag = "2")]
    pub view: i32,
}
/// Request object for `DeleteBlueprint`.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteBlueprintRequest {
    /// Required. The name of blueprint to delete.
    /// Blueprint name should be in the format {blueprint_id}, if
    /// {blueprint_id}@{revision_id} is passed then the API throws invalid
    /// argument.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request object for `ListBlueprints`.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListBlueprintsRequest {
    /// Required. The name of parent orchestration cluster resource.
    /// Format should be -
    /// "projects/{project_id}/locations/{location_name}/orchestrationClusters/{orchestration_cluster}".
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. Filtering only supports equality on blueprint state.
    /// It should be in the form: "state = DRAFT". `OR` operator can be used to
    /// get response for multiple states. e.g. "state = DRAFT OR state = PROPOSED".
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    /// Optional. The maximum number of blueprints to return per page.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. The page token, received from a previous ListBlueprints call.
    /// It can be provided to retrieve the subsequent page.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
/// Response object for `ListBlueprints`.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListBlueprintsResponse {
    /// The list of requested blueprints.
    #[prost(message, repeated, tag = "1")]
    pub blueprints: ::prost::alloc::vec::Vec<Blueprint>,
    /// A token that can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// Request object for `ApproveBlueprint`.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ApproveBlueprintRequest {
    /// Required. The name of the blueprint to approve. The blueprint must be in
    /// Proposed state. A new revision is committed on approval.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request object for `ProposeBlueprint`.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProposeBlueprintRequest {
    /// Required. The name of the blueprint being proposed.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request object for `RejectBlueprint`.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RejectBlueprintRequest {
    /// Required. The name of the blueprint being rejected.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request object for `ListBlueprintRevisions`.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListBlueprintRevisionsRequest {
    /// Required. The name of the blueprint to list revisions for.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// The maximum number of revisions to return per page.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// The page token, received from a previous ListBlueprintRevisions call
    /// It can be provided to retrieve the subsequent page.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
/// Response object for `ListBlueprintRevisions`.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListBlueprintRevisionsResponse {
    /// The revisions of the blueprint.
    #[prost(message, repeated, tag = "1")]
    pub blueprints: ::prost::alloc::vec::Vec<Blueprint>,
    /// A token that can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// Request object for `SearchBlueprintRevisions`.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchBlueprintRevisionsRequest {
    /// Required. The name of parent orchestration cluster resource.
    /// Format should be -
    /// "projects/{project_id}/locations/{location_name}/orchestrationClusters/{orchestration_cluster}".
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. Supported queries:
    /// 1. ""                       : Lists all revisions across all blueprints.
    /// 2. "latest=true"            : Lists latest revisions across all blueprints.
    /// 3. "name={name}"            : Lists all revisions of blueprint with name
    /// {name}.
    /// 4. "name={name} latest=true": Lists latest revision of blueprint with name
    /// {name}
    #[prost(string, tag = "2")]
    pub query: ::prost::alloc::string::String,
    /// Optional. The maximum number of blueprints revisions to return per page.
    /// max page size = 100, default page size = 20.
    #[prost(int32, tag = "3")]
    pub page_size: i32,
    /// Optional. The page token, received from a previous search call.
    /// It can be provided to retrieve the subsequent page.
    #[prost(string, tag = "4")]
    pub page_token: ::prost::alloc::string::String,
}
/// Response object for `SearchBlueprintRevisions`.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchBlueprintRevisionsResponse {
    /// The list of requested blueprint revisions.
    #[prost(message, repeated, tag = "1")]
    pub blueprints: ::prost::alloc::vec::Vec<Blueprint>,
    /// A token that can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// Request object for `DiscardBlueprintChanges`.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DiscardBlueprintChangesRequest {
    /// Required. The name of the blueprint of which changes are being discarded.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Response object for `DiscardBlueprintChanges`.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DiscardBlueprintChangesResponse {}
/// Request object for `ListPublicBlueprints`.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListPublicBlueprintsRequest {
    /// Required. Parent value of public blueprint.
    /// Format should be -
    /// "projects/{project_id}/locations/{location_name}".
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. Requested page size. Server may return fewer items than
    /// requested. If unspecified, server will pick an appropriate default.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. A token identifying a page of results the server should return.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
/// Response object for `ListPublicBlueprints`.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListPublicBlueprintsResponse {
    /// The list of public blueprints to return.
    #[prost(message, repeated, tag = "1")]
    pub public_blueprints: ::prost::alloc::vec::Vec<PublicBlueprint>,
    /// Output only. A token identifying a page of results the server should
    /// return.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// Request object for `GetPublicBlueprint`.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetPublicBlueprintRequest {
    /// Required. The name of the public blueprint.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request object for `CreateDeployment`.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateDeploymentRequest {
    /// Required. The name of parent resource.
    /// Format should be -
    /// "projects/{project_id}/locations/{location_name}/orchestrationClusters/{orchestration_cluster}".
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. The name of the deployment.
    #[prost(string, tag = "2")]
    pub deployment_id: ::prost::alloc::string::String,
    /// Required. The `Deployment` to create.
    #[prost(message, optional, tag = "3")]
    pub deployment: ::core::option::Option<Deployment>,
}
/// Request object for `UpdateDeployment`.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateDeploymentRequest {
    /// Required. The `deployment` to update.
    #[prost(message, optional, tag = "1")]
    pub deployment: ::core::option::Option<Deployment>,
    /// Required. Update mask is used to specify the fields to be overwritten in
    /// the `deployment` resource by the update.
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
/// Request object for `GetDeployment`.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetDeploymentRequest {
    /// Required. The name of the deployment.
    /// Case 1: If the name provided in the request is
    /// {deployment_id}@{revision_id}, then the revision with revision_id will be
    /// returned.
    /// Case 2: If the name provided in the request is {deployment}, then
    /// the current state of the deployment is returned.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. Defines the type of view of the deployment.
    /// When field is not present VIEW_BASIC is considered as default.
    #[prost(enumeration = "DeploymentView", tag = "2")]
    pub view: i32,
}
/// Request object for `RemoveDeployment`.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RemoveDeploymentRequest {
    /// Required. The name of deployment to initiate delete.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request object for `ListDeployments`.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDeploymentsRequest {
    /// Required. The name of parent orchestration cluster resource.
    /// Format should be -
    /// "projects/{project_id}/locations/{location_name}/orchestrationClusters/{orchestration_cluster}".
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. Filtering only supports equality on deployment state.
    /// It should be in the form: "state = DRAFT". `OR` operator can be used to
    /// get response for multiple states. e.g. "state = DRAFT OR state = APPLIED".
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    /// Optional. The maximum number of deployments to return per page.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. The page token, received from a previous ListDeployments call.
    /// It can be provided to retrieve the subsequent page.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
/// Response object for `ListDeployments`.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDeploymentsResponse {
    /// The list of requested deployments.
    #[prost(message, repeated, tag = "1")]
    pub deployments: ::prost::alloc::vec::Vec<Deployment>,
    /// A token that can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// Request for listing all revisions of a deployment.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDeploymentRevisionsRequest {
    /// Required. The name of the deployment to list revisions for.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. The maximum number of revisions to return per page.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. The page token, received from a previous ListDeploymentRevisions
    /// call Provide this to retrieve the subsequent page.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
/// List of deployment revisions for a given deployment.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDeploymentRevisionsResponse {
    /// The revisions of the deployment.
    #[prost(message, repeated, tag = "1")]
    pub deployments: ::prost::alloc::vec::Vec<Deployment>,
    /// A token that can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// Request object for `SearchDeploymentRevisions`.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchDeploymentRevisionsRequest {
    /// Required. The name of parent orchestration cluster resource.
    /// Format should be -
    /// "projects/{project_id}/locations/{location_name}/orchestrationClusters/{orchestration_cluster}".
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. Supported queries:
    /// 1. ""                       : Lists all revisions across all deployments.
    /// 2. "latest=true"            : Lists latest revisions across all
    /// deployments.
    /// 3. "name={name}"            : Lists all revisions of deployment with name
    /// {name}.
    /// 4. "name={name} latest=true": Lists latest revision of deployment with name
    /// {name}
    #[prost(string, tag = "2")]
    pub query: ::prost::alloc::string::String,
    /// Optional. The maximum number of deployment revisions to return per page.
    /// max page size = 100, default page size = 20.
    #[prost(int32, tag = "3")]
    pub page_size: i32,
    /// Optional. The page token, received from a previous search call.
    /// It can be provided to retrieve the subsequent page.
    #[prost(string, tag = "4")]
    pub page_token: ::prost::alloc::string::String,
}
/// Response object for `SearchDeploymentRevisions`.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchDeploymentRevisionsResponse {
    /// The list of requested deployment revisions.
    #[prost(message, repeated, tag = "1")]
    pub deployments: ::prost::alloc::vec::Vec<Deployment>,
    /// A token that can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// Request object for `DiscardDeploymentChanges`.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DiscardDeploymentChangesRequest {
    /// Required. The name of the deployment of which changes are being discarded.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Response object for `DiscardDeploymentChanges`.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DiscardDeploymentChangesResponse {}
/// Request object for `ApplyDeployment`. The resources in given deployment
/// gets applied to Orchestration Cluster. A new revision is created when a
/// deployment is applied.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ApplyDeploymentRequest {
    /// Required. The name of the deployment to apply to orchestration cluster.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request object for `ComputeDeploymentStatus`.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ComputeDeploymentStatusRequest {
    /// Required. The name of the deployment without revisionID.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Response object for `ComputeDeploymentStatus`.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ComputeDeploymentStatusResponse {
    /// The name of the deployment.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. Aggregated status of a deployment.
    #[prost(enumeration = "Status", tag = "2")]
    pub aggregated_status: i32,
    /// Output only. Resource level status details in deployments.
    #[prost(message, repeated, tag = "3")]
    pub resource_statuses: ::prost::alloc::vec::Vec<ResourceStatus>,
}
/// Request object for `RollbackDeployment`.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RollbackDeploymentRequest {
    /// Required. Name of the deployment.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Required. The revision id of deployment to roll back to.
    #[prost(string, tag = "2")]
    pub revision_id: ::prost::alloc::string::String,
}
/// Represents the metadata of the long-running operation.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OperationMetadata {
    /// Output only. The time the operation was created.
    #[prost(message, optional, tag = "1")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The time the operation finished running.
    #[prost(message, optional, tag = "2")]
    pub end_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. Server-defined resource path for the target of the operation.
    #[prost(string, tag = "3")]
    pub target: ::prost::alloc::string::String,
    /// Output only. Name of the verb executed by the operation.
    #[prost(string, tag = "4")]
    pub verb: ::prost::alloc::string::String,
    /// Output only. Human-readable status of the operation, if any.
    #[prost(string, tag = "5")]
    pub status_message: ::prost::alloc::string::String,
    /// Output only. Identifies whether the user has requested cancellation
    /// of the operation. Operations that have been cancelled successfully
    /// have [Operation.error][] value with a
    /// [google.rpc.Status.code][google.rpc.Status.code] of 1, corresponding to
    /// `Code.CANCELLED`.
    #[prost(bool, tag = "6")]
    pub requested_cancellation: bool,
    /// Output only. API version used to start the operation.
    #[prost(string, tag = "7")]
    pub api_version: ::prost::alloc::string::String,
}
/// Request object for `GetHydratedDeployment`.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetHydratedDeploymentRequest {
    /// Required. Name of the hydrated deployment.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request object for `ListHydratedDeployments`.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListHydratedDeploymentsRequest {
    /// Required. The deployment managing the hydrated deployments.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. The maximum number of hydrated deployments to return. The service
    /// may return fewer than this value. If unspecified, at most 50 hydrated
    /// deployments will be returned. The maximum value is 1000. Values above 1000
    /// will be set to 1000.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. The page token, received from a previous ListHydratedDeployments
    /// call. Provide this to retrieve the subsequent page.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
/// Response object for `ListHydratedDeployments`.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListHydratedDeploymentsResponse {
    /// The list of hydrated deployments.
    #[prost(message, repeated, tag = "1")]
    pub hydrated_deployments: ::prost::alloc::vec::Vec<HydratedDeployment>,
    /// A token that can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// Request object for `UpdateHydratedDeployment`.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateHydratedDeploymentRequest {
    /// Required. The hydrated deployment to update.
    #[prost(message, optional, tag = "1")]
    pub hydrated_deployment: ::core::option::Option<HydratedDeployment>,
    /// Required. The list of fields to update. Update mask supports a special
    /// value `*` which fully replaces (equivalent to PUT) the resource provided.
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
/// Request for applying a hydrated deployment.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ApplyHydratedDeploymentRequest {
    /// Required. The name of the hydrated deployment to apply.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Configuration of the cluster management
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ManagementConfig {
    /// The configuration can be one of StandardManagementConfig
    /// and FullManagementConfig
    #[prost(oneof = "management_config::OneofConfig", tags = "1, 2")]
    pub oneof_config: ::core::option::Option<management_config::OneofConfig>,
}
/// Nested message and enum types in `ManagementConfig`.
pub mod management_config {
    /// The configuration can be one of StandardManagementConfig
    /// and FullManagementConfig
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum OneofConfig {
        /// Configuration of the standard (GKE) cluster management
        #[prost(message, tag = "1")]
        StandardManagementConfig(super::StandardManagementConfig),
        /// Configuration of the full (Autopilot) cluster management. Full cluster
        /// management is a preview feature.
        #[prost(message, tag = "2")]
        FullManagementConfig(super::FullManagementConfig),
    }
}
/// Configuration of the standard (GKE) cluster management.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StandardManagementConfig {
    /// Optional. Name of the VPC Network to put the GKE cluster and nodes in. The
    /// VPC will be created if it doesn't exist.
    #[prost(string, tag = "1")]
    pub network: ::prost::alloc::string::String,
    /// Optional. Specifies the subnet that the interface will be part of. Network
    /// key must be specified and the subnet must be a subnetwork of the specified
    /// network.
    #[prost(string, tag = "2")]
    pub subnet: ::prost::alloc::string::String,
    /// Optional. The /28 network that the masters will use. It should be free
    /// within the network.
    #[prost(string, tag = "3")]
    pub master_ipv4_cidr_block: ::prost::alloc::string::String,
    /// Optional. The IP address range for the cluster pod IPs. Set to blank to
    /// have a range chosen with the default size. Set to /netmask (e.g. /14) to
    /// have a range chosen with a specific netmask. Set to a CIDR notation
    /// (e.g. 10.96.0.0/14) from the RFC-1918 private networks (e.g. 10.0.0.0/8,
    /// 172.16.0.0/12, 192.168.0.0/16) to pick a specific range to use.
    #[prost(string, tag = "4")]
    pub cluster_cidr_block: ::prost::alloc::string::String,
    /// Optional. The IP address range for the cluster service IPs. Set to blank to
    /// have a range chosen with the default size. Set to /netmask (e.g. /14) to
    /// have a range chosen with a specific netmask. Set to a CIDR notation (e.g.
    /// 10.96.0.0/14) from the RFC-1918 private networks (e.g. 10.0.0.0/8,
    /// 172.16.0.0/12, 192.168.0.0/16) to pick a specific range to use.
    #[prost(string, tag = "5")]
    pub services_cidr_block: ::prost::alloc::string::String,
    /// Optional. The name of the existing secondary range in the cluster's
    /// subnetwork to use for pod IP addresses. Alternatively, cluster_cidr_block
    /// can be used to automatically create a GKE-managed one.
    #[prost(string, tag = "6")]
    pub cluster_named_range: ::prost::alloc::string::String,
    /// Optional. The name of the existing secondary range in the cluster's
    /// subnetwork to use for service ClusterIPs. Alternatively,
    /// services_cidr_block can be used to automatically create a GKE-managed one.
    #[prost(string, tag = "7")]
    pub services_named_range: ::prost::alloc::string::String,
    /// Optional. Master Authorized Network that supports multiple CIDR blocks.
    /// Allows access to the k8s master from multiple blocks. It cannot be set at
    /// the same time with the field man_block.
    #[prost(message, optional, tag = "8")]
    pub master_authorized_networks_config: ::core::option::Option<
        MasterAuthorizedNetworksConfig,
    >,
}
/// Configuration of the full (Autopilot) cluster management
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FullManagementConfig {
    /// Optional. Name of the VPC Network to put the GKE cluster and nodes in. The
    /// VPC will be created if it doesn't exist.
    #[prost(string, tag = "1")]
    pub network: ::prost::alloc::string::String,
    /// Optional. Specifies the subnet that the interface will be part of. Network
    /// key must be specified and the subnet must be a subnetwork of the specified
    /// network.
    #[prost(string, tag = "2")]
    pub subnet: ::prost::alloc::string::String,
    /// Optional. The /28 network that the masters will use.
    #[prost(string, tag = "3")]
    pub master_ipv4_cidr_block: ::prost::alloc::string::String,
    /// Optional. The IP address range for the cluster pod IPs. Set to blank to
    /// have a range chosen with the default size. Set to /netmask (e.g. /14) to
    /// have a range chosen with a specific netmask. Set to a CIDR notation
    /// (e.g. 10.96.0.0/14) from the RFC-1918 private networks (e.g. 10.0.0.0/8,
    /// 172.16.0.0/12, 192.168.0.0/16) to pick a specific range to use.
    #[prost(string, tag = "4")]
    pub cluster_cidr_block: ::prost::alloc::string::String,
    /// Optional. The IP address range for the cluster service IPs. Set to blank to
    /// have a range chosen with the default size. Set to /netmask (e.g. /14) to
    /// have a range chosen with a specific netmask. Set to a CIDR notation (e.g.
    /// 10.96.0.0/14) from the RFC-1918 private networks (e.g. 10.0.0.0/8,
    /// 172.16.0.0/12, 192.168.0.0/16) to pick a specific range to use.
    #[prost(string, tag = "5")]
    pub services_cidr_block: ::prost::alloc::string::String,
    /// Optional. The name of the existing secondary range in the cluster's
    /// subnetwork to use for pod IP addresses. Alternatively, cluster_cidr_block
    /// can be used to automatically create a GKE-managed one.
    #[prost(string, tag = "6")]
    pub cluster_named_range: ::prost::alloc::string::String,
    /// Optional. The name of the existing secondary range in the cluster's
    /// subnetwork to use for service ClusterIPs. Alternatively,
    /// services_cidr_block can be used to automatically create a GKE-managed one.
    #[prost(string, tag = "7")]
    pub services_named_range: ::prost::alloc::string::String,
    /// Optional. Master Authorized Network that supports multiple CIDR blocks.
    /// Allows access to the k8s master from multiple blocks. It cannot be set at
    /// the same time with the field man_block.
    #[prost(message, optional, tag = "8")]
    pub master_authorized_networks_config: ::core::option::Option<
        MasterAuthorizedNetworksConfig,
    >,
}
/// Configuration of the Master Authorized Network that support multiple CIDRs
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MasterAuthorizedNetworksConfig {
    /// Optional. cidr_blocks define up to 50 external networks that could access
    /// Kubernetes master through HTTPS.
    #[prost(message, repeated, tag = "1")]
    pub cidr_blocks: ::prost::alloc::vec::Vec<
        master_authorized_networks_config::CidrBlock,
    >,
}
/// Nested message and enum types in `MasterAuthorizedNetworksConfig`.
pub mod master_authorized_networks_config {
    /// CidrBlock contains an optional name and one CIDR block.
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct CidrBlock {
        /// Optional. display_name is an optional field for users to identify CIDR
        /// blocks.
        #[prost(string, tag = "1")]
        pub display_name: ::prost::alloc::string::String,
        /// Optional. cidr_block must be specified in CIDR notation when using
        /// master_authorized_networks_config. Currently, the user could still use
        /// the deprecated man_block field, so this field is currently optional, but
        /// will be required in the future.
        #[prost(string, tag = "2")]
        pub cidr_block: ::prost::alloc::string::String,
    }
}
/// File represents a yaml file present in a blueprint's package.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct File {
    /// Required. Path of the file in package.
    /// e.g. `gdce/v1/cluster.yaml`
    #[prost(string, tag = "1")]
    pub path: ::prost::alloc::string::String,
    /// Optional. The contents of a file in string format.
    #[prost(string, tag = "2")]
    pub content: ::prost::alloc::string::String,
    /// Optional. Signifies whether a file is marked for deletion.
    #[prost(bool, tag = "3")]
    pub deleted: bool,
    /// Optional. Indicates whether changes are allowed to a file. If the field is
    /// not set, the file cannot be edited.
    #[prost(bool, tag = "4")]
    pub editable: bool,
}
/// Status of a deployment resource.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResourceStatus {
    /// Name of the resource.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Namespace of the resource.
    #[prost(string, tag = "2")]
    pub resource_namespace: ::prost::alloc::string::String,
    /// Group to which the resource belongs to.
    #[prost(string, tag = "3")]
    pub group: ::prost::alloc::string::String,
    /// Version of the resource.
    #[prost(string, tag = "4")]
    pub version: ::prost::alloc::string::String,
    /// Kind of the resource.
    #[prost(string, tag = "5")]
    pub kind: ::prost::alloc::string::String,
    /// Output only. Resource type.
    #[prost(enumeration = "ResourceType", tag = "6")]
    pub resource_type: i32,
    /// Output only. Status of the resource.
    #[prost(enumeration = "Status", tag = "7")]
    pub status: i32,
    /// Output only. Detailed status of NFDeploy.
    #[prost(message, optional, tag = "8")]
    pub nf_deploy_status: ::core::option::Option<NfDeployStatus>,
}
/// Deployment status of NFDeploy.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NfDeployStatus {
    /// Output only. Total number of NFs targeted by this deployment
    #[prost(int32, tag = "1")]
    pub targeted_nfs: i32,
    /// Output only. Total number of NFs targeted by this deployment with a Ready
    /// Condition set.
    #[prost(int32, tag = "2")]
    pub ready_nfs: i32,
    /// Output only. Per-Site Status.
    #[prost(message, repeated, tag = "3")]
    pub sites: ::prost::alloc::vec::Vec<NfDeploySiteStatus>,
}
/// Per-Site Status.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NfDeploySiteStatus {
    /// Output only. Site id.
    #[prost(string, tag = "1")]
    pub site: ::prost::alloc::string::String,
    /// Output only. If true, the Site Deletion is in progress.
    #[prost(bool, tag = "2")]
    pub pending_deletion: bool,
    /// Output only. Hydration status.
    #[prost(message, optional, tag = "3")]
    pub hydration: ::core::option::Option<HydrationStatus>,
    /// Output only. Workload status.
    #[prost(message, optional, tag = "4")]
    pub workload: ::core::option::Option<WorkloadStatus>,
}
/// Hydration status.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HydrationStatus {
    /// Output only. SiteVersion Hydration is targeting.
    #[prost(message, optional, tag = "1")]
    pub site_version: ::core::option::Option<SiteVersion>,
    /// Output only. Status.
    #[prost(string, tag = "2")]
    pub status: ::prost::alloc::string::String,
}
/// SiteVersion Hydration is targeting.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SiteVersion {
    /// Output only. NF vendor.
    #[prost(string, tag = "1")]
    pub nf_vendor: ::prost::alloc::string::String,
    /// Output only. NF vendor type.
    #[prost(string, tag = "2")]
    pub nf_type: ::prost::alloc::string::String,
    /// Output only. NF version.
    #[prost(string, tag = "3")]
    pub nf_version: ::prost::alloc::string::String,
}
/// Workload status.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorkloadStatus {
    /// Output only. SiteVersion running in the workload cluster.
    #[prost(message, optional, tag = "1")]
    pub site_version: ::core::option::Option<SiteVersion>,
    /// Output only. Status.
    #[prost(string, tag = "2")]
    pub status: ::prost::alloc::string::String,
}
/// BlueprintView defines the type of view of the blueprint.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum BlueprintView {
    /// Unspecified enum value.
    Unspecified = 0,
    /// View which only contains metadata.
    Basic = 1,
    /// View which contains metadata and files it encapsulates.
    Full = 2,
}
impl BlueprintView {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            BlueprintView::Unspecified => "BLUEPRINT_VIEW_UNSPECIFIED",
            BlueprintView::Basic => "BLUEPRINT_VIEW_BASIC",
            BlueprintView::Full => "BLUEPRINT_VIEW_FULL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "BLUEPRINT_VIEW_UNSPECIFIED" => Some(Self::Unspecified),
            "BLUEPRINT_VIEW_BASIC" => Some(Self::Basic),
            "BLUEPRINT_VIEW_FULL" => Some(Self::Full),
            _ => None,
        }
    }
}
/// DeploymentView defines the type of view of the deployment.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum DeploymentView {
    /// Unspecified enum value.
    Unspecified = 0,
    /// View which only contains metadata.
    Basic = 1,
    /// View which contains metadata and files it encapsulates.
    Full = 2,
}
impl DeploymentView {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            DeploymentView::Unspecified => "DEPLOYMENT_VIEW_UNSPECIFIED",
            DeploymentView::Basic => "DEPLOYMENT_VIEW_BASIC",
            DeploymentView::Full => "DEPLOYMENT_VIEW_FULL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "DEPLOYMENT_VIEW_UNSPECIFIED" => Some(Self::Unspecified),
            "DEPLOYMENT_VIEW_BASIC" => Some(Self::Basic),
            "DEPLOYMENT_VIEW_FULL" => Some(Self::Full),
            _ => None,
        }
    }
}
/// Represent type of CR.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ResourceType {
    /// Unspecified resource type.
    Unspecified = 0,
    /// User specified NF Deploy CR.
    NfDeployResource = 1,
    /// CRs that are part of a blueprint.
    DeploymentResource = 2,
}
impl ResourceType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ResourceType::Unspecified => "RESOURCE_TYPE_UNSPECIFIED",
            ResourceType::NfDeployResource => "NF_DEPLOY_RESOURCE",
            ResourceType::DeploymentResource => "DEPLOYMENT_RESOURCE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "RESOURCE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "NF_DEPLOY_RESOURCE" => Some(Self::NfDeployResource),
            "DEPLOYMENT_RESOURCE" => Some(Self::DeploymentResource),
            _ => None,
        }
    }
}
/// Status of an entity (resource, deployment).
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Status {
    /// Unknown state.
    Unspecified = 0,
    /// Under progress.
    InProgress = 1,
    /// Running and ready to serve traffic.
    Active = 2,
    /// Failed or stalled.
    Failed = 3,
    /// Delete in progress.
    Deleting = 4,
    /// Deleted deployment.
    Deleted = 5,
    /// NFDeploy specific status. Peering in progress.
    Peering = 10,
    /// K8s objects such as NetworkAttachmentDefinition don't have a defined
    /// status.
    NotApplicable = 11,
}
impl Status {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Status::Unspecified => "STATUS_UNSPECIFIED",
            Status::InProgress => "STATUS_IN_PROGRESS",
            Status::Active => "STATUS_ACTIVE",
            Status::Failed => "STATUS_FAILED",
            Status::Deleting => "STATUS_DELETING",
            Status::Deleted => "STATUS_DELETED",
            Status::Peering => "STATUS_PEERING",
            Status::NotApplicable => "STATUS_NOT_APPLICABLE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "STATUS_UNSPECIFIED" => Some(Self::Unspecified),
            "STATUS_IN_PROGRESS" => Some(Self::InProgress),
            "STATUS_ACTIVE" => Some(Self::Active),
            "STATUS_FAILED" => Some(Self::Failed),
            "STATUS_DELETING" => Some(Self::Deleting),
            "STATUS_DELETED" => Some(Self::Deleted),
            "STATUS_PEERING" => Some(Self::Peering),
            "STATUS_NOT_APPLICABLE" => Some(Self::NotApplicable),
            _ => None,
        }
    }
}
/// DeploymentLevel of a blueprint signifies where the blueprint will be
/// applied.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum DeploymentLevel {
    /// Default unspecified deployment level.
    Unspecified = 0,
    /// Blueprints at HYDRATION level cannot be used to create a Deployment
    /// (A user cannot manually initate deployment of these blueprints on
    /// orchestration or workload cluster).
    /// These blueprints stay in a user's private catalog and are configured and
    /// deployed by TNA automation.
    Hydration = 1,
    /// Blueprints at SINGLE_DEPLOYMENT level can be
    /// a) Modified in private catalog.
    /// b) Used to create a deployment on orchestration cluster by the user, once
    /// approved.
    SingleDeployment = 2,
    /// Blueprints at MULTI_DEPLOYMENT level can be
    /// a) Modified in private catalog.
    /// b) Used to create a deployment on orchestration cluster which will create
    /// further hydrated deployments.
    MultiDeployment = 3,
    /// Blueprints at WORKLOAD_CLUSTER_DEPLOYMENT level can be
    /// a) Modified in private catalog.
    /// b) Used to create a deployment on workload cluster by the user, once
    /// approved.
    WorkloadClusterDeployment = 4,
}
impl DeploymentLevel {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            DeploymentLevel::Unspecified => "DEPLOYMENT_LEVEL_UNSPECIFIED",
            DeploymentLevel::Hydration => "HYDRATION",
            DeploymentLevel::SingleDeployment => "SINGLE_DEPLOYMENT",
            DeploymentLevel::MultiDeployment => "MULTI_DEPLOYMENT",
            DeploymentLevel::WorkloadClusterDeployment => "WORKLOAD_CLUSTER_DEPLOYMENT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "DEPLOYMENT_LEVEL_UNSPECIFIED" => Some(Self::Unspecified),
            "HYDRATION" => Some(Self::Hydration),
            "SINGLE_DEPLOYMENT" => Some(Self::SingleDeployment),
            "MULTI_DEPLOYMENT" => Some(Self::MultiDeployment),
            "WORKLOAD_CLUSTER_DEPLOYMENT" => Some(Self::WorkloadClusterDeployment),
            _ => None,
        }
    }
}
/// Generated server implementations.
pub mod telco_automation_server {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with TelcoAutomationServer.
    #[async_trait]
    pub trait TelcoAutomation: Send + Sync + 'static {
        /// Lists OrchestrationClusters in a given project and location.
        async fn list_orchestration_clusters(
            &self,
            request: tonic::Request<super::ListOrchestrationClustersRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListOrchestrationClustersResponse>,
            tonic::Status,
        >;
        /// Gets details of a single OrchestrationCluster.
        async fn get_orchestration_cluster(
            &self,
            request: tonic::Request<super::GetOrchestrationClusterRequest>,
        ) -> std::result::Result<
            tonic::Response<super::OrchestrationCluster>,
            tonic::Status,
        >;
        /// Creates a new OrchestrationCluster in a given project and location.
        async fn create_orchestration_cluster(
            &self,
            request: tonic::Request<super::CreateOrchestrationClusterRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        >;
        /// Deletes a single OrchestrationCluster.
        async fn delete_orchestration_cluster(
            &self,
            request: tonic::Request<super::DeleteOrchestrationClusterRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        >;
        /// Lists EdgeSlms in a given project and location.
        async fn list_edge_slms(
            &self,
            request: tonic::Request<super::ListEdgeSlmsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListEdgeSlmsResponse>,
            tonic::Status,
        >;
        /// Gets details of a single EdgeSlm.
        async fn get_edge_slm(
            &self,
            request: tonic::Request<super::GetEdgeSlmRequest>,
        ) -> std::result::Result<tonic::Response<super::EdgeSlm>, tonic::Status>;
        /// Creates a new EdgeSlm in a given project and location.
        async fn create_edge_slm(
            &self,
            request: tonic::Request<super::CreateEdgeSlmRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        >;
        /// Deletes a single EdgeSlm.
        async fn delete_edge_slm(
            &self,
            request: tonic::Request<super::DeleteEdgeSlmRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        >;
        /// Creates a blueprint.
        async fn create_blueprint(
            &self,
            request: tonic::Request<super::CreateBlueprintRequest>,
        ) -> std::result::Result<tonic::Response<super::Blueprint>, tonic::Status>;
        /// Updates a blueprint.
        async fn update_blueprint(
            &self,
            request: tonic::Request<super::UpdateBlueprintRequest>,
        ) -> std::result::Result<tonic::Response<super::Blueprint>, tonic::Status>;
        /// Returns the requested blueprint.
        async fn get_blueprint(
            &self,
            request: tonic::Request<super::GetBlueprintRequest>,
        ) -> std::result::Result<tonic::Response<super::Blueprint>, tonic::Status>;
        /// Deletes a blueprint and all its revisions.
        async fn delete_blueprint(
            &self,
            request: tonic::Request<super::DeleteBlueprintRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status>;
        /// List all blueprints.
        async fn list_blueprints(
            &self,
            request: tonic::Request<super::ListBlueprintsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListBlueprintsResponse>,
            tonic::Status,
        >;
        /// Approves a blueprint and commits a new revision.
        async fn approve_blueprint(
            &self,
            request: tonic::Request<super::ApproveBlueprintRequest>,
        ) -> std::result::Result<tonic::Response<super::Blueprint>, tonic::Status>;
        /// Proposes a blueprint for approval of changes.
        async fn propose_blueprint(
            &self,
            request: tonic::Request<super::ProposeBlueprintRequest>,
        ) -> std::result::Result<tonic::Response<super::Blueprint>, tonic::Status>;
        /// Rejects a blueprint revision proposal and flips it back to Draft state.
        async fn reject_blueprint(
            &self,
            request: tonic::Request<super::RejectBlueprintRequest>,
        ) -> std::result::Result<tonic::Response<super::Blueprint>, tonic::Status>;
        /// List blueprint revisions of a given blueprint.
        async fn list_blueprint_revisions(
            &self,
            request: tonic::Request<super::ListBlueprintRevisionsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListBlueprintRevisionsResponse>,
            tonic::Status,
        >;
        /// Searches across blueprint revisions.
        async fn search_blueprint_revisions(
            &self,
            request: tonic::Request<super::SearchBlueprintRevisionsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SearchBlueprintRevisionsResponse>,
            tonic::Status,
        >;
        /// Searches across deployment revisions.
        async fn search_deployment_revisions(
            &self,
            request: tonic::Request<super::SearchDeploymentRevisionsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SearchDeploymentRevisionsResponse>,
            tonic::Status,
        >;
        /// Discards the changes in a blueprint and reverts the blueprint to the last
        /// approved blueprint revision. No changes take place if a blueprint does not
        /// have revisions.
        async fn discard_blueprint_changes(
            &self,
            request: tonic::Request<super::DiscardBlueprintChangesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DiscardBlueprintChangesResponse>,
            tonic::Status,
        >;
        /// Lists the blueprints in TNA's public catalog. Default page size = 20,
        /// Max Page Size = 100.
        async fn list_public_blueprints(
            &self,
            request: tonic::Request<super::ListPublicBlueprintsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListPublicBlueprintsResponse>,
            tonic::Status,
        >;
        /// Returns the requested public blueprint.
        async fn get_public_blueprint(
            &self,
            request: tonic::Request<super::GetPublicBlueprintRequest>,
        ) -> std::result::Result<tonic::Response<super::PublicBlueprint>, tonic::Status>;
        /// Creates a deployment.
        async fn create_deployment(
            &self,
            request: tonic::Request<super::CreateDeploymentRequest>,
        ) -> std::result::Result<tonic::Response<super::Deployment>, tonic::Status>;
        /// Updates a deployment.
        async fn update_deployment(
            &self,
            request: tonic::Request<super::UpdateDeploymentRequest>,
        ) -> std::result::Result<tonic::Response<super::Deployment>, tonic::Status>;
        /// Returns the requested deployment.
        async fn get_deployment(
            &self,
            request: tonic::Request<super::GetDeploymentRequest>,
        ) -> std::result::Result<tonic::Response<super::Deployment>, tonic::Status>;
        /// Removes the deployment by marking it as DELETING. Post which deployment and
        /// it's revisions gets deleted.
        async fn remove_deployment(
            &self,
            request: tonic::Request<super::RemoveDeploymentRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status>;
        /// List all deployments.
        async fn list_deployments(
            &self,
            request: tonic::Request<super::ListDeploymentsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListDeploymentsResponse>,
            tonic::Status,
        >;
        /// List deployment revisions of a given deployment.
        async fn list_deployment_revisions(
            &self,
            request: tonic::Request<super::ListDeploymentRevisionsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListDeploymentRevisionsResponse>,
            tonic::Status,
        >;
        /// Discards the changes in a deployment and reverts the deployment to the last
        /// approved deployment revision. No changes take place if a deployment does
        /// not have revisions.
        async fn discard_deployment_changes(
            &self,
            request: tonic::Request<super::DiscardDeploymentChangesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DiscardDeploymentChangesResponse>,
            tonic::Status,
        >;
        /// Applies the deployment's YAML files to the parent orchestration cluster.
        async fn apply_deployment(
            &self,
            request: tonic::Request<super::ApplyDeploymentRequest>,
        ) -> std::result::Result<tonic::Response<super::Deployment>, tonic::Status>;
        /// Returns the requested deployment status.
        async fn compute_deployment_status(
            &self,
            request: tonic::Request<super::ComputeDeploymentStatusRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ComputeDeploymentStatusResponse>,
            tonic::Status,
        >;
        /// Rollback the active deployment to the given past approved deployment
        /// revision.
        async fn rollback_deployment(
            &self,
            request: tonic::Request<super::RollbackDeploymentRequest>,
        ) -> std::result::Result<tonic::Response<super::Deployment>, tonic::Status>;
        /// Returns the requested hydrated deployment.
        async fn get_hydrated_deployment(
            &self,
            request: tonic::Request<super::GetHydratedDeploymentRequest>,
        ) -> std::result::Result<
            tonic::Response<super::HydratedDeployment>,
            tonic::Status,
        >;
        /// List all hydrated deployments present under a deployment.
        async fn list_hydrated_deployments(
            &self,
            request: tonic::Request<super::ListHydratedDeploymentsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListHydratedDeploymentsResponse>,
            tonic::Status,
        >;
        /// Updates a hydrated deployment.
        async fn update_hydrated_deployment(
            &self,
            request: tonic::Request<super::UpdateHydratedDeploymentRequest>,
        ) -> std::result::Result<
            tonic::Response<super::HydratedDeployment>,
            tonic::Status,
        >;
        /// Applies a hydrated deployment to a workload cluster.
        async fn apply_hydrated_deployment(
            &self,
            request: tonic::Request<super::ApplyHydratedDeploymentRequest>,
        ) -> std::result::Result<
            tonic::Response<super::HydratedDeployment>,
            tonic::Status,
        >;
    }
    /// TelcoAutomation Service manages the control plane cluster a.k.a.
    /// Orchestration Cluster (GKE cluster with config controller) of TNA. It also
    /// exposes blueprint APIs which manages the lifecycle of blueprints that control
    /// the infrastructure setup (e.g GDCE clusters) and deployment of network
    /// functions.
    #[derive(Debug)]
    pub struct TelcoAutomationServer<T: TelcoAutomation> {
        inner: _Inner<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    struct _Inner<T>(Arc<T>);
    impl<T: TelcoAutomation> TelcoAutomationServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            let inner = _Inner(inner);
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for TelcoAutomationServer<T>
    where
        T: TelcoAutomation,
        B: Body + Send + 'static,
        B::Error: Into<StdError> + Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            let inner = self.inner.clone();
            match req.uri().path() {
                "/google.cloud.telcoautomation.v1.TelcoAutomation/ListOrchestrationClusters" => {
                    #[allow(non_camel_case_types)]
                    struct ListOrchestrationClustersSvc<T: TelcoAutomation>(pub Arc<T>);
                    impl<
                        T: TelcoAutomation,
                    > tonic::server::UnaryService<
                        super::ListOrchestrationClustersRequest,
                    > for ListOrchestrationClustersSvc<T> {
                        type Response = super::ListOrchestrationClustersResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::ListOrchestrationClustersRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as TelcoAutomation>::list_orchestration_clusters(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = ListOrchestrationClustersSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.telcoautomation.v1.TelcoAutomation/GetOrchestrationCluster" => {
                    #[allow(non_camel_case_types)]
                    struct GetOrchestrationClusterSvc<T: TelcoAutomation>(pub Arc<T>);
                    impl<
                        T: TelcoAutomation,
                    > tonic::server::UnaryService<super::GetOrchestrationClusterRequest>
                    for GetOrchestrationClusterSvc<T> {
                        type Response = super::OrchestrationCluster;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::GetOrchestrationClusterRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as TelcoAutomation>::get_orchestration_cluster(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = GetOrchestrationClusterSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.telcoautomation.v1.TelcoAutomation/CreateOrchestrationCluster" => {
                    #[allow(non_camel_case_types)]
                    struct CreateOrchestrationClusterSvc<T: TelcoAutomation>(pub Arc<T>);
                    impl<
                        T: TelcoAutomation,
                    > tonic::server::UnaryService<
                        super::CreateOrchestrationClusterRequest,
                    > for CreateOrchestrationClusterSvc<T> {
                        type Response = super::super::super::super::longrunning::Operation;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::CreateOrchestrationClusterRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as TelcoAutomation>::create_orchestration_cluster(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = CreateOrchestrationClusterSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.telcoautomation.v1.TelcoAutomation/DeleteOrchestrationCluster" => {
                    #[allow(non_camel_case_types)]
                    struct DeleteOrchestrationClusterSvc<T: TelcoAutomation>(pub Arc<T>);
                    impl<
                        T: TelcoAutomation,
                    > tonic::server::UnaryService<
                        super::DeleteOrchestrationClusterRequest,
                    > for DeleteOrchestrationClusterSvc<T> {
                        type Response = super::super::super::super::longrunning::Operation;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::DeleteOrchestrationClusterRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as TelcoAutomation>::delete_orchestration_cluster(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = DeleteOrchestrationClusterSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.telcoautomation.v1.TelcoAutomation/ListEdgeSlms" => {
                    #[allow(non_camel_case_types)]
                    struct ListEdgeSlmsSvc<T: TelcoAutomation>(pub Arc<T>);
                    impl<
                        T: TelcoAutomation,
                    > tonic::server::UnaryService<super::ListEdgeSlmsRequest>
                    for ListEdgeSlmsSvc<T> {
                        type Response = super::ListEdgeSlmsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ListEdgeSlmsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as TelcoAutomation>::list_edge_slms(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = ListEdgeSlmsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.telcoautomation.v1.TelcoAutomation/GetEdgeSlm" => {
                    #[allow(non_camel_case_types)]
                    struct GetEdgeSlmSvc<T: TelcoAutomation>(pub Arc<T>);
                    impl<
                        T: TelcoAutomation,
                    > tonic::server::UnaryService<super::GetEdgeSlmRequest>
                    for GetEdgeSlmSvc<T> {
                        type Response = super::EdgeSlm;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetEdgeSlmRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as TelcoAutomation>::get_edge_slm(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = GetEdgeSlmSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.telcoautomation.v1.TelcoAutomation/CreateEdgeSlm" => {
                    #[allow(non_camel_case_types)]
                    struct CreateEdgeSlmSvc<T: TelcoAutomation>(pub Arc<T>);
                    impl<
                        T: TelcoAutomation,
                    > tonic::server::UnaryService<super::CreateEdgeSlmRequest>
                    for CreateEdgeSlmSvc<T> {
                        type Response = super::super::super::super::longrunning::Operation;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::CreateEdgeSlmRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as TelcoAutomation>::create_edge_slm(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = CreateEdgeSlmSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.telcoautomation.v1.TelcoAutomation/DeleteEdgeSlm" => {
                    #[allow(non_camel_case_types)]
                    struct DeleteEdgeSlmSvc<T: TelcoAutomation>(pub Arc<T>);
                    impl<
                        T: TelcoAutomation,
                    > tonic::server::UnaryService<super::DeleteEdgeSlmRequest>
                    for DeleteEdgeSlmSvc<T> {
                        type Response = super::super::super::super::longrunning::Operation;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DeleteEdgeSlmRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as TelcoAutomation>::delete_edge_slm(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = DeleteEdgeSlmSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.telcoautomation.v1.TelcoAutomation/CreateBlueprint" => {
                    #[allow(non_camel_case_types)]
                    struct CreateBlueprintSvc<T: TelcoAutomation>(pub Arc<T>);
                    impl<
                        T: TelcoAutomation,
                    > tonic::server::UnaryService<super::CreateBlueprintRequest>
                    for CreateBlueprintSvc<T> {
                        type Response = super::Blueprint;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::CreateBlueprintRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as TelcoAutomation>::create_blueprint(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = CreateBlueprintSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.telcoautomation.v1.TelcoAutomation/UpdateBlueprint" => {
                    #[allow(non_camel_case_types)]
                    struct UpdateBlueprintSvc<T: TelcoAutomation>(pub Arc<T>);
                    impl<
                        T: TelcoAutomation,
                    > tonic::server::UnaryService<super::UpdateBlueprintRequest>
                    for UpdateBlueprintSvc<T> {
                        type Response = super::Blueprint;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::UpdateBlueprintRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as TelcoAutomation>::update_blueprint(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = UpdateBlueprintSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.telcoautomation.v1.TelcoAutomation/GetBlueprint" => {
                    #[allow(non_camel_case_types)]
                    struct GetBlueprintSvc<T: TelcoAutomation>(pub Arc<T>);
                    impl<
                        T: TelcoAutomation,
                    > tonic::server::UnaryService<super::GetBlueprintRequest>
                    for GetBlueprintSvc<T> {
                        type Response = super::Blueprint;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetBlueprintRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as TelcoAutomation>::get_blueprint(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = GetBlueprintSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.telcoautomation.v1.TelcoAutomation/DeleteBlueprint" => {
                    #[allow(non_camel_case_types)]
                    struct DeleteBlueprintSvc<T: TelcoAutomation>(pub Arc<T>);
                    impl<
                        T: TelcoAutomation,
                    > tonic::server::UnaryService<super::DeleteBlueprintRequest>
                    for DeleteBlueprintSvc<T> {
                        type Response = ();
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DeleteBlueprintRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as TelcoAutomation>::delete_blueprint(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = DeleteBlueprintSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.telcoautomation.v1.TelcoAutomation/ListBlueprints" => {
                    #[allow(non_camel_case_types)]
                    struct ListBlueprintsSvc<T: TelcoAutomation>(pub Arc<T>);
                    impl<
                        T: TelcoAutomation,
                    > tonic::server::UnaryService<super::ListBlueprintsRequest>
                    for ListBlueprintsSvc<T> {
                        type Response = super::ListBlueprintsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ListBlueprintsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as TelcoAutomation>::list_blueprints(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = ListBlueprintsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.telcoautomation.v1.TelcoAutomation/ApproveBlueprint" => {
                    #[allow(non_camel_case_types)]
                    struct ApproveBlueprintSvc<T: TelcoAutomation>(pub Arc<T>);
                    impl<
                        T: TelcoAutomation,
                    > tonic::server::UnaryService<super::ApproveBlueprintRequest>
                    for ApproveBlueprintSvc<T> {
                        type Response = super::Blueprint;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ApproveBlueprintRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as TelcoAutomation>::approve_blueprint(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = ApproveBlueprintSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.telcoautomation.v1.TelcoAutomation/ProposeBlueprint" => {
                    #[allow(non_camel_case_types)]
                    struct ProposeBlueprintSvc<T: TelcoAutomation>(pub Arc<T>);
                    impl<
                        T: TelcoAutomation,
                    > tonic::server::UnaryService<super::ProposeBlueprintRequest>
                    for ProposeBlueprintSvc<T> {
                        type Response = super::Blueprint;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ProposeBlueprintRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as TelcoAutomation>::propose_blueprint(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = ProposeBlueprintSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.telcoautomation.v1.TelcoAutomation/RejectBlueprint" => {
                    #[allow(non_camel_case_types)]
                    struct RejectBlueprintSvc<T: TelcoAutomation>(pub Arc<T>);
                    impl<
                        T: TelcoAutomation,
                    > tonic::server::UnaryService<super::RejectBlueprintRequest>
                    for RejectBlueprintSvc<T> {
                        type Response = super::Blueprint;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::RejectBlueprintRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as TelcoAutomation>::reject_blueprint(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = RejectBlueprintSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.telcoautomation.v1.TelcoAutomation/ListBlueprintRevisions" => {
                    #[allow(non_camel_case_types)]
                    struct ListBlueprintRevisionsSvc<T: TelcoAutomation>(pub Arc<T>);
                    impl<
                        T: TelcoAutomation,
                    > tonic::server::UnaryService<super::ListBlueprintRevisionsRequest>
                    for ListBlueprintRevisionsSvc<T> {
                        type Response = super::ListBlueprintRevisionsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ListBlueprintRevisionsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as TelcoAutomation>::list_blueprint_revisions(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = ListBlueprintRevisionsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.telcoautomation.v1.TelcoAutomation/SearchBlueprintRevisions" => {
                    #[allow(non_camel_case_types)]
                    struct SearchBlueprintRevisionsSvc<T: TelcoAutomation>(pub Arc<T>);
                    impl<
                        T: TelcoAutomation,
                    > tonic::server::UnaryService<super::SearchBlueprintRevisionsRequest>
                    for SearchBlueprintRevisionsSvc<T> {
                        type Response = super::SearchBlueprintRevisionsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::SearchBlueprintRevisionsRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as TelcoAutomation>::search_blueprint_revisions(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = SearchBlueprintRevisionsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.telcoautomation.v1.TelcoAutomation/SearchDeploymentRevisions" => {
                    #[allow(non_camel_case_types)]
                    struct SearchDeploymentRevisionsSvc<T: TelcoAutomation>(pub Arc<T>);
                    impl<
                        T: TelcoAutomation,
                    > tonic::server::UnaryService<
                        super::SearchDeploymentRevisionsRequest,
                    > for SearchDeploymentRevisionsSvc<T> {
                        type Response = super::SearchDeploymentRevisionsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::SearchDeploymentRevisionsRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as TelcoAutomation>::search_deployment_revisions(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = SearchDeploymentRevisionsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.telcoautomation.v1.TelcoAutomation/DiscardBlueprintChanges" => {
                    #[allow(non_camel_case_types)]
                    struct DiscardBlueprintChangesSvc<T: TelcoAutomation>(pub Arc<T>);
                    impl<
                        T: TelcoAutomation,
                    > tonic::server::UnaryService<super::DiscardBlueprintChangesRequest>
                    for DiscardBlueprintChangesSvc<T> {
                        type Response = super::DiscardBlueprintChangesResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::DiscardBlueprintChangesRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as TelcoAutomation>::discard_blueprint_changes(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = DiscardBlueprintChangesSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.telcoautomation.v1.TelcoAutomation/ListPublicBlueprints" => {
                    #[allow(non_camel_case_types)]
                    struct ListPublicBlueprintsSvc<T: TelcoAutomation>(pub Arc<T>);
                    impl<
                        T: TelcoAutomation,
                    > tonic::server::UnaryService<super::ListPublicBlueprintsRequest>
                    for ListPublicBlueprintsSvc<T> {
                        type Response = super::ListPublicBlueprintsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ListPublicBlueprintsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as TelcoAutomation>::list_public_blueprints(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = ListPublicBlueprintsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.telcoautomation.v1.TelcoAutomation/GetPublicBlueprint" => {
                    #[allow(non_camel_case_types)]
                    struct GetPublicBlueprintSvc<T: TelcoAutomation>(pub Arc<T>);
                    impl<
                        T: TelcoAutomation,
                    > tonic::server::UnaryService<super::GetPublicBlueprintRequest>
                    for GetPublicBlueprintSvc<T> {
                        type Response = super::PublicBlueprint;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetPublicBlueprintRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as TelcoAutomation>::get_public_blueprint(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = GetPublicBlueprintSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.telcoautomation.v1.TelcoAutomation/CreateDeployment" => {
                    #[allow(non_camel_case_types)]
                    struct CreateDeploymentSvc<T: TelcoAutomation>(pub Arc<T>);
                    impl<
                        T: TelcoAutomation,
                    > tonic::server::UnaryService<super::CreateDeploymentRequest>
                    for CreateDeploymentSvc<T> {
                        type Response = super::Deployment;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::CreateDeploymentRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as TelcoAutomation>::create_deployment(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = CreateDeploymentSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.telcoautomation.v1.TelcoAutomation/UpdateDeployment" => {
                    #[allow(non_camel_case_types)]
                    struct UpdateDeploymentSvc<T: TelcoAutomation>(pub Arc<T>);
                    impl<
                        T: TelcoAutomation,
                    > tonic::server::UnaryService<super::UpdateDeploymentRequest>
                    for UpdateDeploymentSvc<T> {
                        type Response = super::Deployment;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::UpdateDeploymentRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as TelcoAutomation>::update_deployment(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = UpdateDeploymentSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.telcoautomation.v1.TelcoAutomation/GetDeployment" => {
                    #[allow(non_camel_case_types)]
                    struct GetDeploymentSvc<T: TelcoAutomation>(pub Arc<T>);
                    impl<
                        T: TelcoAutomation,
                    > tonic::server::UnaryService<super::GetDeploymentRequest>
                    for GetDeploymentSvc<T> {
                        type Response = super::Deployment;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetDeploymentRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as TelcoAutomation>::get_deployment(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = GetDeploymentSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.telcoautomation.v1.TelcoAutomation/RemoveDeployment" => {
                    #[allow(non_camel_case_types)]
                    struct RemoveDeploymentSvc<T: TelcoAutomation>(pub Arc<T>);
                    impl<
                        T: TelcoAutomation,
                    > tonic::server::UnaryService<super::RemoveDeploymentRequest>
                    for RemoveDeploymentSvc<T> {
                        type Response = ();
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::RemoveDeploymentRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as TelcoAutomation>::remove_deployment(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = RemoveDeploymentSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.telcoautomation.v1.TelcoAutomation/ListDeployments" => {
                    #[allow(non_camel_case_types)]
                    struct ListDeploymentsSvc<T: TelcoAutomation>(pub Arc<T>);
                    impl<
                        T: TelcoAutomation,
                    > tonic::server::UnaryService<super::ListDeploymentsRequest>
                    for ListDeploymentsSvc<T> {
                        type Response = super::ListDeploymentsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ListDeploymentsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as TelcoAutomation>::list_deployments(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = ListDeploymentsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.telcoautomation.v1.TelcoAutomation/ListDeploymentRevisions" => {
                    #[allow(non_camel_case_types)]
                    struct ListDeploymentRevisionsSvc<T: TelcoAutomation>(pub Arc<T>);
                    impl<
                        T: TelcoAutomation,
                    > tonic::server::UnaryService<super::ListDeploymentRevisionsRequest>
                    for ListDeploymentRevisionsSvc<T> {
                        type Response = super::ListDeploymentRevisionsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::ListDeploymentRevisionsRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as TelcoAutomation>::list_deployment_revisions(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = ListDeploymentRevisionsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.telcoautomation.v1.TelcoAutomation/DiscardDeploymentChanges" => {
                    #[allow(non_camel_case_types)]
                    struct DiscardDeploymentChangesSvc<T: TelcoAutomation>(pub Arc<T>);
                    impl<
                        T: TelcoAutomation,
                    > tonic::server::UnaryService<super::DiscardDeploymentChangesRequest>
                    for DiscardDeploymentChangesSvc<T> {
                        type Response = super::DiscardDeploymentChangesResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::DiscardDeploymentChangesRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as TelcoAutomation>::discard_deployment_changes(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = DiscardDeploymentChangesSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.telcoautomation.v1.TelcoAutomation/ApplyDeployment" => {
                    #[allow(non_camel_case_types)]
                    struct ApplyDeploymentSvc<T: TelcoAutomation>(pub Arc<T>);
                    impl<
                        T: TelcoAutomation,
                    > tonic::server::UnaryService<super::ApplyDeploymentRequest>
                    for ApplyDeploymentSvc<T> {
                        type Response = super::Deployment;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ApplyDeploymentRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as TelcoAutomation>::apply_deployment(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = ApplyDeploymentSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.telcoautomation.v1.TelcoAutomation/ComputeDeploymentStatus" => {
                    #[allow(non_camel_case_types)]
                    struct ComputeDeploymentStatusSvc<T: TelcoAutomation>(pub Arc<T>);
                    impl<
                        T: TelcoAutomation,
                    > tonic::server::UnaryService<super::ComputeDeploymentStatusRequest>
                    for ComputeDeploymentStatusSvc<T> {
                        type Response = super::ComputeDeploymentStatusResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::ComputeDeploymentStatusRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as TelcoAutomation>::compute_deployment_status(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = ComputeDeploymentStatusSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.telcoautomation.v1.TelcoAutomation/RollbackDeployment" => {
                    #[allow(non_camel_case_types)]
                    struct RollbackDeploymentSvc<T: TelcoAutomation>(pub Arc<T>);
                    impl<
                        T: TelcoAutomation,
                    > tonic::server::UnaryService<super::RollbackDeploymentRequest>
                    for RollbackDeploymentSvc<T> {
                        type Response = super::Deployment;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::RollbackDeploymentRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as TelcoAutomation>::rollback_deployment(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = RollbackDeploymentSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.telcoautomation.v1.TelcoAutomation/GetHydratedDeployment" => {
                    #[allow(non_camel_case_types)]
                    struct GetHydratedDeploymentSvc<T: TelcoAutomation>(pub Arc<T>);
                    impl<
                        T: TelcoAutomation,
                    > tonic::server::UnaryService<super::GetHydratedDeploymentRequest>
                    for GetHydratedDeploymentSvc<T> {
                        type Response = super::HydratedDeployment;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetHydratedDeploymentRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as TelcoAutomation>::get_hydrated_deployment(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = GetHydratedDeploymentSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.telcoautomation.v1.TelcoAutomation/ListHydratedDeployments" => {
                    #[allow(non_camel_case_types)]
                    struct ListHydratedDeploymentsSvc<T: TelcoAutomation>(pub Arc<T>);
                    impl<
                        T: TelcoAutomation,
                    > tonic::server::UnaryService<super::ListHydratedDeploymentsRequest>
                    for ListHydratedDeploymentsSvc<T> {
                        type Response = super::ListHydratedDeploymentsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::ListHydratedDeploymentsRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as TelcoAutomation>::list_hydrated_deployments(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = ListHydratedDeploymentsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.telcoautomation.v1.TelcoAutomation/UpdateHydratedDeployment" => {
                    #[allow(non_camel_case_types)]
                    struct UpdateHydratedDeploymentSvc<T: TelcoAutomation>(pub Arc<T>);
                    impl<
                        T: TelcoAutomation,
                    > tonic::server::UnaryService<super::UpdateHydratedDeploymentRequest>
                    for UpdateHydratedDeploymentSvc<T> {
                        type Response = super::HydratedDeployment;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::UpdateHydratedDeploymentRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as TelcoAutomation>::update_hydrated_deployment(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = UpdateHydratedDeploymentSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.telcoautomation.v1.TelcoAutomation/ApplyHydratedDeployment" => {
                    #[allow(non_camel_case_types)]
                    struct ApplyHydratedDeploymentSvc<T: TelcoAutomation>(pub Arc<T>);
                    impl<
                        T: TelcoAutomation,
                    > tonic::server::UnaryService<super::ApplyHydratedDeploymentRequest>
                    for ApplyHydratedDeploymentSvc<T> {
                        type Response = super::HydratedDeployment;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::ApplyHydratedDeploymentRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as TelcoAutomation>::apply_hydrated_deployment(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = ApplyHydratedDeploymentSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        Ok(
                            http::Response::builder()
                                .status(200)
                                .header("grpc-status", "12")
                                .header("content-type", "application/grpc")
                                .body(empty_body())
                                .unwrap(),
                        )
                    })
                }
            }
        }
    }
    impl<T: TelcoAutomation> Clone for TelcoAutomationServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    impl<T: TelcoAutomation> Clone for _Inner<T> {
        fn clone(&self) -> Self {
            Self(Arc::clone(&self.0))
        }
    }
    impl<T: std::fmt::Debug> std::fmt::Debug for _Inner<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{:?}", self.0)
        }
    }
    impl<T: TelcoAutomation> tonic::server::NamedService for TelcoAutomationServer<T> {
        const NAME: &'static str = "google.cloud.telcoautomation.v1.TelcoAutomation";
    }
}
