// This file is @generated by prost-build.
/// The representation of a key managed by the API Keys API.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Key {
    /// Output only. The resource name of the key.
    /// The `name` has the form:
    /// `projects/<PROJECT_NUMBER>/locations/global/keys/<KEY_ID>`.
    /// For example:
    /// `projects/123456867718/locations/global/keys/b7ff1f9f-8275-410a-94dd-3855ee9b5dd2`
    ///
    /// NOTE: Key is a global resource; hence the only supported value for
    /// location is `global`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. Unique id in UUID4 format.
    #[prost(string, tag = "5")]
    pub uid: ::prost::alloc::string::String,
    /// Human-readable display name of this key that you can modify.
    /// The maximum length is 63 characters.
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    /// Output only. An encrypted and signed value held by this key.
    /// This field can be accessed only through the `GetKeyString` method.
    #[prost(string, tag = "3")]
    pub key_string: ::prost::alloc::string::String,
    /// Output only. A timestamp identifying the time this key was originally
    /// created.
    #[prost(message, optional, tag = "4")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. A timestamp identifying the time this key was last
    /// updated.
    #[prost(message, optional, tag = "6")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. A timestamp when this key was deleted. If the resource is not
    /// deleted, this must be empty.
    #[prost(message, optional, tag = "7")]
    pub delete_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Annotations is an unstructured key-value map stored with a policy that
    /// may be set by external tools to store and retrieve arbitrary metadata.
    /// They are not queryable and should be preserved when modifying objects.
    #[prost(map = "string, string", tag = "8")]
    pub annotations: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Key restrictions.
    #[prost(message, optional, tag = "9")]
    pub restrictions: ::core::option::Option<Restrictions>,
    /// Output only. A checksum computed by the server based on the current value
    /// of the Key resource. This may be sent on update and delete requests to
    /// ensure the client has an up-to-date value before proceeding. See
    /// <https://google.aip.dev/154.>
    #[prost(string, tag = "11")]
    pub etag: ::prost::alloc::string::String,
}
/// Describes the restrictions on the key.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Restrictions {
    /// A restriction for a specific service and optionally one or
    /// more specific methods. Requests are allowed if they
    /// match any of these restrictions. If no restrictions are
    /// specified, all targets are allowed.
    #[prost(message, repeated, tag = "5")]
    pub api_targets: ::prost::alloc::vec::Vec<ApiTarget>,
    /// The websites, IP addresses, Android apps, or iOS apps (the clients) that
    /// are allowed to use the key. You can specify only one type of client
    /// restrictions per key.
    #[prost(oneof = "restrictions::ClientRestrictions", tags = "1, 2, 3, 4")]
    pub client_restrictions: ::core::option::Option<restrictions::ClientRestrictions>,
}
/// Nested message and enum types in `Restrictions`.
pub mod restrictions {
    /// The websites, IP addresses, Android apps, or iOS apps (the clients) that
    /// are allowed to use the key. You can specify only one type of client
    /// restrictions per key.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum ClientRestrictions {
        /// The HTTP referrers (websites) that are allowed to use the key.
        #[prost(message, tag = "1")]
        BrowserKeyRestrictions(super::BrowserKeyRestrictions),
        /// The IP addresses of callers that are allowed to use the key.
        #[prost(message, tag = "2")]
        ServerKeyRestrictions(super::ServerKeyRestrictions),
        /// The Android apps that are allowed to use the key.
        #[prost(message, tag = "3")]
        AndroidKeyRestrictions(super::AndroidKeyRestrictions),
        /// The iOS apps that are allowed to use the key.
        #[prost(message, tag = "4")]
        IosKeyRestrictions(super::IosKeyRestrictions),
    }
}
/// The HTTP referrers (websites) that are allowed to use the key.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BrowserKeyRestrictions {
    /// A list of regular expressions for the referrer URLs that are allowed
    /// to make API calls with this key.
    #[prost(string, repeated, tag = "1")]
    pub allowed_referrers: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// The IP addresses of callers that are allowed to use the key.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ServerKeyRestrictions {
    /// A list of the caller IP addresses that are allowed to make API calls
    /// with this key.
    #[prost(string, repeated, tag = "1")]
    pub allowed_ips: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// The Android apps that are allowed to use the key.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AndroidKeyRestrictions {
    /// A list of Android applications that are allowed to make API calls with
    /// this key.
    #[prost(message, repeated, tag = "1")]
    pub allowed_applications: ::prost::alloc::vec::Vec<AndroidApplication>,
}
/// Identifier of an Android application for key use.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AndroidApplication {
    /// The SHA1 fingerprint of the application. For example, both sha1 formats are
    /// acceptable : DA:39:A3:EE:5E:6B:4B:0D:32:55:BF:EF:95:60:18:90:AF:D8:07:09 or
    /// DA39A3EE5E6B4B0D3255BFEF95601890AFD80709.
    /// Output format is the latter.
    #[prost(string, tag = "1")]
    pub sha1_fingerprint: ::prost::alloc::string::String,
    /// The package name of the application.
    #[prost(string, tag = "2")]
    pub package_name: ::prost::alloc::string::String,
}
/// The iOS apps that are allowed to use the key.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IosKeyRestrictions {
    /// A list of bundle IDs that are allowed when making API calls with this key.
    #[prost(string, repeated, tag = "1")]
    pub allowed_bundle_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// A restriction for a specific service and optionally one or multiple
/// specific methods. Both fields are case insensitive.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ApiTarget {
    /// The service for this restriction. It should be the canonical
    /// service name, for example: `translate.googleapis.com`.
    /// You can use [`gcloud services list`](/sdk/gcloud/reference/services/list)
    /// to get a list of services that are enabled in the project.
    #[prost(string, tag = "1")]
    pub service: ::prost::alloc::string::String,
    /// Optional. List of one or more methods that can be called.
    /// If empty, all methods for the service are allowed. A wildcard
    /// (*) can be used as the last symbol.
    /// Valid examples:
    ///    `google.cloud.translate.v2.TranslateService.GetSupportedLanguage`
    ///    `TranslateText`
    ///    `Get*`
    ///    `translate.googleapis.com.Get*`
    #[prost(string, repeated, tag = "2")]
    pub methods: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Request message for `CreateKey` method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateKeyRequest {
    /// Required. The project in which the API key is created.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The API key fields to set at creation time.
    /// You can configure only the `display_name`, `restrictions`, and
    /// `annotations` fields.
    #[prost(message, optional, tag = "2")]
    pub key: ::core::option::Option<Key>,
    /// User specified key id (optional). If specified, it will become the final
    /// component of the key resource name.
    ///
    /// The id must be unique within the project, must conform with RFC-1034,
    /// is restricted to lower-cased letters, and has a maximum length of 63
    /// characters. In another word, the id must match the regular
    /// expression: `[a-z](\[a-z0-9-\]{0,61}\[a-z0-9\])?`.
    ///
    /// The id must NOT be a UUID-like string.
    #[prost(string, tag = "3")]
    pub key_id: ::prost::alloc::string::String,
}
/// Request message for `ListKeys` method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListKeysRequest {
    /// Required. Lists all API keys associated with this project.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. Specifies the maximum number of results to be returned at a time.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. Requests a specific page of results.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. Indicate that keys deleted in the past 30 days should also be
    /// returned.
    #[prost(bool, tag = "6")]
    pub show_deleted: bool,
}
/// Response message for `ListKeys` method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListKeysResponse {
    /// A list of API keys.
    #[prost(message, repeated, tag = "1")]
    pub keys: ::prost::alloc::vec::Vec<Key>,
    /// The pagination token for the next page of results.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// Request message for `GetKey` method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetKeyRequest {
    /// Required. The resource name of the API key to get.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request message for `GetKeyString` method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetKeyStringRequest {
    /// Required. The resource name of the API key to be retrieved.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Response message for `GetKeyString` method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetKeyStringResponse {
    /// An encrypted and signed value of the key.
    #[prost(string, tag = "1")]
    pub key_string: ::prost::alloc::string::String,
}
/// Request message for `UpdateKey` method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateKeyRequest {
    /// Required. Set the `name` field to the resource name of the API key to be
    /// updated. You can update only the `display_name`, `restrictions`, and
    /// `annotations` fields.
    #[prost(message, optional, tag = "1")]
    pub key: ::core::option::Option<Key>,
    /// The field mask specifies which fields to be updated as part of this
    /// request. All other fields are ignored.
    /// Mutable fields are: `display_name`, `restrictions`, and `annotations`.
    /// If an update mask is not provided, the service treats it as an implied mask
    /// equivalent to all allowed fields that are set on the wire. If the field
    /// mask has a special value "*", the service treats it equivalent to replace
    /// all allowed mutable fields.
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
/// Request message for `DeleteKey` method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteKeyRequest {
    /// Required. The resource name of the API key to be deleted.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. The etag known to the client for the expected state of the key.
    /// This is to be used for optimistic concurrency.
    #[prost(string, tag = "2")]
    pub etag: ::prost::alloc::string::String,
}
/// Request message for `UndeleteKey` method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UndeleteKeyRequest {
    /// Required. The resource name of the API key to be undeleted.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request message for `LookupKey` method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LookupKeyRequest {
    /// Required. Finds the project that owns the key string value.
    #[prost(string, tag = "1")]
    pub key_string: ::prost::alloc::string::String,
}
/// Response message for `LookupKey` method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LookupKeyResponse {
    /// The project that owns the key with the value specified in the request.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// The resource name of the API key. If the API key has been purged,
    /// resource name is empty.
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
}
/// Generated server implementations.
pub mod api_keys_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with ApiKeysServer.
    #[async_trait]
    pub trait ApiKeys: std::marker::Send + std::marker::Sync + 'static {
        /// Creates a new API key.
        ///
        /// NOTE: Key is a global resource; hence the only supported value for
        /// location is `global`.
        async fn create_key(
            &self,
            request: tonic::Request<super::CreateKeyRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        >;
        /// Lists the API keys owned by a project. The key string of the API key
        /// isn't included in the response.
        ///
        /// NOTE: Key is a global resource; hence the only supported value for
        /// location is `global`.
        async fn list_keys(
            &self,
            request: tonic::Request<super::ListKeysRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListKeysResponse>,
            tonic::Status,
        >;
        /// Gets the metadata for an API key. The key string of the API key
        /// isn't included in the response.
        ///
        /// NOTE: Key is a global resource; hence the only supported value for
        /// location is `global`.
        async fn get_key(
            &self,
            request: tonic::Request<super::GetKeyRequest>,
        ) -> std::result::Result<tonic::Response<super::Key>, tonic::Status>;
        /// Get the key string for an API key.
        ///
        /// NOTE: Key is a global resource; hence the only supported value for
        /// location is `global`.
        async fn get_key_string(
            &self,
            request: tonic::Request<super::GetKeyStringRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetKeyStringResponse>,
            tonic::Status,
        >;
        /// Patches the modifiable fields of an API key.
        /// The key string of the API key isn't included in the response.
        ///
        /// NOTE: Key is a global resource; hence the only supported value for
        /// location is `global`.
        async fn update_key(
            &self,
            request: tonic::Request<super::UpdateKeyRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        >;
        /// Deletes an API key. Deleted key can be retrieved within 30 days of
        /// deletion. Afterward, key will be purged from the project.
        ///
        /// NOTE: Key is a global resource; hence the only supported value for
        /// location is `global`.
        async fn delete_key(
            &self,
            request: tonic::Request<super::DeleteKeyRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        >;
        /// Undeletes an API key which was deleted within 30 days.
        ///
        /// NOTE: Key is a global resource; hence the only supported value for
        /// location is `global`.
        async fn undelete_key(
            &self,
            request: tonic::Request<super::UndeleteKeyRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        >;
        /// Find the parent project and resource name of the API
        /// key that matches the key string in the request. If the API key has been
        /// purged, resource name will not be set.
        /// The service account must have the `apikeys.keys.lookup` permission
        /// on the parent project.
        async fn lookup_key(
            &self,
            request: tonic::Request<super::LookupKeyRequest>,
        ) -> std::result::Result<
            tonic::Response<super::LookupKeyResponse>,
            tonic::Status,
        >;
    }
    /// Manages the API keys associated with projects.
    #[derive(Debug)]
    pub struct ApiKeysServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> ApiKeysServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for ApiKeysServer<T>
    where
        T: ApiKeys,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/google.api.apikeys.v2.ApiKeys/CreateKey" => {
                    #[allow(non_camel_case_types)]
                    struct CreateKeySvc<T: ApiKeys>(pub Arc<T>);
                    impl<T: ApiKeys> tonic::server::UnaryService<super::CreateKeyRequest>
                    for CreateKeySvc<T> {
                        type Response = super::super::super::super::longrunning::Operation;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::CreateKeyRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ApiKeys>::create_key(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = CreateKeySvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.api.apikeys.v2.ApiKeys/ListKeys" => {
                    #[allow(non_camel_case_types)]
                    struct ListKeysSvc<T: ApiKeys>(pub Arc<T>);
                    impl<T: ApiKeys> tonic::server::UnaryService<super::ListKeysRequest>
                    for ListKeysSvc<T> {
                        type Response = super::ListKeysResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ListKeysRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ApiKeys>::list_keys(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ListKeysSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.api.apikeys.v2.ApiKeys/GetKey" => {
                    #[allow(non_camel_case_types)]
                    struct GetKeySvc<T: ApiKeys>(pub Arc<T>);
                    impl<T: ApiKeys> tonic::server::UnaryService<super::GetKeyRequest>
                    for GetKeySvc<T> {
                        type Response = super::Key;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetKeyRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ApiKeys>::get_key(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetKeySvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.api.apikeys.v2.ApiKeys/GetKeyString" => {
                    #[allow(non_camel_case_types)]
                    struct GetKeyStringSvc<T: ApiKeys>(pub Arc<T>);
                    impl<
                        T: ApiKeys,
                    > tonic::server::UnaryService<super::GetKeyStringRequest>
                    for GetKeyStringSvc<T> {
                        type Response = super::GetKeyStringResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetKeyStringRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ApiKeys>::get_key_string(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetKeyStringSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.api.apikeys.v2.ApiKeys/UpdateKey" => {
                    #[allow(non_camel_case_types)]
                    struct UpdateKeySvc<T: ApiKeys>(pub Arc<T>);
                    impl<T: ApiKeys> tonic::server::UnaryService<super::UpdateKeyRequest>
                    for UpdateKeySvc<T> {
                        type Response = super::super::super::super::longrunning::Operation;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::UpdateKeyRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ApiKeys>::update_key(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = UpdateKeySvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.api.apikeys.v2.ApiKeys/DeleteKey" => {
                    #[allow(non_camel_case_types)]
                    struct DeleteKeySvc<T: ApiKeys>(pub Arc<T>);
                    impl<T: ApiKeys> tonic::server::UnaryService<super::DeleteKeyRequest>
                    for DeleteKeySvc<T> {
                        type Response = super::super::super::super::longrunning::Operation;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DeleteKeyRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ApiKeys>::delete_key(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = DeleteKeySvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.api.apikeys.v2.ApiKeys/UndeleteKey" => {
                    #[allow(non_camel_case_types)]
                    struct UndeleteKeySvc<T: ApiKeys>(pub Arc<T>);
                    impl<
                        T: ApiKeys,
                    > tonic::server::UnaryService<super::UndeleteKeyRequest>
                    for UndeleteKeySvc<T> {
                        type Response = super::super::super::super::longrunning::Operation;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::UndeleteKeyRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ApiKeys>::undelete_key(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = UndeleteKeySvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.api.apikeys.v2.ApiKeys/LookupKey" => {
                    #[allow(non_camel_case_types)]
                    struct LookupKeySvc<T: ApiKeys>(pub Arc<T>);
                    impl<T: ApiKeys> tonic::server::UnaryService<super::LookupKeyRequest>
                    for LookupKeySvc<T> {
                        type Response = super::LookupKeyResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::LookupKeyRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ApiKeys>::lookup_key(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = LookupKeySvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for ApiKeysServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "google.api.apikeys.v2.ApiKeys";
    impl<T> tonic::server::NamedService for ApiKeysServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
