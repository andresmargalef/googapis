// This file is @generated by prost-build.
/// A Deployment is a group of resources and configs managed and provisioned by
/// Infra Manager.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Deployment {
    /// Resource name of the deployment.
    /// Format: `projects/{project}/locations/{location}/deployments/{deployment}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. Time when the deployment was created.
    #[prost(message, optional, tag = "2")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. Time when the deployment was last modified.
    #[prost(message, optional, tag = "3")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// User-defined metadata for the deployment.
    #[prost(map = "string, string", tag = "4")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Output only. Current state of the deployment.
    #[prost(enumeration = "deployment::State", tag = "5")]
    pub state: i32,
    /// Output only. Revision name that was most recently applied.
    /// Format: `projects/{project}/locations/{location}/deployments/{deployment}/
    /// revisions/{revision}`
    #[prost(string, tag = "7")]
    pub latest_revision: ::prost::alloc::string::String,
    /// Output only. Additional information regarding the current state.
    #[prost(string, tag = "9")]
    pub state_detail: ::prost::alloc::string::String,
    /// Output only. Error code describing errors that may have occurred.
    #[prost(enumeration = "deployment::ErrorCode", tag = "10")]
    pub error_code: i32,
    /// Output only. Location of artifacts from a DeleteDeployment operation.
    #[prost(message, optional, tag = "8")]
    pub delete_results: ::core::option::Option<ApplyResults>,
    /// Output only. Cloud Build instance UUID associated with deleting this
    /// deployment.
    #[prost(string, tag = "11")]
    pub delete_build: ::prost::alloc::string::String,
    /// Output only. Location of Cloud Build logs in Google Cloud Storage,
    /// populated when deleting this deployment. Format: `gs://{bucket}/{object}`.
    #[prost(string, tag = "12")]
    pub delete_logs: ::prost::alloc::string::String,
    /// Output only. Errors encountered when deleting this deployment.
    /// Errors are truncated to 10 entries, see `delete_results` and `error_logs`
    /// for full details.
    #[prost(message, repeated, tag = "13")]
    pub tf_errors: ::prost::alloc::vec::Vec<TerraformError>,
    /// Output only. Location of Terraform error logs in Google Cloud Storage.
    /// Format: `gs://{bucket}/{object}`.
    #[prost(string, tag = "14")]
    pub error_logs: ::prost::alloc::string::String,
    /// Optional. User-defined location of Cloud Build logs and artifacts in Google
    /// Cloud Storage. Format: `gs://{bucket}/{folder}`
    ///
    /// A default bucket will be bootstrapped if the field is not set or empty.
    /// Default bucket format: `gs://<project number>-<region>-blueprint-config`
    /// Constraints:
    /// - The bucket needs to be in the same project as the deployment
    /// - The path cannot be within the path of `gcs_source`
    /// - The field cannot be updated, including changing its presence
    #[prost(string, optional, tag = "15")]
    pub artifacts_gcs_bucket: ::core::option::Option<::prost::alloc::string::String>,
    /// Optional. User-specified Service Account (SA) credentials to be used when
    /// actuating resources.
    /// Format: `projects/{projectID}/serviceAccounts/{serviceAccount}`
    #[prost(string, optional, tag = "16")]
    pub service_account: ::core::option::Option<::prost::alloc::string::String>,
    /// By default, Infra Manager will return a failure when
    /// Terraform encounters a 409 code (resource conflict error) during actuation.
    /// If this flag is set to true, Infra Manager will instead
    /// attempt to automatically import the resource into the Terraform state (for
    /// supported resource types) and continue actuation.
    ///
    /// Not all resource types are supported, refer to documentation.
    #[prost(bool, optional, tag = "17")]
    pub import_existing_resources: ::core::option::Option<bool>,
    /// Optional. The user-specified Cloud Build worker pool resource in which the
    /// Cloud Build job will execute. Format:
    /// `projects/{project}/locations/{location}/workerPools/{workerPoolId}`.
    /// If this field is unspecified, the default Cloud Build worker pool will be
    /// used.
    #[prost(string, optional, tag = "19")]
    pub worker_pool: ::core::option::Option<::prost::alloc::string::String>,
    /// Output only. Current lock state of the deployment.
    #[prost(enumeration = "deployment::LockState", tag = "20")]
    pub lock_state: i32,
    /// Optional. The user-specified Terraform version constraint.
    /// Example: "=1.3.10".
    #[prost(string, optional, tag = "21")]
    pub tf_version_constraint: ::core::option::Option<::prost::alloc::string::String>,
    /// Output only. The current Terraform version set on the deployment.
    /// It is in the format of "Major.Minor.Patch", for example, "1.3.10".
    #[prost(string, tag = "22")]
    pub tf_version: ::prost::alloc::string::String,
    /// Optional. Input to control quota checks for resources in terraform
    /// configuration files. There are limited resources on which quota validation
    /// applies.
    #[prost(enumeration = "QuotaValidation", tag = "23")]
    pub quota_validation: i32,
    /// Optional. Arbitrary key-value metadata storage e.g. to help client tools
    /// identify deployments during automation. See
    /// <https://google.aip.dev/148#annotations> for details on format and size
    /// limitations.
    #[prost(map = "string, string", tag = "24")]
    pub annotations: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Blueprint to deploy.
    #[prost(oneof = "deployment::Blueprint", tags = "6")]
    pub blueprint: ::core::option::Option<deployment::Blueprint>,
}
/// Nested message and enum types in `Deployment`.
pub mod deployment {
    /// Possible states of a deployment.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        /// The default value. This value is used if the state is omitted.
        Unspecified = 0,
        /// The deployment is being created.
        Creating = 1,
        /// The deployment is healthy.
        Active = 2,
        /// The deployment is being updated.
        Updating = 3,
        /// The deployment is being deleted.
        Deleting = 4,
        /// The deployment has encountered an unexpected error.
        Failed = 5,
        /// The deployment is no longer being actively reconciled.
        /// This may be the result of recovering the project after deletion.
        Suspended = 6,
        /// The deployment has been deleted.
        Deleted = 7,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                State::Unspecified => "STATE_UNSPECIFIED",
                State::Creating => "CREATING",
                State::Active => "ACTIVE",
                State::Updating => "UPDATING",
                State::Deleting => "DELETING",
                State::Failed => "FAILED",
                State::Suspended => "SUSPENDED",
                State::Deleted => "DELETED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "CREATING" => Some(Self::Creating),
                "ACTIVE" => Some(Self::Active),
                "UPDATING" => Some(Self::Updating),
                "DELETING" => Some(Self::Deleting),
                "FAILED" => Some(Self::Failed),
                "SUSPENDED" => Some(Self::Suspended),
                "DELETED" => Some(Self::Deleted),
                _ => None,
            }
        }
    }
    /// Possible errors that can occur with deployments.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ErrorCode {
        /// No error code was specified.
        Unspecified = 0,
        /// The revision failed. See Revision for more details.
        RevisionFailed = 1,
        /// Cloud Build failed due to a permission issue.
        CloudBuildPermissionDenied = 3,
        /// Cloud Build job associated with a deployment deletion could not be
        /// started.
        DeleteBuildApiFailed = 5,
        /// Cloud Build job associated with a deployment deletion was started but
        /// failed.
        DeleteBuildRunFailed = 6,
        /// Cloud Storage bucket creation failed due to a permission issue.
        BucketCreationPermissionDenied = 7,
        /// Cloud Storage bucket creation failed due to an issue unrelated to
        /// permissions.
        BucketCreationFailed = 8,
    }
    impl ErrorCode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ErrorCode::Unspecified => "ERROR_CODE_UNSPECIFIED",
                ErrorCode::RevisionFailed => "REVISION_FAILED",
                ErrorCode::CloudBuildPermissionDenied => "CLOUD_BUILD_PERMISSION_DENIED",
                ErrorCode::DeleteBuildApiFailed => "DELETE_BUILD_API_FAILED",
                ErrorCode::DeleteBuildRunFailed => "DELETE_BUILD_RUN_FAILED",
                ErrorCode::BucketCreationPermissionDenied => {
                    "BUCKET_CREATION_PERMISSION_DENIED"
                }
                ErrorCode::BucketCreationFailed => "BUCKET_CREATION_FAILED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ERROR_CODE_UNSPECIFIED" => Some(Self::Unspecified),
                "REVISION_FAILED" => Some(Self::RevisionFailed),
                "CLOUD_BUILD_PERMISSION_DENIED" => Some(Self::CloudBuildPermissionDenied),
                "DELETE_BUILD_API_FAILED" => Some(Self::DeleteBuildApiFailed),
                "DELETE_BUILD_RUN_FAILED" => Some(Self::DeleteBuildRunFailed),
                "BUCKET_CREATION_PERMISSION_DENIED" => {
                    Some(Self::BucketCreationPermissionDenied)
                }
                "BUCKET_CREATION_FAILED" => Some(Self::BucketCreationFailed),
                _ => None,
            }
        }
    }
    /// Possible lock states of a deployment.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum LockState {
        /// The default value. This value is used if the lock state is omitted.
        Unspecified = 0,
        /// The deployment is locked.
        Locked = 1,
        /// The deployment is unlocked.
        Unlocked = 2,
        /// The deployment is being locked.
        Locking = 3,
        /// The deployment is being unlocked.
        Unlocking = 4,
        /// The deployment has failed to lock.
        LockFailed = 5,
        /// The deployment has failed to unlock.
        UnlockFailed = 6,
    }
    impl LockState {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                LockState::Unspecified => "LOCK_STATE_UNSPECIFIED",
                LockState::Locked => "LOCKED",
                LockState::Unlocked => "UNLOCKED",
                LockState::Locking => "LOCKING",
                LockState::Unlocking => "UNLOCKING",
                LockState::LockFailed => "LOCK_FAILED",
                LockState::UnlockFailed => "UNLOCK_FAILED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "LOCK_STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "LOCKED" => Some(Self::Locked),
                "UNLOCKED" => Some(Self::Unlocked),
                "LOCKING" => Some(Self::Locking),
                "UNLOCKING" => Some(Self::Unlocking),
                "LOCK_FAILED" => Some(Self::LockFailed),
                "UNLOCK_FAILED" => Some(Self::UnlockFailed),
                _ => None,
            }
        }
    }
    /// Blueprint to deploy.
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Blueprint {
        /// A blueprint described using Terraform's HashiCorp Configuration Language
        /// as a root module.
        #[prost(message, tag = "6")]
        TerraformBlueprint(super::TerraformBlueprint),
    }
}
/// TerraformBlueprint describes the source of a Terraform root module which
/// describes the resources and configs to be deployed.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TerraformBlueprint {
    /// Input variable values for the Terraform blueprint.
    #[prost(map = "string, message", tag = "4")]
    pub input_values: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        TerraformVariable,
    >,
    /// Location of the source configs.
    #[prost(oneof = "terraform_blueprint::Source", tags = "1, 2")]
    pub source: ::core::option::Option<terraform_blueprint::Source>,
}
/// Nested message and enum types in `TerraformBlueprint`.
pub mod terraform_blueprint {
    /// Location of the source configs.
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Source {
        /// Required. URI of an object in Google Cloud Storage.
        /// Format: `gs://{bucket}/{object}`
        ///
        /// URI may also specify an object version for zipped objects.
        /// Format: `gs://{bucket}/{object}#{version}`
        #[prost(string, tag = "1")]
        GcsSource(::prost::alloc::string::String),
        /// Required. URI of a public Git repo.
        #[prost(message, tag = "2")]
        GitSource(super::GitSource),
    }
}
/// A Terraform input variable.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TerraformVariable {
    /// Input variable value.
    #[prost(message, optional, tag = "5")]
    pub input_value: ::core::option::Option<::prost_types::Value>,
}
/// Outputs and artifacts from applying a deployment.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ApplyResults {
    /// Location of a blueprint copy and other manifests in Google Cloud Storage.
    /// Format: `gs://{bucket}/{object}`
    #[prost(string, tag = "1")]
    pub content: ::prost::alloc::string::String,
    /// Location of artifacts (e.g. logs) in Google Cloud Storage.
    /// Format: `gs://{bucket}/{object}`
    #[prost(string, tag = "2")]
    pub artifacts: ::prost::alloc::string::String,
    /// Map of output name to output info.
    #[prost(map = "string, message", tag = "3")]
    pub outputs: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        TerraformOutput,
    >,
}
/// Describes a Terraform output.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TerraformOutput {
    /// Identifies whether Terraform has set this output as a potential
    /// sensitive value.
    #[prost(bool, tag = "1")]
    pub sensitive: bool,
    /// Value of output.
    #[prost(message, optional, tag = "2")]
    pub value: ::core::option::Option<::prost_types::Value>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDeploymentsRequest {
    /// Required. The parent in whose context the Deployments are listed. The
    /// parent value is in the format:
    /// 'projects/{project_id}/locations/{location}'.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// When requesting a page of resources, 'page_size' specifies number of
    /// resources to return. If unspecified, at most 500 will be returned. The
    /// maximum value is 1000.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Token returned by previous call to 'ListDeployments' which specifies the
    /// position in the list from where to continue listing the resources.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Lists the Deployments that match the filter expression. A filter
    /// expression filters the resources listed in the response. The expression
    /// must be of the form '{field} {operator} {value}' where operators: '<', '>',
    /// '<=', '>=', '!=', '=', ':' are supported (colon ':' represents a HAS
    /// operator which is roughly synonymous with equality). {field} can refer to a
    /// proto or JSON field, or a synthetic field. Field names can be camelCase or
    /// snake_case.
    ///
    /// Examples:
    /// - Filter by name:
    ///    name = "projects/foo/locations/us-central1/deployments/bar
    ///
    /// - Filter by labels:
    ///    - Resources that have a key called 'foo'
    ///      labels.foo:*
    ///    - Resources that have a key called 'foo' whose value is 'bar'
    ///      labels.foo = bar
    ///
    /// - Filter by state:
    ///    - Deployments in CREATING state.
    ///      state=CREATING
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    /// Field to use to sort the list.
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDeploymentsResponse {
    /// List of [Deployment][google.cloud.config.v1.Deployment]s.
    #[prost(message, repeated, tag = "1")]
    pub deployments: ::prost::alloc::vec::Vec<Deployment>,
    /// Token to be supplied to the next ListDeployments request via `page_token`
    /// to obtain the next set of results.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    /// Locations that could not be reached.
    #[prost(string, repeated, tag = "3")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetDeploymentRequest {
    /// Required. The name of the deployment. Format:
    /// 'projects/{project_id}/locations/{location}/deployments/{deployment}'.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// A request to list Revisions passed to a 'ListRevisions' call.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListRevisionsRequest {
    /// Required. The parent in whose context the Revisions are listed. The parent
    /// value is in the format:
    /// 'projects/{project_id}/locations/{location}/deployments/{deployment}'.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// When requesting a page of resources, `page_size` specifies number of
    /// resources to return. If unspecified, at most 500 will be returned. The
    /// maximum value is 1000.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Token returned by previous call to 'ListRevisions' which specifies the
    /// position in the list from where to continue listing the resources.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Lists the Revisions that match the filter expression. A filter
    /// expression filters the resources listed in the response. The expression
    /// must be of the form '{field} {operator} {value}' where operators: '<', '>',
    /// '<=', '>=', '!=', '=', ':' are supported (colon ':' represents a HAS
    /// operator which is roughly synonymous with equality). {field} can refer to a
    /// proto or JSON field, or a synthetic field. Field names can be camelCase or
    /// snake_case.
    ///
    /// Examples:
    /// - Filter by name:
    ///    name = "projects/foo/locations/us-central1/deployments/dep/revisions/bar
    ///
    /// - Filter by labels:
    ///    - Resources that have a key called 'foo'
    ///      labels.foo:*
    ///    - Resources that have a key called 'foo' whose value is 'bar'
    ///      labels.foo = bar
    ///
    /// - Filter by state:
    ///    - Revisions in CREATING state.
    ///      state=CREATING
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    /// Field to use to sort the list.
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
/// A response to a 'ListRevisions' call. Contains a list of Revisions.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListRevisionsResponse {
    /// List of [Revision][google.cloud.config.v1.Revision]s.
    #[prost(message, repeated, tag = "1")]
    pub revisions: ::prost::alloc::vec::Vec<Revision>,
    /// A token to request the next page of resources from the 'ListRevisions'
    /// method. The value of an empty string means that there are no more resources
    /// to return.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    /// Locations that could not be reached.
    #[prost(string, repeated, tag = "3")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// A request to get a Revision from a 'GetRevision' call.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetRevisionRequest {
    /// Required. The name of the Revision in the format:
    /// 'projects/{project_id}/locations/{location}/deployments/{deployment}/revisions/{revision}'.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateDeploymentRequest {
    /// Required. The parent in whose context the Deployment is created. The parent
    /// value is in the format: 'projects/{project_id}/locations/{location}'.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The Deployment ID.
    #[prost(string, tag = "2")]
    pub deployment_id: ::prost::alloc::string::String,
    /// Required. [Deployment][google.cloud.config.v1.Deployment] resource to be
    /// created.
    #[prost(message, optional, tag = "3")]
    pub deployment: ::core::option::Option<Deployment>,
    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request ID,
    /// the server can check if original operation with the same request ID was
    /// received, and if so, will ignore the second request. This prevents clients
    /// from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[prost(string, tag = "4")]
    pub request_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateDeploymentRequest {
    /// Optional. Field mask used to specify the fields to be overwritten in the
    /// Deployment resource by the update.
    ///
    /// The fields specified in the update_mask are relative to the resource, not
    /// the full request. A field will be overwritten if it is in the mask. If the
    /// user does not provide a mask then all fields will be overwritten.
    #[prost(message, optional, tag = "1")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// Required. [Deployment][google.cloud.config.v1.Deployment] to update.
    ///
    /// The deployment's `name` field is used to identify the resource to be
    /// updated. Format:
    /// `projects/{project}/locations/{location}/deployments/{deployment}`
    #[prost(message, optional, tag = "2")]
    pub deployment: ::core::option::Option<Deployment>,
    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request ID,
    /// the server can check if original operation with the same request ID was
    /// received, and if so, will ignore the second request. This prevents clients
    /// from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[prost(string, tag = "3")]
    pub request_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteDeploymentRequest {
    /// Required. The name of the Deployment in the format:
    /// 'projects/{project_id}/locations/{location}/deployments/{deployment}'.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request ID,
    /// the server can check if original operation with the same request ID was
    /// received, and if so, will ignore the second request. This prevents clients
    /// from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[prost(string, tag = "2")]
    pub request_id: ::prost::alloc::string::String,
    /// Optional. If set to true, any revisions for this deployment will also be
    /// deleted. (Otherwise, the request will only work if the deployment has no
    /// revisions.)
    #[prost(bool, tag = "3")]
    pub force: bool,
    /// Optional. Policy on how resources actuated by the deployment should be
    /// deleted. If unspecified, the default behavior is to delete the underlying
    /// resources.
    #[prost(enumeration = "delete_deployment_request::DeletePolicy", tag = "4")]
    pub delete_policy: i32,
}
/// Nested message and enum types in `DeleteDeploymentRequest`.
pub mod delete_deployment_request {
    /// Policy on how resources actuated by the deployment should be deleted.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum DeletePolicy {
        /// Unspecified policy, resources will be deleted.
        Unspecified = 0,
        /// Deletes resources actuated by the deployment.
        Delete = 1,
        /// Abandons resources and only deletes the deployment and its metadata.
        Abandon = 2,
    }
    impl DeletePolicy {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                DeletePolicy::Unspecified => "DELETE_POLICY_UNSPECIFIED",
                DeletePolicy::Delete => "DELETE",
                DeletePolicy::Abandon => "ABANDON",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "DELETE_POLICY_UNSPECIFIED" => Some(Self::Unspecified),
                "DELETE" => Some(Self::Delete),
                "ABANDON" => Some(Self::Abandon),
                _ => None,
            }
        }
    }
}
/// Represents the metadata of the long-running operation.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OperationMetadata {
    /// Output only. Time when the operation was created.
    #[prost(message, optional, tag = "1")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. Time when the operation finished running.
    #[prost(message, optional, tag = "2")]
    pub end_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. Server-defined resource path for the target of the operation.
    #[prost(string, tag = "3")]
    pub target: ::prost::alloc::string::String,
    /// Output only. Name of the verb executed by the operation.
    #[prost(string, tag = "4")]
    pub verb: ::prost::alloc::string::String,
    /// Output only. Human-readable status of the operation, if any.
    #[prost(string, tag = "5")]
    pub status_message: ::prost::alloc::string::String,
    /// Output only. Identifies whether the user has requested cancellation of the
    /// operation. Operations that have successfully been cancelled have
    /// [Operation.error][] value with a
    /// [google.rpc.Status.code][google.rpc.Status.code] of 1, corresponding to
    /// `Code.CANCELLED`.
    #[prost(bool, tag = "6")]
    pub requested_cancellation: bool,
    /// Output only. API version used to start the operation.
    #[prost(string, tag = "7")]
    pub api_version: ::prost::alloc::string::String,
    /// Ephemeral metadata about the state of an operation for a particular
    /// resource.
    #[prost(oneof = "operation_metadata::ResourceMetadata", tags = "8, 9")]
    pub resource_metadata: ::core::option::Option<operation_metadata::ResourceMetadata>,
}
/// Nested message and enum types in `OperationMetadata`.
pub mod operation_metadata {
    /// Ephemeral metadata about the state of an operation for a particular
    /// resource.
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum ResourceMetadata {
        /// Output only. Metadata about the deployment operation state.
        #[prost(message, tag = "8")]
        DeploymentMetadata(super::DeploymentOperationMetadata),
        /// Output only. Metadata about the preview operation state.
        #[prost(message, tag = "9")]
        PreviewMetadata(super::PreviewOperationMetadata),
    }
}
/// A child resource of a Deployment generated by a 'CreateDeployment' or
/// 'UpdateDeployment' call. Each Revision contains metadata pertaining to a
/// snapshot of a particular Deployment.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Revision {
    /// Revision name. Format:
    /// `projects/{project}/locations/{location}/deployments/{deployment}/
    /// revisions/{revision}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. Time when the revision was created.
    #[prost(message, optional, tag = "2")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. Time when the revision was last modified.
    #[prost(message, optional, tag = "3")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The action which created this revision
    #[prost(enumeration = "revision::Action", tag = "4")]
    pub action: i32,
    /// Output only. Current state of the revision.
    #[prost(enumeration = "revision::State", tag = "5")]
    pub state: i32,
    /// Output only. Outputs and artifacts from applying a deployment.
    #[prost(message, optional, tag = "7")]
    pub apply_results: ::core::option::Option<ApplyResults>,
    /// Output only. Additional info regarding the current state.
    #[prost(string, tag = "8")]
    pub state_detail: ::prost::alloc::string::String,
    /// Output only. Code describing any errors that may have occurred.
    #[prost(enumeration = "revision::ErrorCode", tag = "9")]
    pub error_code: i32,
    /// Output only. Cloud Build instance UUID associated with this revision.
    #[prost(string, tag = "10")]
    pub build: ::prost::alloc::string::String,
    /// Output only. Location of Revision operation logs in
    /// `gs://{bucket}/{object}` format.
    #[prost(string, tag = "11")]
    pub logs: ::prost::alloc::string::String,
    /// Output only. Errors encountered when creating or updating this deployment.
    /// Errors are truncated to 10 entries, see `delete_results` and `error_logs`
    /// for full details.
    #[prost(message, repeated, tag = "12")]
    pub tf_errors: ::prost::alloc::vec::Vec<TerraformError>,
    /// Output only. Location of Terraform error logs in Google Cloud Storage.
    /// Format: `gs://{bucket}/{object}`.
    #[prost(string, tag = "13")]
    pub error_logs: ::prost::alloc::string::String,
    /// Output only. User-specified Service Account (SA) to be used as credential
    /// to manage resources. Format:
    /// `projects/{projectID}/serviceAccounts/{serviceAccount}`
    #[prost(string, tag = "14")]
    pub service_account: ::prost::alloc::string::String,
    /// Output only. By default, Infra Manager will return a failure when
    /// Terraform encounters a 409 code (resource conflict error) during actuation.
    /// If this flag is set to true, Infra Manager will instead
    /// attempt to automatically import the resource into the Terraform state (for
    /// supported resource types) and continue actuation.
    ///
    /// Not all resource types are supported, refer to documentation.
    #[prost(bool, tag = "15")]
    pub import_existing_resources: bool,
    /// Output only. The user-specified Cloud Build worker pool resource in which
    /// the Cloud Build job will execute. Format:
    /// `projects/{project}/locations/{location}/workerPools/{workerPoolId}`.
    /// If this field is unspecified, the default Cloud Build worker pool will be
    /// used.
    #[prost(string, tag = "17")]
    pub worker_pool: ::prost::alloc::string::String,
    /// Output only. The user-specified Terraform version constraint.
    /// Example: "=1.3.10".
    #[prost(string, tag = "18")]
    pub tf_version_constraint: ::prost::alloc::string::String,
    /// Output only. The version of Terraform used to create the Revision.
    /// It is in the format of "Major.Minor.Patch", for example, "1.3.10".
    #[prost(string, tag = "19")]
    pub tf_version: ::prost::alloc::string::String,
    /// Output only. Cloud Storage path containing quota validation results. This
    /// field is set when a user sets Deployment.quota_validation field to ENABLED
    /// or ENFORCED. Format: `gs://{bucket}/{object}`.
    #[prost(string, tag = "29")]
    pub quota_validation_results: ::prost::alloc::string::String,
    /// Optional. Input to control quota checks for resources in terraform
    /// configuration files. There are limited resources on which quota validation
    /// applies.
    #[prost(enumeration = "QuotaValidation", tag = "20")]
    pub quota_validation: i32,
    /// Blueprint that was deployed.
    #[prost(oneof = "revision::Blueprint", tags = "6")]
    pub blueprint: ::core::option::Option<revision::Blueprint>,
}
/// Nested message and enum types in `Revision`.
pub mod revision {
    /// Actions that generate a revision.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Action {
        /// The default value. This value is used if the action is omitted.
        Unspecified = 0,
        /// The revision was generated by creating a deployment.
        Create = 1,
        /// The revision was generated by updating a deployment.
        Update = 2,
        /// The revision was deleted.
        Delete = 3,
    }
    impl Action {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Action::Unspecified => "ACTION_UNSPECIFIED",
                Action::Create => "CREATE",
                Action::Update => "UPDATE",
                Action::Delete => "DELETE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ACTION_UNSPECIFIED" => Some(Self::Unspecified),
                "CREATE" => Some(Self::Create),
                "UPDATE" => Some(Self::Update),
                "DELETE" => Some(Self::Delete),
                _ => None,
            }
        }
    }
    /// Possible states of a revision.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        /// The default value. This value is used if the state is omitted.
        Unspecified = 0,
        /// The revision is being applied.
        Applying = 1,
        /// The revision was applied successfully.
        Applied = 2,
        /// The revision could not be applied successfully.
        Failed = 3,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                State::Unspecified => "STATE_UNSPECIFIED",
                State::Applying => "APPLYING",
                State::Applied => "APPLIED",
                State::Failed => "FAILED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "APPLYING" => Some(Self::Applying),
                "APPLIED" => Some(Self::Applied),
                "FAILED" => Some(Self::Failed),
                _ => None,
            }
        }
    }
    /// Possible errors if Revision could not be created or updated successfully.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ErrorCode {
        /// No error code was specified.
        Unspecified = 0,
        /// Cloud Build failed due to a permission issue.
        CloudBuildPermissionDenied = 1,
        /// Cloud Build job associated with creating or updating a deployment could
        /// not be started.
        ApplyBuildApiFailed = 4,
        /// Cloud Build job associated with creating or updating a deployment was
        /// started but failed.
        ApplyBuildRunFailed = 5,
        /// quota validation failed for one or more resources in terraform
        /// configuration files.
        QuotaValidationFailed = 7,
    }
    impl ErrorCode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ErrorCode::Unspecified => "ERROR_CODE_UNSPECIFIED",
                ErrorCode::CloudBuildPermissionDenied => "CLOUD_BUILD_PERMISSION_DENIED",
                ErrorCode::ApplyBuildApiFailed => "APPLY_BUILD_API_FAILED",
                ErrorCode::ApplyBuildRunFailed => "APPLY_BUILD_RUN_FAILED",
                ErrorCode::QuotaValidationFailed => "QUOTA_VALIDATION_FAILED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ERROR_CODE_UNSPECIFIED" => Some(Self::Unspecified),
                "CLOUD_BUILD_PERMISSION_DENIED" => Some(Self::CloudBuildPermissionDenied),
                "APPLY_BUILD_API_FAILED" => Some(Self::ApplyBuildApiFailed),
                "APPLY_BUILD_RUN_FAILED" => Some(Self::ApplyBuildRunFailed),
                "QUOTA_VALIDATION_FAILED" => Some(Self::QuotaValidationFailed),
                _ => None,
            }
        }
    }
    /// Blueprint that was deployed.
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Blueprint {
        /// Output only. A blueprint described using Terraform's HashiCorp
        /// Configuration Language as a root module.
        #[prost(message, tag = "6")]
        TerraformBlueprint(super::TerraformBlueprint),
    }
}
/// Errors encountered during actuation using Terraform
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TerraformError {
    /// Address of the resource associated with the error,
    /// e.g. `google_compute_network.vpc_network`.
    #[prost(string, tag = "1")]
    pub resource_address: ::prost::alloc::string::String,
    /// HTTP response code returned from Google Cloud Platform APIs when Terraform
    /// fails to provision the resource. If unset or 0, no HTTP response code was
    /// returned by Terraform.
    #[prost(int32, tag = "2")]
    pub http_response_code: i32,
    /// A human-readable error description.
    #[prost(string, tag = "3")]
    pub error_description: ::prost::alloc::string::String,
    /// Original error response from underlying Google API, if available.
    #[prost(message, optional, tag = "4")]
    pub error: ::core::option::Option<super::super::super::rpc::Status>,
}
/// A set of files in a Git repository.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GitSource {
    /// Optional. Repository URL.
    /// Example: '<https://github.com/kubernetes/examples.git'>
    #[prost(string, optional, tag = "1")]
    pub repo: ::core::option::Option<::prost::alloc::string::String>,
    /// Optional. Subdirectory inside the repository.
    /// Example: 'staging/my-package'
    #[prost(string, optional, tag = "2")]
    pub directory: ::core::option::Option<::prost::alloc::string::String>,
    /// Optional. Git reference (e.g. branch or tag).
    #[prost(string, optional, tag = "3")]
    pub r#ref: ::core::option::Option<::prost::alloc::string::String>,
}
/// Ephemeral metadata content describing the state of a deployment operation.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeploymentOperationMetadata {
    /// The current step the deployment operation is running.
    #[prost(enumeration = "deployment_operation_metadata::DeploymentStep", tag = "1")]
    pub step: i32,
    /// Outputs and artifacts from applying a deployment.
    #[prost(message, optional, tag = "2")]
    pub apply_results: ::core::option::Option<ApplyResults>,
    /// Output only. Cloud Build instance UUID associated with this operation.
    #[prost(string, tag = "3")]
    pub build: ::prost::alloc::string::String,
    /// Output only. Location of Deployment operations logs in
    /// `gs://{bucket}/{object}` format.
    #[prost(string, tag = "4")]
    pub logs: ::prost::alloc::string::String,
}
/// Nested message and enum types in `DeploymentOperationMetadata`.
pub mod deployment_operation_metadata {
    /// The possible steps a deployment may be running.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum DeploymentStep {
        /// Unspecified deployment step
        Unspecified = 0,
        /// Infra Manager is creating a Google Cloud Storage bucket to store
        /// artifacts and metadata about the deployment and revision
        PreparingStorageBucket = 1,
        /// Downloading the blueprint onto the Google Cloud Storage bucket
        DownloadingBlueprint = 2,
        /// Initializing Terraform using `terraform init`
        RunningTfInit = 3,
        /// Running `terraform plan`
        RunningTfPlan = 4,
        /// Actuating resources using Terraform using `terraform apply`
        RunningTfApply = 5,
        /// Destroying resources using Terraform using `terraform destroy`
        RunningTfDestroy = 6,
        /// Validating the uploaded TF state file when unlocking a deployment
        RunningTfValidate = 7,
        /// Unlocking a deployment
        UnlockingDeployment = 8,
        /// Operation was successful
        Succeeded = 9,
        /// Operation failed
        Failed = 10,
        /// Validating the provided repository.
        ValidatingRepository = 11,
        /// Running quota validation
        RunningQuotaValidation = 12,
    }
    impl DeploymentStep {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                DeploymentStep::Unspecified => "DEPLOYMENT_STEP_UNSPECIFIED",
                DeploymentStep::PreparingStorageBucket => "PREPARING_STORAGE_BUCKET",
                DeploymentStep::DownloadingBlueprint => "DOWNLOADING_BLUEPRINT",
                DeploymentStep::RunningTfInit => "RUNNING_TF_INIT",
                DeploymentStep::RunningTfPlan => "RUNNING_TF_PLAN",
                DeploymentStep::RunningTfApply => "RUNNING_TF_APPLY",
                DeploymentStep::RunningTfDestroy => "RUNNING_TF_DESTROY",
                DeploymentStep::RunningTfValidate => "RUNNING_TF_VALIDATE",
                DeploymentStep::UnlockingDeployment => "UNLOCKING_DEPLOYMENT",
                DeploymentStep::Succeeded => "SUCCEEDED",
                DeploymentStep::Failed => "FAILED",
                DeploymentStep::ValidatingRepository => "VALIDATING_REPOSITORY",
                DeploymentStep::RunningQuotaValidation => "RUNNING_QUOTA_VALIDATION",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "DEPLOYMENT_STEP_UNSPECIFIED" => Some(Self::Unspecified),
                "PREPARING_STORAGE_BUCKET" => Some(Self::PreparingStorageBucket),
                "DOWNLOADING_BLUEPRINT" => Some(Self::DownloadingBlueprint),
                "RUNNING_TF_INIT" => Some(Self::RunningTfInit),
                "RUNNING_TF_PLAN" => Some(Self::RunningTfPlan),
                "RUNNING_TF_APPLY" => Some(Self::RunningTfApply),
                "RUNNING_TF_DESTROY" => Some(Self::RunningTfDestroy),
                "RUNNING_TF_VALIDATE" => Some(Self::RunningTfValidate),
                "UNLOCKING_DEPLOYMENT" => Some(Self::UnlockingDeployment),
                "SUCCEEDED" => Some(Self::Succeeded),
                "FAILED" => Some(Self::Failed),
                "VALIDATING_REPOSITORY" => Some(Self::ValidatingRepository),
                "RUNNING_QUOTA_VALIDATION" => Some(Self::RunningQuotaValidation),
                _ => None,
            }
        }
    }
}
/// Resource represents a Google Cloud Platform resource actuated by IM.
/// Resources are child resources of Revisions.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Resource {
    /// Output only. Resource name.
    /// Format:
    /// `projects/{project}/locations/{location}/deployments/{deployment}/revisions/{revision}/resources/{resource}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. Terraform-specific info if this resource was created using
    /// Terraform.
    #[prost(message, optional, tag = "2")]
    pub terraform_info: ::core::option::Option<ResourceTerraformInfo>,
    /// Output only. Map of Cloud Asset Inventory (CAI) type to CAI info (e.g. CAI
    /// ID). CAI type format follows
    /// <https://cloud.google.com/asset-inventory/docs/supported-asset-types>
    #[prost(map = "string, message", tag = "3")]
    pub cai_assets: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ResourceCaiInfo,
    >,
    /// Output only. Intent of the resource.
    #[prost(enumeration = "resource::Intent", tag = "4")]
    pub intent: i32,
    /// Output only. Current state of the resource.
    #[prost(enumeration = "resource::State", tag = "5")]
    pub state: i32,
}
/// Nested message and enum types in `Resource`.
pub mod resource {
    /// Possible intent of the resource.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Intent {
        /// The default value. This value is used if the intent is omitted.
        Unspecified = 0,
        /// Infra Manager will create this Resource.
        Create = 1,
        /// Infra Manager will update this Resource.
        Update = 2,
        /// Infra Manager will delete this Resource.
        Delete = 3,
        /// Infra Manager will destroy and recreate this Resource.
        Recreate = 4,
        /// Infra Manager will leave this Resource untouched.
        Unchanged = 5,
    }
    impl Intent {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Intent::Unspecified => "INTENT_UNSPECIFIED",
                Intent::Create => "CREATE",
                Intent::Update => "UPDATE",
                Intent::Delete => "DELETE",
                Intent::Recreate => "RECREATE",
                Intent::Unchanged => "UNCHANGED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "INTENT_UNSPECIFIED" => Some(Self::Unspecified),
                "CREATE" => Some(Self::Create),
                "UPDATE" => Some(Self::Update),
                "DELETE" => Some(Self::Delete),
                "RECREATE" => Some(Self::Recreate),
                "UNCHANGED" => Some(Self::Unchanged),
                _ => None,
            }
        }
    }
    /// Possible states of a resource.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        /// The default value. This value is used if the state is omitted.
        Unspecified = 0,
        /// Resource has been planned for reconcile.
        Planned = 1,
        /// Resource is actively reconciling into the intended state.
        InProgress = 2,
        /// Resource has reconciled to intended state.
        Reconciled = 3,
        /// Resource failed to reconcile.
        Failed = 4,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                State::Unspecified => "STATE_UNSPECIFIED",
                State::Planned => "PLANNED",
                State::InProgress => "IN_PROGRESS",
                State::Reconciled => "RECONCILED",
                State::Failed => "FAILED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "PLANNED" => Some(Self::Planned),
                "IN_PROGRESS" => Some(Self::InProgress),
                "RECONCILED" => Some(Self::Reconciled),
                "FAILED" => Some(Self::Failed),
                _ => None,
            }
        }
    }
}
/// Terraform info of a Resource.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResourceTerraformInfo {
    /// TF resource address that uniquely identifies this resource within this
    /// deployment.
    #[prost(string, tag = "1")]
    pub address: ::prost::alloc::string::String,
    /// TF resource type
    #[prost(string, tag = "2")]
    pub r#type: ::prost::alloc::string::String,
    /// ID attribute of the TF resource
    #[prost(string, tag = "3")]
    pub id: ::prost::alloc::string::String,
}
/// CAI info of a Resource.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResourceCaiInfo {
    /// CAI resource name in the format following
    /// <https://cloud.google.com/apis/design/resource_names#full_resource_name>
    #[prost(string, tag = "1")]
    pub full_resource_name: ::prost::alloc::string::String,
}
/// A request to get a Resource from a 'GetResource' call.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetResourceRequest {
    /// Required. The name of the Resource in the format:
    /// 'projects/{project_id}/locations/{location}/deployments/{deployment}/revisions/{revision}/resource/{resource}'.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// A request to list Resources passed to a 'ListResources' call.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListResourcesRequest {
    /// Required. The parent in whose context the Resources are listed. The parent
    /// value is in the format:
    /// 'projects/{project_id}/locations/{location}/deployments/{deployment}/revisions/{revision}'.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// When requesting a page of resources, 'page_size' specifies number of
    /// resources to return. If unspecified, at most 500 will be returned. The
    /// maximum value is 1000.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Token returned by previous call to 'ListResources' which specifies the
    /// position in the list from where to continue listing the resources.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Lists the Resources that match the filter expression. A filter
    /// expression filters the resources listed in the response. The expression
    /// must be of the form '{field} {operator} {value}' where operators: '<', '>',
    /// '<=',
    /// '>=',
    /// '!=', '=', ':' are supported (colon ':' represents a HAS operator which is
    /// roughly synonymous with equality). {field} can refer to a proto or JSON
    /// field, or a synthetic field. Field names can be camelCase or snake_case.
    ///
    /// Examples:
    /// - Filter by name:
    ///    name =
    ///    "projects/foo/locations/us-central1/deployments/dep/revisions/bar/resources/baz
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    /// Field to use to sort the list.
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
/// A response to a 'ListResources' call. Contains a list of Resources.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListResourcesResponse {
    /// List of [Resources][]s.
    #[prost(message, repeated, tag = "1")]
    pub resources: ::prost::alloc::vec::Vec<Resource>,
    /// A token to request the next page of resources from the 'ListResources'
    /// method. The value of an empty string means that there are no more resources
    /// to return.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    /// Locations that could not be reached.
    #[prost(string, repeated, tag = "3")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Contains info about a Terraform state file
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Statefile {
    /// Output only. Cloud Storage signed URI used for downloading or uploading the
    /// state file.
    #[prost(string, tag = "1")]
    pub signed_uri: ::prost::alloc::string::String,
}
/// A request to export a state file passed to a 'ExportDeploymentStatefile'
/// call.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExportDeploymentStatefileRequest {
    /// Required. The parent in whose context the statefile is listed. The parent
    /// value is in the format:
    /// 'projects/{project_id}/locations/{location}/deployments/{deployment}'.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. If this flag is set to true, the exported deployment state file
    /// will be the draft state. This will enable the draft file to be validated
    /// before copying it over to the working state on unlock.
    #[prost(bool, tag = "3")]
    pub draft: bool,
}
/// A request to export a state file passed to a 'ExportRevisionStatefile'
/// call.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExportRevisionStatefileRequest {
    /// Required. The parent in whose context the statefile is listed. The parent
    /// value is in the format:
    /// 'projects/{project_id}/locations/{location}/deployments/{deployment}/revisions/{revision}'.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
}
/// A request to import a state file passed to a 'ImportStatefile' call.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImportStatefileRequest {
    /// Required. The parent in whose context the statefile is listed. The parent
    /// value is in the format:
    /// 'projects/{project_id}/locations/{location}/deployments/{deployment}'.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. Lock ID of the lock file to verify that the user who is importing
    /// the state file previously locked the Deployment.
    #[prost(int64, tag = "2")]
    pub lock_id: i64,
    /// Optional.
    #[prost(bool, tag = "3")]
    pub skip_draft: bool,
}
/// A request to delete a state file passed to a 'DeleteStatefile' call.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteStatefileRequest {
    /// Required. The name of the deployment in the format:
    /// 'projects/{project_id}/locations/{location}/deployments/{deployment}'.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Required. Lock ID of the lock file to verify that the user who is deleting
    /// the state file previously locked the Deployment.
    #[prost(int64, tag = "2")]
    pub lock_id: i64,
}
/// A request to lock a deployment passed to a 'LockDeployment' call.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LockDeploymentRequest {
    /// Required. The name of the deployment in the format:
    /// 'projects/{project_id}/locations/{location}/deployments/{deployment}'.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// A request to unlock a state file passed to a 'UnlockDeployment' call.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UnlockDeploymentRequest {
    /// Required. The name of the deployment in the format:
    /// 'projects/{project_id}/locations/{location}/deployments/{deployment}'.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Required. Lock ID of the lock file to be unlocked.
    #[prost(int64, tag = "2")]
    pub lock_id: i64,
}
/// A request to get a state file lock info passed to a 'ExportLockInfo' call.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExportLockInfoRequest {
    /// Required. The name of the deployment in the format:
    /// 'projects/{project_id}/locations/{location}/deployments/{deployment}'.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Details about the lock which locked the deployment.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LockInfo {
    /// Unique ID for the lock to be overridden with generation ID in the backend.
    #[prost(int64, tag = "1")]
    pub lock_id: i64,
    /// Terraform operation, provided by the caller.
    #[prost(string, tag = "2")]
    pub operation: ::prost::alloc::string::String,
    /// Extra information to store with the lock, provided by the caller.
    #[prost(string, tag = "3")]
    pub info: ::prost::alloc::string::String,
    /// user@hostname when available
    #[prost(string, tag = "4")]
    pub who: ::prost::alloc::string::String,
    /// Terraform version
    #[prost(string, tag = "5")]
    pub version: ::prost::alloc::string::String,
    /// Time that the lock was taken.
    #[prost(message, optional, tag = "6")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
}
/// A preview represents a set of actions Infra Manager would perform
/// to move the resources towards the desired state as specified in the
/// configuration.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Preview {
    /// Identifier. Resource name of the preview. Resource name can be user
    /// provided or server generated ID if unspecified. Format:
    /// `projects/{project}/locations/{location}/previews/{preview}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. Time the preview was created.
    #[prost(message, optional, tag = "2")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Optional. User-defined labels for the preview.
    #[prost(map = "string, string", tag = "3")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Output only. Current state of the preview.
    #[prost(enumeration = "preview::State", tag = "4")]
    pub state: i32,
    /// Optional. Optional deployment reference. If specified, the preview will be
    /// performed using the provided deployment's current state and use any
    /// relevant fields from the deployment unless explicitly specified in the
    /// preview create request.
    #[prost(string, tag = "5")]
    pub deployment: ::prost::alloc::string::String,
    /// Optional. Current mode of preview.
    #[prost(enumeration = "preview::PreviewMode", tag = "15")]
    pub preview_mode: i32,
    /// Optional. User-specified Service Account (SA) credentials to be used when
    /// previewing resources.
    /// Format: `projects/{projectID}/serviceAccounts/{serviceAccount}`
    #[prost(string, tag = "7")]
    pub service_account: ::prost::alloc::string::String,
    /// Optional. User-defined location of Cloud Build logs, artifacts, and
    /// in Google Cloud Storage.
    /// Format: `gs://{bucket}/{folder}`
    /// A default bucket will be bootstrapped if the field is not set or empty
    /// Default Bucket Format: `gs://<project number>-<region>-blueprint-config`
    /// Constraints:
    /// - The bucket needs to be in the same project as the deployment
    /// - The path cannot be within the path of `gcs_source`
    /// If omitted and deployment resource ref provided has artifacts_gcs_bucket
    /// defined, that artifact bucket is used.
    #[prost(string, optional, tag = "8")]
    pub artifacts_gcs_bucket: ::core::option::Option<::prost::alloc::string::String>,
    /// Optional. The user-specified Worker Pool resource in which the Cloud Build
    /// job will execute. Format
    /// projects/{project}/locations/{location}/workerPools/{workerPoolId} If this
    /// field is unspecified, the default Cloud Build worker pool will be used. If
    /// omitted and deployment resource ref provided has worker_pool defined, that
    /// worker pool is used.
    #[prost(string, optional, tag = "9")]
    pub worker_pool: ::core::option::Option<::prost::alloc::string::String>,
    /// Output only. Code describing any errors that may have occurred.
    #[prost(enumeration = "preview::ErrorCode", tag = "10")]
    pub error_code: i32,
    /// Output only. Additional information regarding the current state.
    #[prost(message, optional, tag = "11")]
    pub error_status: ::core::option::Option<super::super::super::rpc::Status>,
    /// Output only. Cloud Build instance UUID associated with this preview.
    #[prost(string, tag = "12")]
    pub build: ::prost::alloc::string::String,
    /// Output only. Summary of errors encountered during Terraform preview.
    /// It has a size limit of 10, i.e. only top 10 errors will be summarized here.
    #[prost(message, repeated, tag = "13")]
    pub tf_errors: ::prost::alloc::vec::Vec<TerraformError>,
    /// Output only. Link to tf-error.ndjson file, which contains the full list of
    /// the errors encountered during a Terraform preview.
    /// Format: `gs://{bucket}/{object}`.
    #[prost(string, tag = "14")]
    pub error_logs: ::prost::alloc::string::String,
    /// Output only. Artifacts from preview.
    #[prost(message, optional, tag = "16")]
    pub preview_artifacts: ::core::option::Option<PreviewArtifacts>,
    /// Output only. Location of preview logs in `gs://{bucket}/{object}` format.
    #[prost(string, tag = "17")]
    pub logs: ::prost::alloc::string::String,
    /// Output only. The current Terraform version set on the preview.
    /// It is in the format of "Major.Minor.Patch", for example, "1.3.10".
    #[prost(string, tag = "18")]
    pub tf_version: ::prost::alloc::string::String,
    /// Optional. The user-specified Terraform version constraint.
    /// Example: "=1.3.10".
    #[prost(string, optional, tag = "19")]
    pub tf_version_constraint: ::core::option::Option<::prost::alloc::string::String>,
    /// Blueprint to preview.
    #[prost(oneof = "preview::Blueprint", tags = "6")]
    pub blueprint: ::core::option::Option<preview::Blueprint>,
}
/// Nested message and enum types in `Preview`.
pub mod preview {
    /// Possible states of a preview.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        /// The default value. This value is used if the state is unknown.
        Unspecified = 0,
        /// The preview is being created.
        Creating = 1,
        /// The preview has succeeded.
        Succeeded = 2,
        /// The preview is being applied.
        Applying = 3,
        /// The preview is stale. A preview can become stale if a revision has been
        /// applied after this preview was created.
        Stale = 4,
        /// The preview is being deleted.
        Deleting = 5,
        /// The preview has encountered an unexpected error.
        Failed = 6,
        /// The preview has been deleted.
        Deleted = 7,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                State::Unspecified => "STATE_UNSPECIFIED",
                State::Creating => "CREATING",
                State::Succeeded => "SUCCEEDED",
                State::Applying => "APPLYING",
                State::Stale => "STALE",
                State::Deleting => "DELETING",
                State::Failed => "FAILED",
                State::Deleted => "DELETED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "CREATING" => Some(Self::Creating),
                "SUCCEEDED" => Some(Self::Succeeded),
                "APPLYING" => Some(Self::Applying),
                "STALE" => Some(Self::Stale),
                "DELETING" => Some(Self::Deleting),
                "FAILED" => Some(Self::Failed),
                "DELETED" => Some(Self::Deleted),
                _ => None,
            }
        }
    }
    /// Preview mode provides options for customizing preview operations.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum PreviewMode {
        /// Unspecified policy, default mode will be used.
        Unspecified = 0,
        /// DEFAULT mode generates an execution plan for reconciling current resource
        /// state into expected resource state.
        Default = 1,
        /// DELETE mode generates as execution plan for destroying current resources.
        Delete = 2,
    }
    impl PreviewMode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                PreviewMode::Unspecified => "PREVIEW_MODE_UNSPECIFIED",
                PreviewMode::Default => "DEFAULT",
                PreviewMode::Delete => "DELETE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "PREVIEW_MODE_UNSPECIFIED" => Some(Self::Unspecified),
                "DEFAULT" => Some(Self::Default),
                "DELETE" => Some(Self::Delete),
                _ => None,
            }
        }
    }
    /// Possible errors that can occur with previews.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ErrorCode {
        /// No error code was specified.
        Unspecified = 0,
        /// Cloud Build failed due to a permissions issue.
        CloudBuildPermissionDenied = 1,
        /// Cloud Storage bucket failed to create due to a permissions issue.
        BucketCreationPermissionDenied = 2,
        /// Cloud Storage bucket failed for a non-permissions-related issue.
        BucketCreationFailed = 3,
        /// Acquiring lock on provided deployment reference failed.
        DeploymentLockAcquireFailed = 4,
        /// Preview encountered an error when trying to access Cloud Build API.
        PreviewBuildApiFailed = 5,
        /// Preview created a build but build failed and logs were generated.
        PreviewBuildRunFailed = 6,
    }
    impl ErrorCode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ErrorCode::Unspecified => "ERROR_CODE_UNSPECIFIED",
                ErrorCode::CloudBuildPermissionDenied => "CLOUD_BUILD_PERMISSION_DENIED",
                ErrorCode::BucketCreationPermissionDenied => {
                    "BUCKET_CREATION_PERMISSION_DENIED"
                }
                ErrorCode::BucketCreationFailed => "BUCKET_CREATION_FAILED",
                ErrorCode::DeploymentLockAcquireFailed => {
                    "DEPLOYMENT_LOCK_ACQUIRE_FAILED"
                }
                ErrorCode::PreviewBuildApiFailed => "PREVIEW_BUILD_API_FAILED",
                ErrorCode::PreviewBuildRunFailed => "PREVIEW_BUILD_RUN_FAILED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ERROR_CODE_UNSPECIFIED" => Some(Self::Unspecified),
                "CLOUD_BUILD_PERMISSION_DENIED" => Some(Self::CloudBuildPermissionDenied),
                "BUCKET_CREATION_PERMISSION_DENIED" => {
                    Some(Self::BucketCreationPermissionDenied)
                }
                "BUCKET_CREATION_FAILED" => Some(Self::BucketCreationFailed),
                "DEPLOYMENT_LOCK_ACQUIRE_FAILED" => {
                    Some(Self::DeploymentLockAcquireFailed)
                }
                "PREVIEW_BUILD_API_FAILED" => Some(Self::PreviewBuildApiFailed),
                "PREVIEW_BUILD_RUN_FAILED" => Some(Self::PreviewBuildRunFailed),
                _ => None,
            }
        }
    }
    /// Blueprint to preview.
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Blueprint {
        /// The terraform blueprint to preview.
        #[prost(message, tag = "6")]
        TerraformBlueprint(super::TerraformBlueprint),
    }
}
/// Ephemeral metadata content describing the state of a preview operation.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PreviewOperationMetadata {
    /// The current step the preview operation is running.
    #[prost(enumeration = "preview_operation_metadata::PreviewStep", tag = "1")]
    pub step: i32,
    /// Artifacts from preview.
    #[prost(message, optional, tag = "2")]
    pub preview_artifacts: ::core::option::Option<PreviewArtifacts>,
    /// Output only. Location of preview logs in `gs://{bucket}/{object}` format.
    #[prost(string, tag = "3")]
    pub logs: ::prost::alloc::string::String,
    /// Output only. Cloud Build instance UUID associated with this preview.
    #[prost(string, tag = "4")]
    pub build: ::prost::alloc::string::String,
}
/// Nested message and enum types in `PreviewOperationMetadata`.
pub mod preview_operation_metadata {
    /// The possible steps a preview may be running.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum PreviewStep {
        /// Unspecified preview step.
        Unspecified = 0,
        /// Infra Manager is creating a Google Cloud Storage bucket to store
        /// artifacts and metadata about the preview.
        PreparingStorageBucket = 1,
        /// Downloading the blueprint onto the Google Cloud Storage bucket.
        DownloadingBlueprint = 2,
        /// Initializing Terraform using `terraform init`.
        RunningTfInit = 3,
        /// Running `terraform plan`.
        RunningTfPlan = 4,
        /// Fetching a deployment.
        FetchingDeployment = 5,
        /// Locking a deployment.
        LockingDeployment = 6,
        /// Unlocking a deployment.
        UnlockingDeployment = 7,
        /// Operation was successful.
        Succeeded = 8,
        /// Operation failed.
        Failed = 9,
        /// Validating the provided repository.
        ValidatingRepository = 10,
    }
    impl PreviewStep {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                PreviewStep::Unspecified => "PREVIEW_STEP_UNSPECIFIED",
                PreviewStep::PreparingStorageBucket => "PREPARING_STORAGE_BUCKET",
                PreviewStep::DownloadingBlueprint => "DOWNLOADING_BLUEPRINT",
                PreviewStep::RunningTfInit => "RUNNING_TF_INIT",
                PreviewStep::RunningTfPlan => "RUNNING_TF_PLAN",
                PreviewStep::FetchingDeployment => "FETCHING_DEPLOYMENT",
                PreviewStep::LockingDeployment => "LOCKING_DEPLOYMENT",
                PreviewStep::UnlockingDeployment => "UNLOCKING_DEPLOYMENT",
                PreviewStep::Succeeded => "SUCCEEDED",
                PreviewStep::Failed => "FAILED",
                PreviewStep::ValidatingRepository => "VALIDATING_REPOSITORY",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "PREVIEW_STEP_UNSPECIFIED" => Some(Self::Unspecified),
                "PREPARING_STORAGE_BUCKET" => Some(Self::PreparingStorageBucket),
                "DOWNLOADING_BLUEPRINT" => Some(Self::DownloadingBlueprint),
                "RUNNING_TF_INIT" => Some(Self::RunningTfInit),
                "RUNNING_TF_PLAN" => Some(Self::RunningTfPlan),
                "FETCHING_DEPLOYMENT" => Some(Self::FetchingDeployment),
                "LOCKING_DEPLOYMENT" => Some(Self::LockingDeployment),
                "UNLOCKING_DEPLOYMENT" => Some(Self::UnlockingDeployment),
                "SUCCEEDED" => Some(Self::Succeeded),
                "FAILED" => Some(Self::Failed),
                "VALIDATING_REPOSITORY" => Some(Self::ValidatingRepository),
                _ => None,
            }
        }
    }
}
/// Artifacts created by preview.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PreviewArtifacts {
    /// Output only. Location of a blueprint copy and other content in Google Cloud
    /// Storage. Format: `gs://{bucket}/{object}`
    #[prost(string, tag = "1")]
    pub content: ::prost::alloc::string::String,
    /// Output only. Location of artifacts in Google Cloud Storage.
    /// Format: `gs://{bucket}/{object}`
    #[prost(string, tag = "2")]
    pub artifacts: ::prost::alloc::string::String,
}
/// A request to create a preview.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreatePreviewRequest {
    /// Required. The parent in whose context the Preview is created. The parent
    /// value is in the format: 'projects/{project_id}/locations/{location}'.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. The preview ID.
    #[prost(string, tag = "2")]
    pub preview_id: ::prost::alloc::string::String,
    /// Required. [Preview][google.cloud.config.v1.Preview] resource to be created.
    #[prost(message, optional, tag = "3")]
    pub preview: ::core::option::Option<Preview>,
    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request ID,
    /// the server can check if original operation with the same request ID was
    /// received, and if so, will ignore the second request. This prevents clients
    /// from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[prost(string, tag = "4")]
    pub request_id: ::prost::alloc::string::String,
}
/// A request to get details about a preview.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetPreviewRequest {
    /// Required. The name of the preview. Format:
    /// 'projects/{project_id}/locations/{location}/previews/{preview}'.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// A request to list all previews for a given project and location.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListPreviewsRequest {
    /// Required. The parent in whose context the Previews are listed. The parent
    /// value is in the format: 'projects/{project_id}/locations/{location}'.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. When requesting a page of resources, 'page_size' specifies number
    /// of resources to return. If unspecified, at most 500 will be returned. The
    /// maximum value is 1000.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. Token returned by previous call to 'ListDeployments' which
    /// specifies the position in the list from where to continue listing the
    /// resources.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. Lists the Deployments that match the filter expression. A filter
    /// expression filters the resources listed in the response. The expression
    /// must be of the form '{field} {operator} {value}' where operators: '<', '>',
    /// '<=', '>=', '!=', '=', ':' are supported (colon ':' represents a HAS
    /// operator which is roughly synonymous with equality). {field} can refer to a
    /// proto or JSON field, or a synthetic field. Field names can be camelCase or
    /// snake_case.
    ///
    /// Examples:
    /// - Filter by name:
    ///    name = "projects/foo/locations/us-central1/deployments/bar
    ///
    /// - Filter by labels:
    ///    - Resources that have a key called 'foo'
    ///      labels.foo:*
    ///    - Resources that have a key called 'foo' whose value is 'bar'
    ///      labels.foo = bar
    ///
    /// - Filter by state:
    ///    - Deployments in CREATING state.
    ///      state=CREATING
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    /// Optional. Field to use to sort the list.
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
/// A response to a `ListPreviews` call. Contains a list of Previews.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListPreviewsResponse {
    /// List of [Previews][]s.
    #[prost(message, repeated, tag = "1")]
    pub previews: ::prost::alloc::vec::Vec<Preview>,
    /// Token to be supplied to the next ListPreviews request via `page_token`
    /// to obtain the next set of results.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    /// Locations that could not be reached.
    #[prost(string, repeated, tag = "3")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// A request to delete a preview.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeletePreviewRequest {
    /// Required. The name of the Preview in the format:
    /// 'projects/{project_id}/locations/{location}/previews/{preview}'.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request ID,
    /// the server can check if original operation with the same request ID was
    /// received, and if so, will ignore the second request. This prevents clients
    /// from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[prost(string, tag = "2")]
    pub request_id: ::prost::alloc::string::String,
}
/// A request to export preview results.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExportPreviewResultRequest {
    /// Required. The preview whose results should be exported. The preview value
    /// is in the format:
    /// 'projects/{project_id}/locations/{location}/previews/{preview}'.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
}
/// A response to `ExportPreviewResult` call. Contains preview results.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExportPreviewResultResponse {
    /// Output only. Signed URLs for accessing the plan files.
    #[prost(message, optional, tag = "1")]
    pub result: ::core::option::Option<PreviewResult>,
}
/// Contains a signed Cloud Storage URLs.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PreviewResult {
    /// Output only. Plan binary signed URL
    #[prost(string, tag = "1")]
    pub binary_signed_uri: ::prost::alloc::string::String,
    /// Output only. Plan JSON signed URL
    #[prost(string, tag = "2")]
    pub json_signed_uri: ::prost::alloc::string::String,
}
/// The request message for the GetTerraformVersion method.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetTerraformVersionRequest {
    /// Required. The name of the TerraformVersion. Format:
    /// 'projects/{project_id}/locations/{location}/terraformVersions/{terraform_version}'
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// The request message for the ListTerraformVersions method.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListTerraformVersionsRequest {
    /// Required. The parent in whose context the TerraformVersions are listed. The
    /// parent value is in the format:
    /// 'projects/{project_id}/locations/{location}'.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. When requesting a page of resources, 'page_size' specifies number
    /// of resources to return. If unspecified, at most 500 will be returned. The
    /// maximum value is 1000.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. Token returned by previous call to 'ListTerraformVersions' which
    /// specifies the position in the list from where to continue listing the
    /// resources.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. Lists the TerraformVersions that match the filter expression. A
    /// filter expression filters the resources listed in the response. The
    /// expression must be of the form '{field} {operator} {value}' where
    /// operators: '<', '>',
    /// '<=', '>=', '!=', '=', ':' are supported (colon ':' represents a HAS
    /// operator which is roughly synonymous with equality). {field} can refer to a
    /// proto or JSON field, or a synthetic field. Field names can be camelCase or
    /// snake_case.
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    /// Optional. Field to use to sort the list.
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
/// The response message for the `ListTerraformVersions` method.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListTerraformVersionsResponse {
    /// List of [TerraformVersion][google.cloud.config.v1.TerraformVersion]s.
    #[prost(message, repeated, tag = "1")]
    pub terraform_versions: ::prost::alloc::vec::Vec<TerraformVersion>,
    /// Token to be supplied to the next ListTerraformVersions request via
    /// `page_token` to obtain the next set of results.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    /// Unreachable resources, if any.
    #[prost(string, repeated, tag = "3")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// A TerraformVersion represents the support state the corresponding
/// Terraform version.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TerraformVersion {
    /// Identifier. The version name is in the format:
    /// 'projects/{project_id}/locations/{location}/terraformVersions/{terraform_version}'.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. The state of the version, ACTIVE, DEPRECATED or OBSOLETE.
    #[prost(enumeration = "terraform_version::State", tag = "2")]
    pub state: i32,
    /// Output only. When the version is supported.
    #[prost(message, optional, tag = "3")]
    pub support_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. When the version is deprecated.
    #[prost(message, optional, tag = "4")]
    pub deprecate_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. When the version is obsolete.
    #[prost(message, optional, tag = "5")]
    pub obsolete_time: ::core::option::Option<::prost_types::Timestamp>,
}
/// Nested message and enum types in `TerraformVersion`.
pub mod terraform_version {
    /// Possible states of a TerraformVersion.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        /// The default value. This value is used if the state is omitted.
        Unspecified = 0,
        /// The version is actively supported.
        Active = 1,
        /// The version is deprecated.
        Deprecated = 2,
        /// The version is obsolete.
        Obsolete = 3,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                State::Unspecified => "STATE_UNSPECIFIED",
                State::Active => "ACTIVE",
                State::Deprecated => "DEPRECATED",
                State::Obsolete => "OBSOLETE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "ACTIVE" => Some(Self::Active),
                "DEPRECATED" => Some(Self::Deprecated),
                "OBSOLETE" => Some(Self::Obsolete),
                _ => None,
            }
        }
    }
}
/// Enum values to control quota checks for resources in terraform
/// configuration files.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum QuotaValidation {
    /// The default value.
    /// QuotaValidation on terraform configuration files will be disabled in
    /// this case.
    Unspecified = 0,
    /// Enable computing quotas for resources in terraform configuration files to
    /// get visibility on resources with insufficient quotas.
    Enabled = 1,
    /// Enforce quota checks so deployment fails if there isn't sufficient quotas
    /// available to deploy resources in terraform configuration files.
    Enforced = 2,
}
impl QuotaValidation {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            QuotaValidation::Unspecified => "QUOTA_VALIDATION_UNSPECIFIED",
            QuotaValidation::Enabled => "ENABLED",
            QuotaValidation::Enforced => "ENFORCED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "QUOTA_VALIDATION_UNSPECIFIED" => Some(Self::Unspecified),
            "ENABLED" => Some(Self::Enabled),
            "ENFORCED" => Some(Self::Enforced),
            _ => None,
        }
    }
}
/// Generated server implementations.
pub mod config_server {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with ConfigServer.
    #[async_trait]
    pub trait Config: Send + Sync + 'static {
        /// Lists [Deployment][google.cloud.config.v1.Deployment]s in a given project
        /// and location.
        async fn list_deployments(
            &self,
            request: tonic::Request<super::ListDeploymentsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListDeploymentsResponse>,
            tonic::Status,
        >;
        /// Gets details about a [Deployment][google.cloud.config.v1.Deployment].
        async fn get_deployment(
            &self,
            request: tonic::Request<super::GetDeploymentRequest>,
        ) -> std::result::Result<tonic::Response<super::Deployment>, tonic::Status>;
        /// Creates a [Deployment][google.cloud.config.v1.Deployment].
        async fn create_deployment(
            &self,
            request: tonic::Request<super::CreateDeploymentRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        >;
        /// Updates a [Deployment][google.cloud.config.v1.Deployment].
        async fn update_deployment(
            &self,
            request: tonic::Request<super::UpdateDeploymentRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        >;
        /// Deletes a [Deployment][google.cloud.config.v1.Deployment].
        async fn delete_deployment(
            &self,
            request: tonic::Request<super::DeleteDeploymentRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        >;
        /// Lists [Revision][google.cloud.config.v1.Revision]s of a deployment.
        async fn list_revisions(
            &self,
            request: tonic::Request<super::ListRevisionsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListRevisionsResponse>,
            tonic::Status,
        >;
        /// Gets details about a [Revision][google.cloud.config.v1.Revision].
        async fn get_revision(
            &self,
            request: tonic::Request<super::GetRevisionRequest>,
        ) -> std::result::Result<tonic::Response<super::Revision>, tonic::Status>;
        /// Gets details about a [Resource][google.cloud.config.v1.Resource] deployed
        /// by Infra Manager.
        async fn get_resource(
            &self,
            request: tonic::Request<super::GetResourceRequest>,
        ) -> std::result::Result<tonic::Response<super::Resource>, tonic::Status>;
        /// Lists [Resource][google.cloud.config.v1.Resource]s in a given revision.
        async fn list_resources(
            &self,
            request: tonic::Request<super::ListResourcesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListResourcesResponse>,
            tonic::Status,
        >;
        /// Exports Terraform state file from a given deployment.
        async fn export_deployment_statefile(
            &self,
            request: tonic::Request<super::ExportDeploymentStatefileRequest>,
        ) -> std::result::Result<tonic::Response<super::Statefile>, tonic::Status>;
        /// Exports Terraform state file from a given revision.
        async fn export_revision_statefile(
            &self,
            request: tonic::Request<super::ExportRevisionStatefileRequest>,
        ) -> std::result::Result<tonic::Response<super::Statefile>, tonic::Status>;
        /// Imports Terraform state file in a given deployment. The state file does not
        /// take effect until the Deployment has been unlocked.
        async fn import_statefile(
            &self,
            request: tonic::Request<super::ImportStatefileRequest>,
        ) -> std::result::Result<tonic::Response<super::Statefile>, tonic::Status>;
        /// Deletes Terraform state file in a given deployment.
        async fn delete_statefile(
            &self,
            request: tonic::Request<super::DeleteStatefileRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status>;
        /// Locks a deployment.
        async fn lock_deployment(
            &self,
            request: tonic::Request<super::LockDeploymentRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        >;
        /// Unlocks a locked deployment.
        async fn unlock_deployment(
            &self,
            request: tonic::Request<super::UnlockDeploymentRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        >;
        /// Exports the lock info on a locked deployment.
        async fn export_lock_info(
            &self,
            request: tonic::Request<super::ExportLockInfoRequest>,
        ) -> std::result::Result<tonic::Response<super::LockInfo>, tonic::Status>;
        /// Creates a [Preview][google.cloud.config.v1.Preview].
        async fn create_preview(
            &self,
            request: tonic::Request<super::CreatePreviewRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        >;
        /// Gets details about a [Preview][google.cloud.config.v1.Preview].
        async fn get_preview(
            &self,
            request: tonic::Request<super::GetPreviewRequest>,
        ) -> std::result::Result<tonic::Response<super::Preview>, tonic::Status>;
        /// Lists [Preview][google.cloud.config.v1.Preview]s in a given project and
        /// location.
        async fn list_previews(
            &self,
            request: tonic::Request<super::ListPreviewsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListPreviewsResponse>,
            tonic::Status,
        >;
        /// Deletes a [Preview][google.cloud.config.v1.Preview].
        async fn delete_preview(
            &self,
            request: tonic::Request<super::DeletePreviewRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        >;
        /// Export [Preview][google.cloud.config.v1.Preview] results.
        async fn export_preview_result(
            &self,
            request: tonic::Request<super::ExportPreviewResultRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ExportPreviewResultResponse>,
            tonic::Status,
        >;
        /// Lists [TerraformVersion][google.cloud.config.v1.TerraformVersion]s in a
        /// given project and location.
        async fn list_terraform_versions(
            &self,
            request: tonic::Request<super::ListTerraformVersionsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListTerraformVersionsResponse>,
            tonic::Status,
        >;
        /// Gets details about a
        /// [TerraformVersion][google.cloud.config.v1.TerraformVersion].
        async fn get_terraform_version(
            &self,
            request: tonic::Request<super::GetTerraformVersionRequest>,
        ) -> std::result::Result<
            tonic::Response<super::TerraformVersion>,
            tonic::Status,
        >;
    }
    /// Infrastructure Manager is a managed service that automates the deployment and
    /// management of Google Cloud infrastructure resources.
    #[derive(Debug)]
    pub struct ConfigServer<T: Config> {
        inner: _Inner<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    struct _Inner<T>(Arc<T>);
    impl<T: Config> ConfigServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            let inner = _Inner(inner);
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for ConfigServer<T>
    where
        T: Config,
        B: Body + Send + 'static,
        B::Error: Into<StdError> + Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            let inner = self.inner.clone();
            match req.uri().path() {
                "/google.cloud.config.v1.Config/ListDeployments" => {
                    #[allow(non_camel_case_types)]
                    struct ListDeploymentsSvc<T: Config>(pub Arc<T>);
                    impl<
                        T: Config,
                    > tonic::server::UnaryService<super::ListDeploymentsRequest>
                    for ListDeploymentsSvc<T> {
                        type Response = super::ListDeploymentsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ListDeploymentsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Config>::list_deployments(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = ListDeploymentsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.config.v1.Config/GetDeployment" => {
                    #[allow(non_camel_case_types)]
                    struct GetDeploymentSvc<T: Config>(pub Arc<T>);
                    impl<
                        T: Config,
                    > tonic::server::UnaryService<super::GetDeploymentRequest>
                    for GetDeploymentSvc<T> {
                        type Response = super::Deployment;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetDeploymentRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Config>::get_deployment(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = GetDeploymentSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.config.v1.Config/CreateDeployment" => {
                    #[allow(non_camel_case_types)]
                    struct CreateDeploymentSvc<T: Config>(pub Arc<T>);
                    impl<
                        T: Config,
                    > tonic::server::UnaryService<super::CreateDeploymentRequest>
                    for CreateDeploymentSvc<T> {
                        type Response = super::super::super::super::longrunning::Operation;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::CreateDeploymentRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Config>::create_deployment(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = CreateDeploymentSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.config.v1.Config/UpdateDeployment" => {
                    #[allow(non_camel_case_types)]
                    struct UpdateDeploymentSvc<T: Config>(pub Arc<T>);
                    impl<
                        T: Config,
                    > tonic::server::UnaryService<super::UpdateDeploymentRequest>
                    for UpdateDeploymentSvc<T> {
                        type Response = super::super::super::super::longrunning::Operation;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::UpdateDeploymentRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Config>::update_deployment(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = UpdateDeploymentSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.config.v1.Config/DeleteDeployment" => {
                    #[allow(non_camel_case_types)]
                    struct DeleteDeploymentSvc<T: Config>(pub Arc<T>);
                    impl<
                        T: Config,
                    > tonic::server::UnaryService<super::DeleteDeploymentRequest>
                    for DeleteDeploymentSvc<T> {
                        type Response = super::super::super::super::longrunning::Operation;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DeleteDeploymentRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Config>::delete_deployment(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = DeleteDeploymentSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.config.v1.Config/ListRevisions" => {
                    #[allow(non_camel_case_types)]
                    struct ListRevisionsSvc<T: Config>(pub Arc<T>);
                    impl<
                        T: Config,
                    > tonic::server::UnaryService<super::ListRevisionsRequest>
                    for ListRevisionsSvc<T> {
                        type Response = super::ListRevisionsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ListRevisionsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Config>::list_revisions(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = ListRevisionsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.config.v1.Config/GetRevision" => {
                    #[allow(non_camel_case_types)]
                    struct GetRevisionSvc<T: Config>(pub Arc<T>);
                    impl<
                        T: Config,
                    > tonic::server::UnaryService<super::GetRevisionRequest>
                    for GetRevisionSvc<T> {
                        type Response = super::Revision;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetRevisionRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Config>::get_revision(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = GetRevisionSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.config.v1.Config/GetResource" => {
                    #[allow(non_camel_case_types)]
                    struct GetResourceSvc<T: Config>(pub Arc<T>);
                    impl<
                        T: Config,
                    > tonic::server::UnaryService<super::GetResourceRequest>
                    for GetResourceSvc<T> {
                        type Response = super::Resource;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetResourceRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Config>::get_resource(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = GetResourceSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.config.v1.Config/ListResources" => {
                    #[allow(non_camel_case_types)]
                    struct ListResourcesSvc<T: Config>(pub Arc<T>);
                    impl<
                        T: Config,
                    > tonic::server::UnaryService<super::ListResourcesRequest>
                    for ListResourcesSvc<T> {
                        type Response = super::ListResourcesResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ListResourcesRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Config>::list_resources(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = ListResourcesSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.config.v1.Config/ExportDeploymentStatefile" => {
                    #[allow(non_camel_case_types)]
                    struct ExportDeploymentStatefileSvc<T: Config>(pub Arc<T>);
                    impl<
                        T: Config,
                    > tonic::server::UnaryService<
                        super::ExportDeploymentStatefileRequest,
                    > for ExportDeploymentStatefileSvc<T> {
                        type Response = super::Statefile;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::ExportDeploymentStatefileRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Config>::export_deployment_statefile(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = ExportDeploymentStatefileSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.config.v1.Config/ExportRevisionStatefile" => {
                    #[allow(non_camel_case_types)]
                    struct ExportRevisionStatefileSvc<T: Config>(pub Arc<T>);
                    impl<
                        T: Config,
                    > tonic::server::UnaryService<super::ExportRevisionStatefileRequest>
                    for ExportRevisionStatefileSvc<T> {
                        type Response = super::Statefile;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::ExportRevisionStatefileRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Config>::export_revision_statefile(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = ExportRevisionStatefileSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.config.v1.Config/ImportStatefile" => {
                    #[allow(non_camel_case_types)]
                    struct ImportStatefileSvc<T: Config>(pub Arc<T>);
                    impl<
                        T: Config,
                    > tonic::server::UnaryService<super::ImportStatefileRequest>
                    for ImportStatefileSvc<T> {
                        type Response = super::Statefile;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ImportStatefileRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Config>::import_statefile(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = ImportStatefileSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.config.v1.Config/DeleteStatefile" => {
                    #[allow(non_camel_case_types)]
                    struct DeleteStatefileSvc<T: Config>(pub Arc<T>);
                    impl<
                        T: Config,
                    > tonic::server::UnaryService<super::DeleteStatefileRequest>
                    for DeleteStatefileSvc<T> {
                        type Response = ();
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DeleteStatefileRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Config>::delete_statefile(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = DeleteStatefileSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.config.v1.Config/LockDeployment" => {
                    #[allow(non_camel_case_types)]
                    struct LockDeploymentSvc<T: Config>(pub Arc<T>);
                    impl<
                        T: Config,
                    > tonic::server::UnaryService<super::LockDeploymentRequest>
                    for LockDeploymentSvc<T> {
                        type Response = super::super::super::super::longrunning::Operation;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::LockDeploymentRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Config>::lock_deployment(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = LockDeploymentSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.config.v1.Config/UnlockDeployment" => {
                    #[allow(non_camel_case_types)]
                    struct UnlockDeploymentSvc<T: Config>(pub Arc<T>);
                    impl<
                        T: Config,
                    > tonic::server::UnaryService<super::UnlockDeploymentRequest>
                    for UnlockDeploymentSvc<T> {
                        type Response = super::super::super::super::longrunning::Operation;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::UnlockDeploymentRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Config>::unlock_deployment(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = UnlockDeploymentSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.config.v1.Config/ExportLockInfo" => {
                    #[allow(non_camel_case_types)]
                    struct ExportLockInfoSvc<T: Config>(pub Arc<T>);
                    impl<
                        T: Config,
                    > tonic::server::UnaryService<super::ExportLockInfoRequest>
                    for ExportLockInfoSvc<T> {
                        type Response = super::LockInfo;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ExportLockInfoRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Config>::export_lock_info(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = ExportLockInfoSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.config.v1.Config/CreatePreview" => {
                    #[allow(non_camel_case_types)]
                    struct CreatePreviewSvc<T: Config>(pub Arc<T>);
                    impl<
                        T: Config,
                    > tonic::server::UnaryService<super::CreatePreviewRequest>
                    for CreatePreviewSvc<T> {
                        type Response = super::super::super::super::longrunning::Operation;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::CreatePreviewRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Config>::create_preview(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = CreatePreviewSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.config.v1.Config/GetPreview" => {
                    #[allow(non_camel_case_types)]
                    struct GetPreviewSvc<T: Config>(pub Arc<T>);
                    impl<T: Config> tonic::server::UnaryService<super::GetPreviewRequest>
                    for GetPreviewSvc<T> {
                        type Response = super::Preview;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetPreviewRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Config>::get_preview(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = GetPreviewSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.config.v1.Config/ListPreviews" => {
                    #[allow(non_camel_case_types)]
                    struct ListPreviewsSvc<T: Config>(pub Arc<T>);
                    impl<
                        T: Config,
                    > tonic::server::UnaryService<super::ListPreviewsRequest>
                    for ListPreviewsSvc<T> {
                        type Response = super::ListPreviewsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ListPreviewsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Config>::list_previews(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = ListPreviewsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.config.v1.Config/DeletePreview" => {
                    #[allow(non_camel_case_types)]
                    struct DeletePreviewSvc<T: Config>(pub Arc<T>);
                    impl<
                        T: Config,
                    > tonic::server::UnaryService<super::DeletePreviewRequest>
                    for DeletePreviewSvc<T> {
                        type Response = super::super::super::super::longrunning::Operation;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DeletePreviewRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Config>::delete_preview(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = DeletePreviewSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.config.v1.Config/ExportPreviewResult" => {
                    #[allow(non_camel_case_types)]
                    struct ExportPreviewResultSvc<T: Config>(pub Arc<T>);
                    impl<
                        T: Config,
                    > tonic::server::UnaryService<super::ExportPreviewResultRequest>
                    for ExportPreviewResultSvc<T> {
                        type Response = super::ExportPreviewResultResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ExportPreviewResultRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Config>::export_preview_result(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = ExportPreviewResultSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.config.v1.Config/ListTerraformVersions" => {
                    #[allow(non_camel_case_types)]
                    struct ListTerraformVersionsSvc<T: Config>(pub Arc<T>);
                    impl<
                        T: Config,
                    > tonic::server::UnaryService<super::ListTerraformVersionsRequest>
                    for ListTerraformVersionsSvc<T> {
                        type Response = super::ListTerraformVersionsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ListTerraformVersionsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Config>::list_terraform_versions(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = ListTerraformVersionsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.config.v1.Config/GetTerraformVersion" => {
                    #[allow(non_camel_case_types)]
                    struct GetTerraformVersionSvc<T: Config>(pub Arc<T>);
                    impl<
                        T: Config,
                    > tonic::server::UnaryService<super::GetTerraformVersionRequest>
                    for GetTerraformVersionSvc<T> {
                        type Response = super::TerraformVersion;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetTerraformVersionRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Config>::get_terraform_version(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = GetTerraformVersionSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        Ok(
                            http::Response::builder()
                                .status(200)
                                .header("grpc-status", "12")
                                .header("content-type", "application/grpc")
                                .body(empty_body())
                                .unwrap(),
                        )
                    })
                }
            }
        }
    }
    impl<T: Config> Clone for ConfigServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    impl<T: Config> Clone for _Inner<T> {
        fn clone(&self) -> Self {
            Self(Arc::clone(&self.0))
        }
    }
    impl<T: std::fmt::Debug> std::fmt::Debug for _Inner<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{:?}", self.0)
        }
    }
    impl<T: Config> tonic::server::NamedService for ConfigServer<T> {
        const NAME: &'static str = "google.cloud.config.v1.Config";
    }
}
