// This file is @generated by prost-build.
/// Request message for
/// [AccountBudgetProposalService.MutateAccountBudgetProposal][google.ads.googleads.v16.services.AccountBudgetProposalService.MutateAccountBudgetProposal].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAccountBudgetProposalRequest {
    /// Required. The ID of the customer.
    #[prost(string, tag = "1")]
    pub customer_id: ::prost::alloc::string::String,
    /// Required. The operation to perform on an individual account-level budget
    /// proposal.
    #[prost(message, optional, tag = "2")]
    pub operation: ::core::option::Option<AccountBudgetProposalOperation>,
    /// If true, the request is validated but not executed. Only errors are
    /// returned, not results.
    #[prost(bool, tag = "3")]
    pub validate_only: bool,
}
/// A single operation to propose the creation of a new account-level budget or
/// edit/end/remove an existing one.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AccountBudgetProposalOperation {
    /// FieldMask that determines which budget fields are modified.  While budgets
    /// may be modified, proposals that propose such modifications are final.
    /// Therefore, update operations are not supported for proposals.
    ///
    /// Proposals that modify budgets have the 'update' proposal type.  Specifying
    /// a mask for any other proposal type is considered an error.
    #[prost(message, optional, tag = "3")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// The mutate operation.
    #[prost(oneof = "account_budget_proposal_operation::Operation", tags = "2, 1")]
    pub operation: ::core::option::Option<account_budget_proposal_operation::Operation>,
}
/// Nested message and enum types in `AccountBudgetProposalOperation`.
pub mod account_budget_proposal_operation {
    /// The mutate operation.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Operation {
        /// Create operation: A new proposal to create a new budget, edit an
        /// existing budget, end an actively running budget, or remove an approved
        /// budget scheduled to start in the future.
        /// No resource name is expected for the new proposal.
        #[prost(message, tag = "2")]
        Create(super::super::resources::AccountBudgetProposal),
        /// Remove operation: A resource name for the removed proposal is expected,
        /// in this format:
        ///
        /// `customers/{customer_id}/accountBudgetProposals/{account_budget_proposal_id}`
        /// A request may be cancelled iff it is pending.
        #[prost(string, tag = "1")]
        Remove(::prost::alloc::string::String),
    }
}
/// Response message for account-level budget mutate operations.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAccountBudgetProposalResponse {
    /// The result of the mutate.
    #[prost(message, optional, tag = "2")]
    pub result: ::core::option::Option<MutateAccountBudgetProposalResult>,
}
/// The result for the account budget proposal mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAccountBudgetProposalResult {
    /// Returned for successful operations.
    #[prost(string, tag = "1")]
    pub resource_name: ::prost::alloc::string::String,
}
/// Generated server implementations.
pub mod account_budget_proposal_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with AccountBudgetProposalServiceServer.
    #[async_trait]
    pub trait AccountBudgetProposalService: std::marker::Send + std::marker::Sync + 'static {
        /// Creates, updates, or removes account budget proposals.  Operation statuses
        /// are returned.
        ///
        /// List of thrown errors:
        ///   [AccountBudgetProposalError]()
        ///   [AuthenticationError]()
        ///   [AuthorizationError]()
        ///   [DatabaseError]()
        ///   [DateError]()
        ///   [FieldError]()
        ///   [FieldMaskError]()
        ///   [HeaderError]()
        ///   [InternalError]()
        ///   [MutateError]()
        ///   [QuotaError]()
        ///   [RequestError]()
        ///   [StringLengthError]()
        async fn mutate_account_budget_proposal(
            &self,
            request: tonic::Request<super::MutateAccountBudgetProposalRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MutateAccountBudgetProposalResponse>,
            tonic::Status,
        >;
    }
    /// A service for managing account-level budgets through proposals.
    ///
    /// A proposal is a request to create a new budget or make changes to an
    /// existing one.
    ///
    /// Mutates:
    /// The CREATE operation creates a new proposal.
    /// UPDATE operations aren't supported.
    /// The REMOVE operation cancels a pending proposal.
    #[derive(Debug)]
    pub struct AccountBudgetProposalServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> AccountBudgetProposalServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>>
    for AccountBudgetProposalServiceServer<T>
    where
        T: AccountBudgetProposalService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/google.ads.googleads.v16.services.AccountBudgetProposalService/MutateAccountBudgetProposal" => {
                    #[allow(non_camel_case_types)]
                    struct MutateAccountBudgetProposalSvc<
                        T: AccountBudgetProposalService,
                    >(
                        pub Arc<T>,
                    );
                    impl<
                        T: AccountBudgetProposalService,
                    > tonic::server::UnaryService<
                        super::MutateAccountBudgetProposalRequest,
                    > for MutateAccountBudgetProposalSvc<T> {
                        type Response = super::MutateAccountBudgetProposalResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::MutateAccountBudgetProposalRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as AccountBudgetProposalService>::mutate_account_budget_proposal(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = MutateAccountBudgetProposalSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for AccountBudgetProposalServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "google.ads.googleads.v16.services.AccountBudgetProposalService";
    impl<T> tonic::server::NamedService for AccountBudgetProposalServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Request message for
/// [AccountLinkService.CreateAccountLink][google.ads.googleads.v16.services.AccountLinkService.CreateAccountLink].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateAccountLinkRequest {
    /// Required. The ID of the customer for which the account link is created.
    #[prost(string, tag = "1")]
    pub customer_id: ::prost::alloc::string::String,
    /// Required. The account link to be created.
    #[prost(message, optional, tag = "2")]
    pub account_link: ::core::option::Option<super::resources::AccountLink>,
}
/// Response message for
/// [AccountLinkService.CreateAccountLink][google.ads.googleads.v16.services.AccountLinkService.CreateAccountLink].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateAccountLinkResponse {
    /// Returned for successful operations. Resource name of the account link.
    #[prost(string, tag = "1")]
    pub resource_name: ::prost::alloc::string::String,
}
/// Request message for
/// [AccountLinkService.MutateAccountLink][google.ads.googleads.v16.services.AccountLinkService.MutateAccountLink].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAccountLinkRequest {
    /// Required. The ID of the customer being modified.
    #[prost(string, tag = "1")]
    pub customer_id: ::prost::alloc::string::String,
    /// Required. The operation to perform on the link.
    #[prost(message, optional, tag = "2")]
    pub operation: ::core::option::Option<AccountLinkOperation>,
    /// If true, successful operations will be carried out and invalid
    /// operations will return errors. If false, all operations will be carried
    /// out in one transaction if and only if they are all valid.
    /// Default is false.
    #[prost(bool, tag = "3")]
    pub partial_failure: bool,
    /// If true, the request is validated but not executed. Only errors are
    /// returned, not results.
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
}
/// A single update on an account link.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AccountLinkOperation {
    /// FieldMask that determines which resource fields are modified in an update.
    #[prost(message, optional, tag = "4")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// The operation to perform.
    #[prost(oneof = "account_link_operation::Operation", tags = "2, 3")]
    pub operation: ::core::option::Option<account_link_operation::Operation>,
}
/// Nested message and enum types in `AccountLinkOperation`.
pub mod account_link_operation {
    /// The operation to perform.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Operation {
        /// Update operation: The account link is expected to have
        /// a valid resource name.
        #[prost(message, tag = "2")]
        Update(super::super::resources::AccountLink),
        /// Remove operation: A resource name for the account link to remove is
        /// expected, in this format:
        ///
        /// `customers/{customer_id}/accountLinks/{account_link_id}`
        #[prost(string, tag = "3")]
        Remove(::prost::alloc::string::String),
    }
}
/// Response message for account link mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAccountLinkResponse {
    /// Result for the mutate.
    #[prost(message, optional, tag = "1")]
    pub result: ::core::option::Option<MutateAccountLinkResult>,
    /// Errors that pertain to operation failures in the partial failure mode.
    /// Returned only when partial_failure = true and all errors occur inside the
    /// operations. If any errors occur outside the operations (for example, auth
    /// errors), we return an RPC level error.
    #[prost(message, optional, tag = "2")]
    pub partial_failure_error: ::core::option::Option<
        super::super::super::super::rpc::Status,
    >,
}
/// The result for the account link mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAccountLinkResult {
    /// Returned for successful operations.
    #[prost(string, tag = "1")]
    pub resource_name: ::prost::alloc::string::String,
}
/// Generated server implementations.
pub mod account_link_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with AccountLinkServiceServer.
    #[async_trait]
    pub trait AccountLinkService: std::marker::Send + std::marker::Sync + 'static {
        /// Creates an account link.
        ///
        /// List of thrown errors:
        ///   [AuthenticationError]()
        ///   [AuthorizationError]()
        ///   [DatabaseError]()
        ///   [FieldError]()
        ///   [HeaderError]()
        ///   [InternalError]()
        ///   [MutateError]()
        ///   [QuotaError]()
        ///   [RequestError]()
        ///   [ThirdPartyAppAnalyticsLinkError]()
        async fn create_account_link(
            &self,
            request: tonic::Request<super::CreateAccountLinkRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CreateAccountLinkResponse>,
            tonic::Status,
        >;
        /// Creates or removes an account link.
        /// From V5, create is not supported through
        /// AccountLinkService.MutateAccountLink. Use
        /// AccountLinkService.CreateAccountLink instead.
        ///
        /// List of thrown errors:
        ///   [AccountLinkError]()
        ///   [AuthenticationError]()
        ///   [AuthorizationError]()
        ///   [FieldMaskError]()
        ///   [HeaderError]()
        ///   [InternalError]()
        ///   [MutateError]()
        ///   [QuotaError]()
        ///   [RequestError]()
        async fn mutate_account_link(
            &self,
            request: tonic::Request<super::MutateAccountLinkRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MutateAccountLinkResponse>,
            tonic::Status,
        >;
    }
    /// This service allows management of links between Google Ads accounts and other
    /// accounts.
    #[derive(Debug)]
    pub struct AccountLinkServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> AccountLinkServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for AccountLinkServiceServer<T>
    where
        T: AccountLinkService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/google.ads.googleads.v16.services.AccountLinkService/CreateAccountLink" => {
                    #[allow(non_camel_case_types)]
                    struct CreateAccountLinkSvc<T: AccountLinkService>(pub Arc<T>);
                    impl<
                        T: AccountLinkService,
                    > tonic::server::UnaryService<super::CreateAccountLinkRequest>
                    for CreateAccountLinkSvc<T> {
                        type Response = super::CreateAccountLinkResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::CreateAccountLinkRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as AccountLinkService>::create_account_link(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = CreateAccountLinkSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.ads.googleads.v16.services.AccountLinkService/MutateAccountLink" => {
                    #[allow(non_camel_case_types)]
                    struct MutateAccountLinkSvc<T: AccountLinkService>(pub Arc<T>);
                    impl<
                        T: AccountLinkService,
                    > tonic::server::UnaryService<super::MutateAccountLinkRequest>
                    for MutateAccountLinkSvc<T> {
                        type Response = super::MutateAccountLinkResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::MutateAccountLinkRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as AccountLinkService>::mutate_account_link(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = MutateAccountLinkSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for AccountLinkServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "google.ads.googleads.v16.services.AccountLinkService";
    impl<T> tonic::server::NamedService for AccountLinkServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Request message for
/// [AdGroupAdLabelService.MutateAdGroupAdLabels][google.ads.googleads.v16.services.AdGroupAdLabelService.MutateAdGroupAdLabels].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAdGroupAdLabelsRequest {
    /// Required. ID of the customer whose ad group ad labels are being modified.
    #[prost(string, tag = "1")]
    pub customer_id: ::prost::alloc::string::String,
    /// Required. The list of operations to perform on ad group ad labels.
    #[prost(message, repeated, tag = "2")]
    pub operations: ::prost::alloc::vec::Vec<AdGroupAdLabelOperation>,
    /// If true, successful operations will be carried out and invalid
    /// operations will return errors. If false, all operations will be carried
    /// out in one transaction if and only if they are all valid.
    /// Default is false.
    #[prost(bool, tag = "3")]
    pub partial_failure: bool,
    /// If true, the request is validated but not executed. Only errors are
    /// returned, not results.
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
}
/// A single operation (create, remove) on an ad group ad label.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AdGroupAdLabelOperation {
    /// The mutate operation.
    #[prost(oneof = "ad_group_ad_label_operation::Operation", tags = "1, 2")]
    pub operation: ::core::option::Option<ad_group_ad_label_operation::Operation>,
}
/// Nested message and enum types in `AdGroupAdLabelOperation`.
pub mod ad_group_ad_label_operation {
    /// The mutate operation.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Operation {
        /// Create operation: No resource name is expected for the new ad group ad
        /// label.
        #[prost(message, tag = "1")]
        Create(super::super::resources::AdGroupAdLabel),
        /// Remove operation: A resource name for the ad group ad label
        /// being removed, in this format:
        ///
        /// `customers/{customer_id}/adGroupAdLabels/{ad_group_id}~{ad_id}~{label_id}`
        #[prost(string, tag = "2")]
        Remove(::prost::alloc::string::String),
    }
}
/// Response message for an ad group ad labels mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAdGroupAdLabelsResponse {
    /// Errors that pertain to operation failures in the partial failure mode.
    /// Returned only when partial_failure = true and all errors occur inside the
    /// operations. If any errors occur outside the operations (for example, auth
    /// errors), we return an RPC level error.
    #[prost(message, optional, tag = "3")]
    pub partial_failure_error: ::core::option::Option<
        super::super::super::super::rpc::Status,
    >,
    /// All results for the mutate.
    #[prost(message, repeated, tag = "2")]
    pub results: ::prost::alloc::vec::Vec<MutateAdGroupAdLabelResult>,
}
/// The result for an ad group ad label mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAdGroupAdLabelResult {
    /// Returned for successful operations.
    #[prost(string, tag = "1")]
    pub resource_name: ::prost::alloc::string::String,
}
/// Generated server implementations.
pub mod ad_group_ad_label_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with AdGroupAdLabelServiceServer.
    #[async_trait]
    pub trait AdGroupAdLabelService: std::marker::Send + std::marker::Sync + 'static {
        /// Creates and removes ad group ad labels.
        /// Operation statuses are returned.
        ///
        /// List of thrown errors:
        ///   [AuthenticationError]()
        ///   [AuthorizationError]()
        ///   [DatabaseError]()
        ///   [HeaderError]()
        ///   [InternalError]()
        ///   [LabelError]()
        ///   [MutateError]()
        ///   [NewResourceCreationError]()
        ///   [QuotaError]()
        ///   [RequestError]()
        async fn mutate_ad_group_ad_labels(
            &self,
            request: tonic::Request<super::MutateAdGroupAdLabelsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MutateAdGroupAdLabelsResponse>,
            tonic::Status,
        >;
    }
    /// Service to manage labels on ad group ads.
    #[derive(Debug)]
    pub struct AdGroupAdLabelServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> AdGroupAdLabelServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>>
    for AdGroupAdLabelServiceServer<T>
    where
        T: AdGroupAdLabelService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/google.ads.googleads.v16.services.AdGroupAdLabelService/MutateAdGroupAdLabels" => {
                    #[allow(non_camel_case_types)]
                    struct MutateAdGroupAdLabelsSvc<T: AdGroupAdLabelService>(
                        pub Arc<T>,
                    );
                    impl<
                        T: AdGroupAdLabelService,
                    > tonic::server::UnaryService<super::MutateAdGroupAdLabelsRequest>
                    for MutateAdGroupAdLabelsSvc<T> {
                        type Response = super::MutateAdGroupAdLabelsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::MutateAdGroupAdLabelsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as AdGroupAdLabelService>::mutate_ad_group_ad_labels(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = MutateAdGroupAdLabelsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for AdGroupAdLabelServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "google.ads.googleads.v16.services.AdGroupAdLabelService";
    impl<T> tonic::server::NamedService for AdGroupAdLabelServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Request message for
/// [AdGroupAdService.MutateAdGroupAds][google.ads.googleads.v16.services.AdGroupAdService.MutateAdGroupAds].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAdGroupAdsRequest {
    /// Required. The ID of the customer whose ads are being modified.
    #[prost(string, tag = "1")]
    pub customer_id: ::prost::alloc::string::String,
    /// Required. The list of operations to perform on individual ads.
    #[prost(message, repeated, tag = "2")]
    pub operations: ::prost::alloc::vec::Vec<AdGroupAdOperation>,
    /// If true, successful operations will be carried out and invalid
    /// operations will return errors. If false, all operations will be carried
    /// out in one transaction if and only if they are all valid.
    /// Default is false.
    #[prost(bool, tag = "3")]
    pub partial_failure: bool,
    /// If true, the request is validated but not executed. Only errors are
    /// returned, not results.
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
    /// The response content type setting. Determines whether the mutable resource
    /// or just the resource name should be returned post mutation.
    #[prost(
        enumeration = "super::enums::response_content_type_enum::ResponseContentType",
        tag = "5"
    )]
    pub response_content_type: i32,
}
/// A single operation (create, update, remove) on an ad group ad.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AdGroupAdOperation {
    /// FieldMask that determines which resource fields are modified in an update.
    #[prost(message, optional, tag = "4")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// Configuration for how policies are validated.
    #[prost(message, optional, tag = "5")]
    pub policy_validation_parameter: ::core::option::Option<
        super::common::PolicyValidationParameter,
    >,
    /// The mutate operation.
    #[prost(oneof = "ad_group_ad_operation::Operation", tags = "1, 2, 3")]
    pub operation: ::core::option::Option<ad_group_ad_operation::Operation>,
}
/// Nested message and enum types in `AdGroupAdOperation`.
pub mod ad_group_ad_operation {
    /// The mutate operation.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Operation {
        /// Create operation: No resource name is expected for the new ad.
        #[prost(message, tag = "1")]
        Create(super::super::resources::AdGroupAd),
        /// Update operation: The ad is expected to have a valid resource name.
        #[prost(message, tag = "2")]
        Update(super::super::resources::AdGroupAd),
        /// Remove operation: A resource name for the removed ad is expected,
        /// in this format:
        ///
        /// `customers/{customer_id}/adGroupAds/{ad_group_id}~{ad_id}`
        #[prost(string, tag = "3")]
        Remove(::prost::alloc::string::String),
    }
}
/// Response message for an ad group ad mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAdGroupAdsResponse {
    /// Errors that pertain to operation failures in the partial failure mode.
    /// Returned only when partial_failure = true and all errors occur inside the
    /// operations. If any errors occur outside the operations (for example, auth
    /// errors), we return an RPC level error.
    #[prost(message, optional, tag = "3")]
    pub partial_failure_error: ::core::option::Option<
        super::super::super::super::rpc::Status,
    >,
    /// All results for the mutate.
    #[prost(message, repeated, tag = "2")]
    pub results: ::prost::alloc::vec::Vec<MutateAdGroupAdResult>,
}
/// The result for the ad mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAdGroupAdResult {
    /// The resource name returned for successful operations.
    #[prost(string, tag = "1")]
    pub resource_name: ::prost::alloc::string::String,
    /// The mutated ad group ad with only mutable fields after mutate. The field
    /// will only be returned when response_content_type is set to
    /// "MUTABLE_RESOURCE".
    #[prost(message, optional, tag = "2")]
    pub ad_group_ad: ::core::option::Option<super::resources::AdGroupAd>,
}
/// Generated server implementations.
pub mod ad_group_ad_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with AdGroupAdServiceServer.
    #[async_trait]
    pub trait AdGroupAdService: std::marker::Send + std::marker::Sync + 'static {
        /// Creates, updates, or removes ads. Operation statuses are returned.
        ///
        /// List of thrown errors:
        ///   [AdCustomizerError]()
        ///   [AdError]()
        ///   [AdGroupAdError]()
        ///   [AdSharingError]()
        ///   [AdxError]()
        ///   [AssetError]()
        ///   [AssetLinkError]()
        ///   [AuthenticationError]()
        ///   [AuthorizationError]()
        ///   [CollectionSizeError]()
        ///   [ContextError]()
        ///   [DatabaseError]()
        ///   [DateError]()
        ///   [DistinctError]()
        ///   [FeedAttributeReferenceError]()
        ///   [FieldError]()
        ///   [FieldMaskError]()
        ///   [FunctionError]()
        ///   [FunctionParsingError]()
        ///   [HeaderError]()
        ///   [IdError]()
        ///   [ImageError]()
        ///   [InternalError]()
        ///   [ListOperationError]()
        ///   [MediaBundleError]()
        ///   [MediaFileError]()
        ///   [MutateError]()
        ///   [NewResourceCreationError]()
        ///   [NotEmptyError]()
        ///   [NullError]()
        ///   [OperationAccessDeniedError]()
        ///   [OperatorError]()
        ///   [PolicyFindingError]()
        ///   [PolicyValidationParameterError]()
        ///   [PolicyViolationError]()
        ///   [QuotaError]()
        ///   [RangeError]()
        ///   [RequestError]()
        ///   [ResourceCountLimitExceededError]()
        ///   [SizeLimitError]()
        ///   [StringFormatError]()
        ///   [StringLengthError]()
        ///   [UrlFieldError]()
        async fn mutate_ad_group_ads(
            &self,
            request: tonic::Request<super::MutateAdGroupAdsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MutateAdGroupAdsResponse>,
            tonic::Status,
        >;
    }
    /// Service to manage ads in an ad group.
    #[derive(Debug)]
    pub struct AdGroupAdServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> AdGroupAdServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for AdGroupAdServiceServer<T>
    where
        T: AdGroupAdService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/google.ads.googleads.v16.services.AdGroupAdService/MutateAdGroupAds" => {
                    #[allow(non_camel_case_types)]
                    struct MutateAdGroupAdsSvc<T: AdGroupAdService>(pub Arc<T>);
                    impl<
                        T: AdGroupAdService,
                    > tonic::server::UnaryService<super::MutateAdGroupAdsRequest>
                    for MutateAdGroupAdsSvc<T> {
                        type Response = super::MutateAdGroupAdsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::MutateAdGroupAdsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as AdGroupAdService>::mutate_ad_group_ads(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = MutateAdGroupAdsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for AdGroupAdServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "google.ads.googleads.v16.services.AdGroupAdService";
    impl<T> tonic::server::NamedService for AdGroupAdServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Request message for
/// [AdGroupAssetService.MutateAdGroupAssets][google.ads.googleads.v16.services.AdGroupAssetService.MutateAdGroupAssets].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAdGroupAssetsRequest {
    /// Required. The ID of the customer whose ad group assets are being modified.
    #[prost(string, tag = "1")]
    pub customer_id: ::prost::alloc::string::String,
    /// Required. The list of operations to perform on individual ad group assets.
    #[prost(message, repeated, tag = "2")]
    pub operations: ::prost::alloc::vec::Vec<AdGroupAssetOperation>,
    /// If true, successful operations will be carried out and invalid
    /// operations will return errors. If false, all operations will be carried
    /// out in one transaction if and only if they are all valid.
    /// Default is false.
    #[prost(bool, tag = "3")]
    pub partial_failure: bool,
    /// If true, the request is validated but not executed. Only errors are
    /// returned, not results.
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
    /// The response content type setting. Determines whether the mutable resource
    /// or just the resource name should be returned post mutation.
    #[prost(
        enumeration = "super::enums::response_content_type_enum::ResponseContentType",
        tag = "5"
    )]
    pub response_content_type: i32,
}
/// A single operation (create, update, remove) on an ad group asset.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AdGroupAssetOperation {
    /// FieldMask that determines which resource fields are modified in an update.
    #[prost(message, optional, tag = "4")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// The mutate operation.
    #[prost(oneof = "ad_group_asset_operation::Operation", tags = "1, 3, 2")]
    pub operation: ::core::option::Option<ad_group_asset_operation::Operation>,
}
/// Nested message and enum types in `AdGroupAssetOperation`.
pub mod ad_group_asset_operation {
    /// The mutate operation.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Operation {
        /// Create operation: No resource name is expected for the new ad group
        /// asset.
        #[prost(message, tag = "1")]
        Create(super::super::resources::AdGroupAsset),
        /// Update operation: The ad group asset is expected to have a valid resource
        /// name.
        #[prost(message, tag = "3")]
        Update(super::super::resources::AdGroupAsset),
        /// Remove operation: A resource name for the removed ad group asset is
        /// expected, in this format:
        ///
        /// `customers/{customer_id}/adGroupAssets/{ad_group_id}~{asset_id}~{field_type}`
        #[prost(string, tag = "2")]
        Remove(::prost::alloc::string::String),
    }
}
/// Response message for an ad group asset mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAdGroupAssetsResponse {
    /// Errors that pertain to operation failures in the partial failure mode.
    /// Returned only when partial_failure = true and all errors occur inside the
    /// operations. If any errors occur outside the operations (for example, auth
    /// errors), we return an RPC level error.
    #[prost(message, optional, tag = "1")]
    pub partial_failure_error: ::core::option::Option<
        super::super::super::super::rpc::Status,
    >,
    /// All results for the mutate.
    #[prost(message, repeated, tag = "2")]
    pub results: ::prost::alloc::vec::Vec<MutateAdGroupAssetResult>,
}
/// The result for the ad group asset mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAdGroupAssetResult {
    /// Returned for successful operations.
    #[prost(string, tag = "1")]
    pub resource_name: ::prost::alloc::string::String,
    /// The mutated ad group asset with only mutable fields after
    /// mutate. The field will only be returned when response_content_type is set
    /// to "MUTABLE_RESOURCE".
    #[prost(message, optional, tag = "2")]
    pub ad_group_asset: ::core::option::Option<super::resources::AdGroupAsset>,
}
/// Generated server implementations.
pub mod ad_group_asset_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with AdGroupAssetServiceServer.
    #[async_trait]
    pub trait AdGroupAssetService: std::marker::Send + std::marker::Sync + 'static {
        /// Creates, updates, or removes ad group assets. Operation statuses are
        /// returned.
        ///
        /// List of thrown errors:
        ///   [AssetLinkError]()
        ///   [AuthenticationError]()
        ///   [AuthorizationError]()
        ///   [ContextError]()
        ///   [FieldError]()
        ///   [HeaderError]()
        ///   [InternalError]()
        ///   [MutateError]()
        ///   [NotAllowlistedError]()
        ///   [QuotaError]()
        ///   [RequestError]()
        async fn mutate_ad_group_assets(
            &self,
            request: tonic::Request<super::MutateAdGroupAssetsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MutateAdGroupAssetsResponse>,
            tonic::Status,
        >;
    }
    /// Service to manage ad group assets.
    #[derive(Debug)]
    pub struct AdGroupAssetServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> AdGroupAssetServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for AdGroupAssetServiceServer<T>
    where
        T: AdGroupAssetService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/google.ads.googleads.v16.services.AdGroupAssetService/MutateAdGroupAssets" => {
                    #[allow(non_camel_case_types)]
                    struct MutateAdGroupAssetsSvc<T: AdGroupAssetService>(pub Arc<T>);
                    impl<
                        T: AdGroupAssetService,
                    > tonic::server::UnaryService<super::MutateAdGroupAssetsRequest>
                    for MutateAdGroupAssetsSvc<T> {
                        type Response = super::MutateAdGroupAssetsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::MutateAdGroupAssetsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as AdGroupAssetService>::mutate_ad_group_assets(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = MutateAdGroupAssetsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for AdGroupAssetServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "google.ads.googleads.v16.services.AdGroupAssetService";
    impl<T> tonic::server::NamedService for AdGroupAssetServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Request message for
/// [AdGroupAssetSetService.MutateAdGroupAssetSets][google.ads.googleads.v16.services.AdGroupAssetSetService.MutateAdGroupAssetSets].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAdGroupAssetSetsRequest {
    /// Required. The ID of the customer whose ad group asset sets are being
    /// modified.
    #[prost(string, tag = "1")]
    pub customer_id: ::prost::alloc::string::String,
    /// Required. The list of operations to perform on individual ad group asset
    /// sets.
    #[prost(message, repeated, tag = "2")]
    pub operations: ::prost::alloc::vec::Vec<AdGroupAssetSetOperation>,
    /// If true, successful operations will be carried out and invalid
    /// operations will return errors. If false, all operations will be carried
    /// out in one transaction if and only if they are all valid.
    /// Default is false.
    #[prost(bool, tag = "3")]
    pub partial_failure: bool,
    /// If true, the request is validated but not executed. Only errors are
    /// returned, not results.
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
    /// The response content type setting. Determines whether the mutable resource
    /// or just the resource name should be returned post mutation.
    #[prost(
        enumeration = "super::enums::response_content_type_enum::ResponseContentType",
        tag = "5"
    )]
    pub response_content_type: i32,
}
/// A single operation (create, remove) on an ad group asset set.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AdGroupAssetSetOperation {
    /// The mutate operation.
    #[prost(oneof = "ad_group_asset_set_operation::Operation", tags = "1, 2")]
    pub operation: ::core::option::Option<ad_group_asset_set_operation::Operation>,
}
/// Nested message and enum types in `AdGroupAssetSetOperation`.
pub mod ad_group_asset_set_operation {
    /// The mutate operation.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Operation {
        /// Create operation: No resource name is expected for the new ad group asset
        /// set.
        #[prost(message, tag = "1")]
        Create(super::super::resources::AdGroupAssetSet),
        /// Remove operation: A resource name for the removed ad group asset set is
        /// expected, in this format:
        /// `customers/{customer_id}/adGroupAssetSets/{ad_group_id}~{asset_set_id}`
        #[prost(string, tag = "2")]
        Remove(::prost::alloc::string::String),
    }
}
/// Response message for an ad group asset set mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAdGroupAssetSetsResponse {
    /// All results for the mutate.
    #[prost(message, repeated, tag = "1")]
    pub results: ::prost::alloc::vec::Vec<MutateAdGroupAssetSetResult>,
    /// Errors that pertain to operation failures in the partial failure mode.
    /// Returned only when partial_failure = true and all errors occur inside the
    /// operations. If any errors occur outside the operations (e.g. auth errors),
    /// we return an RPC level error.
    #[prost(message, optional, tag = "2")]
    pub partial_failure_error: ::core::option::Option<
        super::super::super::super::rpc::Status,
    >,
}
/// The result for the ad group asset set mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAdGroupAssetSetResult {
    /// Returned for successful operations.
    #[prost(string, tag = "1")]
    pub resource_name: ::prost::alloc::string::String,
    /// The mutated ad group asset set with only mutable fields after mutate. The
    /// field will only be returned when response_content_type is set to
    /// "MUTABLE_RESOURCE".
    #[prost(message, optional, tag = "2")]
    pub ad_group_asset_set: ::core::option::Option<super::resources::AdGroupAssetSet>,
}
/// Generated server implementations.
pub mod ad_group_asset_set_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with AdGroupAssetSetServiceServer.
    #[async_trait]
    pub trait AdGroupAssetSetService: std::marker::Send + std::marker::Sync + 'static {
        /// Creates, or removes ad group asset sets. Operation statuses are
        /// returned.
        async fn mutate_ad_group_asset_sets(
            &self,
            request: tonic::Request<super::MutateAdGroupAssetSetsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MutateAdGroupAssetSetsResponse>,
            tonic::Status,
        >;
    }
    /// Service to manage ad group asset set
    #[derive(Debug)]
    pub struct AdGroupAssetSetServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> AdGroupAssetSetServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>>
    for AdGroupAssetSetServiceServer<T>
    where
        T: AdGroupAssetSetService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/google.ads.googleads.v16.services.AdGroupAssetSetService/MutateAdGroupAssetSets" => {
                    #[allow(non_camel_case_types)]
                    struct MutateAdGroupAssetSetsSvc<T: AdGroupAssetSetService>(
                        pub Arc<T>,
                    );
                    impl<
                        T: AdGroupAssetSetService,
                    > tonic::server::UnaryService<super::MutateAdGroupAssetSetsRequest>
                    for MutateAdGroupAssetSetsSvc<T> {
                        type Response = super::MutateAdGroupAssetSetsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::MutateAdGroupAssetSetsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as AdGroupAssetSetService>::mutate_ad_group_asset_sets(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = MutateAdGroupAssetSetsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for AdGroupAssetSetServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "google.ads.googleads.v16.services.AdGroupAssetSetService";
    impl<T> tonic::server::NamedService for AdGroupAssetSetServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Request message for
/// [AdGroupBidModifierService.MutateAdGroupBidModifiers][google.ads.googleads.v16.services.AdGroupBidModifierService.MutateAdGroupBidModifiers].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAdGroupBidModifiersRequest {
    /// Required. ID of the customer whose ad group bid modifiers are being
    /// modified.
    #[prost(string, tag = "1")]
    pub customer_id: ::prost::alloc::string::String,
    /// Required. The list of operations to perform on individual ad group bid
    /// modifiers.
    #[prost(message, repeated, tag = "2")]
    pub operations: ::prost::alloc::vec::Vec<AdGroupBidModifierOperation>,
    /// If true, successful operations will be carried out and invalid
    /// operations will return errors. If false, all operations will be carried
    /// out in one transaction if and only if they are all valid.
    /// Default is false.
    #[prost(bool, tag = "3")]
    pub partial_failure: bool,
    /// If true, the request is validated but not executed. Only errors are
    /// returned, not results.
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
    /// The response content type setting. Determines whether the mutable resource
    /// or just the resource name should be returned post mutation.
    #[prost(
        enumeration = "super::enums::response_content_type_enum::ResponseContentType",
        tag = "5"
    )]
    pub response_content_type: i32,
}
/// A single operation (create, remove, update) on an ad group bid modifier.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AdGroupBidModifierOperation {
    /// FieldMask that determines which resource fields are modified in an update.
    #[prost(message, optional, tag = "4")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// The mutate operation.
    #[prost(oneof = "ad_group_bid_modifier_operation::Operation", tags = "1, 2, 3")]
    pub operation: ::core::option::Option<ad_group_bid_modifier_operation::Operation>,
}
/// Nested message and enum types in `AdGroupBidModifierOperation`.
pub mod ad_group_bid_modifier_operation {
    /// The mutate operation.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Operation {
        /// Create operation: No resource name is expected for the new ad group bid
        /// modifier.
        #[prost(message, tag = "1")]
        Create(super::super::resources::AdGroupBidModifier),
        /// Update operation: The ad group bid modifier is expected to have a valid
        /// resource name.
        #[prost(message, tag = "2")]
        Update(super::super::resources::AdGroupBidModifier),
        /// Remove operation: A resource name for the removed ad group bid modifier
        /// is expected, in this format:
        ///
        /// `customers/{customer_id}/adGroupBidModifiers/{ad_group_id}~{criterion_id}`
        #[prost(string, tag = "3")]
        Remove(::prost::alloc::string::String),
    }
}
/// Response message for ad group bid modifiers mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAdGroupBidModifiersResponse {
    /// Errors that pertain to operation failures in the partial failure mode.
    /// Returned only when partial_failure = true and all errors occur inside the
    /// operations. If any errors occur outside the operations (for example, auth
    /// errors), we return an RPC level error.
    #[prost(message, optional, tag = "3")]
    pub partial_failure_error: ::core::option::Option<
        super::super::super::super::rpc::Status,
    >,
    /// All results for the mutate.
    #[prost(message, repeated, tag = "2")]
    pub results: ::prost::alloc::vec::Vec<MutateAdGroupBidModifierResult>,
}
/// The result for the criterion mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAdGroupBidModifierResult {
    /// Returned for successful operations.
    #[prost(string, tag = "1")]
    pub resource_name: ::prost::alloc::string::String,
    /// The mutated ad group bid modifier with only mutable fields after mutate.
    /// The field will only be returned when response_content_type is set to
    /// "MUTABLE_RESOURCE".
    #[prost(message, optional, tag = "2")]
    pub ad_group_bid_modifier: ::core::option::Option<
        super::resources::AdGroupBidModifier,
    >,
}
/// Generated server implementations.
pub mod ad_group_bid_modifier_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with AdGroupBidModifierServiceServer.
    #[async_trait]
    pub trait AdGroupBidModifierService: std::marker::Send + std::marker::Sync + 'static {
        /// Creates, updates, or removes ad group bid modifiers.
        /// Operation statuses are returned.
        ///
        /// List of thrown errors:
        ///   [AdGroupBidModifierError]()
        ///   [AuthenticationError]()
        ///   [AuthorizationError]()
        ///   [ContextError]()
        ///   [CriterionError]()
        ///   [DatabaseError]()
        ///   [DistinctError]()
        ///   [FieldError]()
        ///   [FieldMaskError]()
        ///   [HeaderError]()
        ///   [IdError]()
        ///   [InternalError]()
        ///   [MutateError]()
        ///   [NewResourceCreationError]()
        ///   [NotEmptyError]()
        ///   [OperatorError]()
        ///   [QuotaError]()
        ///   [RangeError]()
        ///   [RequestError]()
        ///   [ResourceCountLimitExceededError]()
        ///   [SizeLimitError]()
        ///   [StringFormatError]()
        ///   [StringLengthError]()
        async fn mutate_ad_group_bid_modifiers(
            &self,
            request: tonic::Request<super::MutateAdGroupBidModifiersRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MutateAdGroupBidModifiersResponse>,
            tonic::Status,
        >;
    }
    /// Service to manage ad group bid modifiers.
    #[derive(Debug)]
    pub struct AdGroupBidModifierServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> AdGroupBidModifierServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>>
    for AdGroupBidModifierServiceServer<T>
    where
        T: AdGroupBidModifierService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/google.ads.googleads.v16.services.AdGroupBidModifierService/MutateAdGroupBidModifiers" => {
                    #[allow(non_camel_case_types)]
                    struct MutateAdGroupBidModifiersSvc<T: AdGroupBidModifierService>(
                        pub Arc<T>,
                    );
                    impl<
                        T: AdGroupBidModifierService,
                    > tonic::server::UnaryService<
                        super::MutateAdGroupBidModifiersRequest,
                    > for MutateAdGroupBidModifiersSvc<T> {
                        type Response = super::MutateAdGroupBidModifiersResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::MutateAdGroupBidModifiersRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as AdGroupBidModifierService>::mutate_ad_group_bid_modifiers(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = MutateAdGroupBidModifiersSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for AdGroupBidModifierServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "google.ads.googleads.v16.services.AdGroupBidModifierService";
    impl<T> tonic::server::NamedService for AdGroupBidModifierServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Request message for
/// [AdGroupCriterionCustomizerService.MutateAdGroupCriterionCustomizers][google.ads.googleads.v16.services.AdGroupCriterionCustomizerService.MutateAdGroupCriterionCustomizers].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAdGroupCriterionCustomizersRequest {
    /// Required. The ID of the customer whose ad group criterion customizers are
    /// being modified.
    #[prost(string, tag = "1")]
    pub customer_id: ::prost::alloc::string::String,
    /// Required. The list of operations to perform on individual ad group
    /// criterion customizers.
    #[prost(message, repeated, tag = "2")]
    pub operations: ::prost::alloc::vec::Vec<AdGroupCriterionCustomizerOperation>,
    /// If true, successful operations will be carried out and invalid
    /// operations will return errors. If false, all operations will be carried
    /// out in one transaction if and only if they are all valid.
    /// Default is false.
    #[prost(bool, tag = "3")]
    pub partial_failure: bool,
    /// If true, the request is validated but not executed. Only errors are
    /// returned, not results.
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
    /// The response content type setting. Determines whether the mutable resource
    /// or just the resource name should be returned post mutation.
    #[prost(
        enumeration = "super::enums::response_content_type_enum::ResponseContentType",
        tag = "5"
    )]
    pub response_content_type: i32,
}
/// A single operation (create, remove) on a customizer attribute.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AdGroupCriterionCustomizerOperation {
    /// The mutate operation.
    #[prost(oneof = "ad_group_criterion_customizer_operation::Operation", tags = "1, 2")]
    pub operation: ::core::option::Option<
        ad_group_criterion_customizer_operation::Operation,
    >,
}
/// Nested message and enum types in `AdGroupCriterionCustomizerOperation`.
pub mod ad_group_criterion_customizer_operation {
    /// The mutate operation.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Operation {
        /// Create operation: No resource name is expected for the new ad group
        /// criterion customizer.
        #[prost(message, tag = "1")]
        Create(super::super::resources::AdGroupCriterionCustomizer),
        /// Remove operation: A resource name for the removed ad group criterion
        /// customizer is expected, in this format:
        ///
        /// `customers/{customer_id}/adGroupCriterionCustomizers/{ad_group_id}~{criterion_id}~{customizer_attribute_id}`
        #[prost(string, tag = "2")]
        Remove(::prost::alloc::string::String),
    }
}
/// Response message for an ad group criterion customizer mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAdGroupCriterionCustomizersResponse {
    /// All results for the mutate.
    #[prost(message, repeated, tag = "1")]
    pub results: ::prost::alloc::vec::Vec<MutateAdGroupCriterionCustomizerResult>,
    /// Errors that pertain to operation failures in the partial failure mode.
    /// Returned only when partial_failure = true and all errors occur inside the
    /// operations. If any errors occur outside the operations (for example, auth
    /// errors), we return an RPC level error.
    #[prost(message, optional, tag = "2")]
    pub partial_failure_error: ::core::option::Option<
        super::super::super::super::rpc::Status,
    >,
}
/// The result for the ad group criterion customizer mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAdGroupCriterionCustomizerResult {
    /// Returned for successful operations.
    #[prost(string, tag = "1")]
    pub resource_name: ::prost::alloc::string::String,
    /// The mutated AdGroupCriterionCustomizer with only mutable fields after
    /// mutate. The field will only be returned when response_content_type is set
    /// to "MUTABLE_RESOURCE".
    #[prost(message, optional, tag = "2")]
    pub ad_group_criterion_customizer: ::core::option::Option<
        super::resources::AdGroupCriterionCustomizer,
    >,
}
/// Generated server implementations.
pub mod ad_group_criterion_customizer_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with AdGroupCriterionCustomizerServiceServer.
    #[async_trait]
    pub trait AdGroupCriterionCustomizerService: std::marker::Send + std::marker::Sync + 'static {
        /// Creates, updates or removes ad group criterion customizers. Operation
        /// statuses are returned.
        async fn mutate_ad_group_criterion_customizers(
            &self,
            request: tonic::Request<super::MutateAdGroupCriterionCustomizersRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MutateAdGroupCriterionCustomizersResponse>,
            tonic::Status,
        >;
    }
    /// Service to manage ad group criterion customizer
    #[derive(Debug)]
    pub struct AdGroupCriterionCustomizerServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> AdGroupCriterionCustomizerServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>>
    for AdGroupCriterionCustomizerServiceServer<T>
    where
        T: AdGroupCriterionCustomizerService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/google.ads.googleads.v16.services.AdGroupCriterionCustomizerService/MutateAdGroupCriterionCustomizers" => {
                    #[allow(non_camel_case_types)]
                    struct MutateAdGroupCriterionCustomizersSvc<
                        T: AdGroupCriterionCustomizerService,
                    >(
                        pub Arc<T>,
                    );
                    impl<
                        T: AdGroupCriterionCustomizerService,
                    > tonic::server::UnaryService<
                        super::MutateAdGroupCriterionCustomizersRequest,
                    > for MutateAdGroupCriterionCustomizersSvc<T> {
                        type Response = super::MutateAdGroupCriterionCustomizersResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::MutateAdGroupCriterionCustomizersRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as AdGroupCriterionCustomizerService>::mutate_ad_group_criterion_customizers(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = MutateAdGroupCriterionCustomizersSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for AdGroupCriterionCustomizerServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "google.ads.googleads.v16.services.AdGroupCriterionCustomizerService";
    impl<T> tonic::server::NamedService for AdGroupCriterionCustomizerServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Request message for
/// [AdGroupCriterionLabelService.MutateAdGroupCriterionLabels][google.ads.googleads.v16.services.AdGroupCriterionLabelService.MutateAdGroupCriterionLabels].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAdGroupCriterionLabelsRequest {
    /// Required. ID of the customer whose ad group criterion labels are being
    /// modified.
    #[prost(string, tag = "1")]
    pub customer_id: ::prost::alloc::string::String,
    /// Required. The list of operations to perform on ad group criterion labels.
    #[prost(message, repeated, tag = "2")]
    pub operations: ::prost::alloc::vec::Vec<AdGroupCriterionLabelOperation>,
    /// If true, successful operations will be carried out and invalid
    /// operations will return errors. If false, all operations will be carried
    /// out in one transaction if and only if they are all valid.
    /// Default is false.
    #[prost(bool, tag = "3")]
    pub partial_failure: bool,
    /// If true, the request is validated but not executed. Only errors are
    /// returned, not results.
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
}
/// A single operation (create, remove) on an ad group criterion label.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AdGroupCriterionLabelOperation {
    /// The mutate operation.
    #[prost(oneof = "ad_group_criterion_label_operation::Operation", tags = "1, 2")]
    pub operation: ::core::option::Option<ad_group_criterion_label_operation::Operation>,
}
/// Nested message and enum types in `AdGroupCriterionLabelOperation`.
pub mod ad_group_criterion_label_operation {
    /// The mutate operation.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Operation {
        /// Create operation: No resource name is expected for the new ad group
        /// label.
        #[prost(message, tag = "1")]
        Create(super::super::resources::AdGroupCriterionLabel),
        /// Remove operation: A resource name for the ad group criterion label
        /// being removed, in this format:
        ///
        /// `customers/{customer_id}/adGroupCriterionLabels/{ad_group_id}~{criterion_id}~{label_id}`
        #[prost(string, tag = "2")]
        Remove(::prost::alloc::string::String),
    }
}
/// Response message for an ad group criterion labels mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAdGroupCriterionLabelsResponse {
    /// Errors that pertain to operation failures in the partial failure mode.
    /// Returned only when partial_failure = true and all errors occur inside the
    /// operations. If any errors occur outside the operations (for example, auth
    /// errors), we return an RPC level error.
    #[prost(message, optional, tag = "3")]
    pub partial_failure_error: ::core::option::Option<
        super::super::super::super::rpc::Status,
    >,
    /// All results for the mutate.
    #[prost(message, repeated, tag = "2")]
    pub results: ::prost::alloc::vec::Vec<MutateAdGroupCriterionLabelResult>,
}
/// The result for an ad group criterion label mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAdGroupCriterionLabelResult {
    /// Returned for successful operations.
    #[prost(string, tag = "1")]
    pub resource_name: ::prost::alloc::string::String,
}
/// Generated server implementations.
pub mod ad_group_criterion_label_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with AdGroupCriterionLabelServiceServer.
    #[async_trait]
    pub trait AdGroupCriterionLabelService: std::marker::Send + std::marker::Sync + 'static {
        /// Creates and removes ad group criterion labels.
        /// Operation statuses are returned.
        ///
        /// List of thrown errors:
        ///   [AuthenticationError]()
        ///   [AuthorizationError]()
        ///   [DatabaseError]()
        ///   [FieldError]()
        ///   [HeaderError]()
        ///   [InternalError]()
        ///   [QuotaError]()
        ///   [RequestError]()
        async fn mutate_ad_group_criterion_labels(
            &self,
            request: tonic::Request<super::MutateAdGroupCriterionLabelsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MutateAdGroupCriterionLabelsResponse>,
            tonic::Status,
        >;
    }
    /// Service to manage labels on ad group criteria.
    #[derive(Debug)]
    pub struct AdGroupCriterionLabelServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> AdGroupCriterionLabelServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>>
    for AdGroupCriterionLabelServiceServer<T>
    where
        T: AdGroupCriterionLabelService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/google.ads.googleads.v16.services.AdGroupCriterionLabelService/MutateAdGroupCriterionLabels" => {
                    #[allow(non_camel_case_types)]
                    struct MutateAdGroupCriterionLabelsSvc<
                        T: AdGroupCriterionLabelService,
                    >(
                        pub Arc<T>,
                    );
                    impl<
                        T: AdGroupCriterionLabelService,
                    > tonic::server::UnaryService<
                        super::MutateAdGroupCriterionLabelsRequest,
                    > for MutateAdGroupCriterionLabelsSvc<T> {
                        type Response = super::MutateAdGroupCriterionLabelsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::MutateAdGroupCriterionLabelsRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as AdGroupCriterionLabelService>::mutate_ad_group_criterion_labels(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = MutateAdGroupCriterionLabelsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for AdGroupCriterionLabelServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "google.ads.googleads.v16.services.AdGroupCriterionLabelService";
    impl<T> tonic::server::NamedService for AdGroupCriterionLabelServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Request message for
/// [AdGroupCriterionService.MutateAdGroupCriteria][google.ads.googleads.v16.services.AdGroupCriterionService.MutateAdGroupCriteria].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAdGroupCriteriaRequest {
    /// Required. ID of the customer whose criteria are being modified.
    #[prost(string, tag = "1")]
    pub customer_id: ::prost::alloc::string::String,
    /// Required. The list of operations to perform on individual criteria.
    #[prost(message, repeated, tag = "2")]
    pub operations: ::prost::alloc::vec::Vec<AdGroupCriterionOperation>,
    /// If true, successful operations will be carried out and invalid
    /// operations will return errors. If false, all operations will be carried
    /// out in one transaction if and only if they are all valid.
    /// Default is false.
    #[prost(bool, tag = "3")]
    pub partial_failure: bool,
    /// If true, the request is validated but not executed. Only errors are
    /// returned, not results.
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
    /// The response content type setting. Determines whether the mutable resource
    /// or just the resource name should be returned post mutation.
    #[prost(
        enumeration = "super::enums::response_content_type_enum::ResponseContentType",
        tag = "5"
    )]
    pub response_content_type: i32,
}
/// A single operation (create, remove, update) on an ad group criterion.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AdGroupCriterionOperation {
    /// FieldMask that determines which resource fields are modified in an update.
    #[prost(message, optional, tag = "4")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// The list of policy violation keys that should not cause a
    /// PolicyViolationError to be reported. Not all policy violations are
    /// exemptable, refer to the is_exemptible field in the returned
    /// PolicyViolationError.
    ///
    /// Resources violating these polices will be saved, but will not be eligible
    /// to serve. They may begin serving at a later time due to a change in
    /// policies, re-review of the resource, or a change in advertiser
    /// certificates.
    #[prost(message, repeated, tag = "5")]
    pub exempt_policy_violation_keys: ::prost::alloc::vec::Vec<
        super::common::PolicyViolationKey,
    >,
    /// The mutate operation.
    #[prost(oneof = "ad_group_criterion_operation::Operation", tags = "1, 2, 3")]
    pub operation: ::core::option::Option<ad_group_criterion_operation::Operation>,
}
/// Nested message and enum types in `AdGroupCriterionOperation`.
pub mod ad_group_criterion_operation {
    /// The mutate operation.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Operation {
        /// Create operation: No resource name is expected for the new criterion.
        #[prost(message, tag = "1")]
        Create(super::super::resources::AdGroupCriterion),
        /// Update operation: The criterion is expected to have a valid resource
        /// name.
        #[prost(message, tag = "2")]
        Update(super::super::resources::AdGroupCriterion),
        /// Remove operation: A resource name for the removed criterion is expected,
        /// in this format:
        ///
        /// `customers/{customer_id}/adGroupCriteria/{ad_group_id}~{criterion_id}`
        #[prost(string, tag = "3")]
        Remove(::prost::alloc::string::String),
    }
}
/// Response message for an ad group criterion mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAdGroupCriteriaResponse {
    /// Errors that pertain to operation failures in the partial failure mode.
    /// Returned only when partial_failure = true and all errors occur inside the
    /// operations. If any errors occur outside the operations (for example, auth
    /// errors), we return an RPC level error.
    #[prost(message, optional, tag = "3")]
    pub partial_failure_error: ::core::option::Option<
        super::super::super::super::rpc::Status,
    >,
    /// All results for the mutate.
    #[prost(message, repeated, tag = "2")]
    pub results: ::prost::alloc::vec::Vec<MutateAdGroupCriterionResult>,
}
/// The result for the criterion mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAdGroupCriterionResult {
    /// Returned for successful operations.
    #[prost(string, tag = "1")]
    pub resource_name: ::prost::alloc::string::String,
    /// The mutated ad group criterion with only mutable fields after mutate. The
    /// field will only be returned when response_content_type is set to
    /// "MUTABLE_RESOURCE".
    #[prost(message, optional, tag = "2")]
    pub ad_group_criterion: ::core::option::Option<super::resources::AdGroupCriterion>,
}
/// Generated server implementations.
pub mod ad_group_criterion_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with AdGroupCriterionServiceServer.
    #[async_trait]
    pub trait AdGroupCriterionService: std::marker::Send + std::marker::Sync + 'static {
        /// Creates, updates, or removes criteria. Operation statuses are returned.
        ///
        /// List of thrown errors:
        ///   [AdGroupCriterionError]()
        ///   [AdxError]()
        ///   [AuthenticationError]()
        ///   [AuthorizationError]()
        ///   [BiddingError]()
        ///   [BiddingStrategyError]()
        ///   [CollectionSizeError]()
        ///   [ContextError]()
        ///   [CriterionError]()
        ///   [DatabaseError]()
        ///   [DateError]()
        ///   [DistinctError]()
        ///   [FieldError]()
        ///   [FieldMaskError]()
        ///   [HeaderError]()
        ///   [IdError]()
        ///   [InternalError]()
        ///   [MultiplierError]()
        ///   [MutateError]()
        ///   [NewResourceCreationError]()
        ///   [NotEmptyError]()
        ///   [NullError]()
        ///   [OperationAccessDeniedError]()
        ///   [OperatorError]()
        ///   [PolicyViolationError]()
        ///   [QuotaError]()
        ///   [RangeError]()
        ///   [RequestError]()
        ///   [ResourceCountLimitExceededError]()
        ///   [SizeLimitError]()
        ///   [StringFormatError]()
        ///   [StringLengthError]()
        ///   [UrlFieldError]()
        async fn mutate_ad_group_criteria(
            &self,
            request: tonic::Request<super::MutateAdGroupCriteriaRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MutateAdGroupCriteriaResponse>,
            tonic::Status,
        >;
    }
    /// Service to manage ad group criteria.
    #[derive(Debug)]
    pub struct AdGroupCriterionServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> AdGroupCriterionServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>>
    for AdGroupCriterionServiceServer<T>
    where
        T: AdGroupCriterionService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/google.ads.googleads.v16.services.AdGroupCriterionService/MutateAdGroupCriteria" => {
                    #[allow(non_camel_case_types)]
                    struct MutateAdGroupCriteriaSvc<T: AdGroupCriterionService>(
                        pub Arc<T>,
                    );
                    impl<
                        T: AdGroupCriterionService,
                    > tonic::server::UnaryService<super::MutateAdGroupCriteriaRequest>
                    for MutateAdGroupCriteriaSvc<T> {
                        type Response = super::MutateAdGroupCriteriaResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::MutateAdGroupCriteriaRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as AdGroupCriterionService>::mutate_ad_group_criteria(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = MutateAdGroupCriteriaSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for AdGroupCriterionServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "google.ads.googleads.v16.services.AdGroupCriterionService";
    impl<T> tonic::server::NamedService for AdGroupCriterionServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Request message for
/// [AdGroupCustomizerService.MutateAdGroupCustomizers][google.ads.googleads.v16.services.AdGroupCustomizerService.MutateAdGroupCustomizers].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAdGroupCustomizersRequest {
    /// Required. The ID of the customer whose ad group customizers are being
    /// modified.
    #[prost(string, tag = "1")]
    pub customer_id: ::prost::alloc::string::String,
    /// Required. The list of operations to perform on individual ad group
    /// customizers.
    #[prost(message, repeated, tag = "2")]
    pub operations: ::prost::alloc::vec::Vec<AdGroupCustomizerOperation>,
    /// If true, successful operations will be carried out and invalid
    /// operations will return errors. If false, all operations will be carried
    /// out in one transaction if and only if they are all valid.
    /// Default is false.
    #[prost(bool, tag = "3")]
    pub partial_failure: bool,
    /// If true, the request is validated but not executed. Only errors are
    /// returned, not results.
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
    /// The response content type setting. Determines whether the mutable resource
    /// or just the resource name should be returned post mutation.
    #[prost(
        enumeration = "super::enums::response_content_type_enum::ResponseContentType",
        tag = "5"
    )]
    pub response_content_type: i32,
}
/// A single operation (create, remove) on a customizer attribute.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AdGroupCustomizerOperation {
    /// The mutate operation.
    #[prost(oneof = "ad_group_customizer_operation::Operation", tags = "1, 2")]
    pub operation: ::core::option::Option<ad_group_customizer_operation::Operation>,
}
/// Nested message and enum types in `AdGroupCustomizerOperation`.
pub mod ad_group_customizer_operation {
    /// The mutate operation.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Operation {
        /// Create operation: No resource name is expected for the new ad group
        /// customizer
        #[prost(message, tag = "1")]
        Create(super::super::resources::AdGroupCustomizer),
        /// Remove operation: A resource name for the removed ad group customizer is
        /// expected, in this format:
        /// `customers/{customer_id}/adGroupCustomizers/{ad_group_id}~{customizer_attribute_id}`
        #[prost(string, tag = "2")]
        Remove(::prost::alloc::string::String),
    }
}
/// Response message for an ad group customizer mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAdGroupCustomizersResponse {
    /// All results for the mutate.
    #[prost(message, repeated, tag = "1")]
    pub results: ::prost::alloc::vec::Vec<MutateAdGroupCustomizerResult>,
    /// Errors that pertain to operation failures in the partial failure mode.
    /// Returned only when partial_failure = true and all errors occur inside the
    /// operations. If any errors occur outside the operations (for example, auth
    /// errors), we return an RPC level error.
    #[prost(message, optional, tag = "2")]
    pub partial_failure_error: ::core::option::Option<
        super::super::super::super::rpc::Status,
    >,
}
/// The result for the ad group customizer mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAdGroupCustomizerResult {
    /// Returned for successful operations.
    #[prost(string, tag = "1")]
    pub resource_name: ::prost::alloc::string::String,
    /// The mutated AdGroupCustomizer with only mutable fields after mutate.
    /// The field will only be returned when response_content_type is set to
    /// "MUTABLE_RESOURCE".
    #[prost(message, optional, tag = "2")]
    pub ad_group_customizer: ::core::option::Option<super::resources::AdGroupCustomizer>,
}
/// Generated server implementations.
pub mod ad_group_customizer_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with AdGroupCustomizerServiceServer.
    #[async_trait]
    pub trait AdGroupCustomizerService: std::marker::Send + std::marker::Sync + 'static {
        /// Creates, updates or removes ad group customizers. Operation statuses are
        /// returned.
        async fn mutate_ad_group_customizers(
            &self,
            request: tonic::Request<super::MutateAdGroupCustomizersRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MutateAdGroupCustomizersResponse>,
            tonic::Status,
        >;
    }
    /// Service to manage ad group customizer
    #[derive(Debug)]
    pub struct AdGroupCustomizerServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> AdGroupCustomizerServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>>
    for AdGroupCustomizerServiceServer<T>
    where
        T: AdGroupCustomizerService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/google.ads.googleads.v16.services.AdGroupCustomizerService/MutateAdGroupCustomizers" => {
                    #[allow(non_camel_case_types)]
                    struct MutateAdGroupCustomizersSvc<T: AdGroupCustomizerService>(
                        pub Arc<T>,
                    );
                    impl<
                        T: AdGroupCustomizerService,
                    > tonic::server::UnaryService<super::MutateAdGroupCustomizersRequest>
                    for MutateAdGroupCustomizersSvc<T> {
                        type Response = super::MutateAdGroupCustomizersResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::MutateAdGroupCustomizersRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as AdGroupCustomizerService>::mutate_ad_group_customizers(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = MutateAdGroupCustomizersSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for AdGroupCustomizerServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "google.ads.googleads.v16.services.AdGroupCustomizerService";
    impl<T> tonic::server::NamedService for AdGroupCustomizerServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Request message for
/// [AdGroupExtensionSettingService.MutateAdGroupExtensionSettings][google.ads.googleads.v16.services.AdGroupExtensionSettingService.MutateAdGroupExtensionSettings].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAdGroupExtensionSettingsRequest {
    /// Required. The ID of the customer whose ad group extension settings are
    /// being modified.
    #[prost(string, tag = "1")]
    pub customer_id: ::prost::alloc::string::String,
    /// Required. The list of operations to perform on individual ad group
    /// extension settings.
    #[prost(message, repeated, tag = "2")]
    pub operations: ::prost::alloc::vec::Vec<AdGroupExtensionSettingOperation>,
    /// If true, successful operations will be carried out and invalid
    /// operations will return errors. If false, all operations will be carried
    /// out in one transaction if and only if they are all valid.
    /// Default is false.
    #[prost(bool, tag = "3")]
    pub partial_failure: bool,
    /// If true, the request is validated but not executed. Only errors are
    /// returned, not results.
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
}
/// A single operation (create, update, remove) on an ad group extension setting.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AdGroupExtensionSettingOperation {
    /// FieldMask that determines which resource fields are modified in an update.
    #[prost(message, optional, tag = "4")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// The response content type setting. Determines whether the mutable resource
    /// or just the resource name should be returned post mutation.
    #[prost(
        enumeration = "super::enums::response_content_type_enum::ResponseContentType",
        tag = "5"
    )]
    pub response_content_type: i32,
    /// The mutate operation.
    #[prost(oneof = "ad_group_extension_setting_operation::Operation", tags = "1, 2, 3")]
    pub operation: ::core::option::Option<
        ad_group_extension_setting_operation::Operation,
    >,
}
/// Nested message and enum types in `AdGroupExtensionSettingOperation`.
pub mod ad_group_extension_setting_operation {
    /// The mutate operation.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Operation {
        /// Create operation: No resource name is expected for the new ad group
        /// extension setting.
        #[prost(message, tag = "1")]
        Create(super::super::resources::AdGroupExtensionSetting),
        /// Update operation: The ad group extension setting is expected to have a
        /// valid resource name.
        #[prost(message, tag = "2")]
        Update(super::super::resources::AdGroupExtensionSetting),
        /// Remove operation: A resource name for the removed ad group extension
        /// setting is expected, in this format:
        ///
        /// `customers/{customer_id}/adGroupExtensionSettings/{ad_group_id}~{extension_type}`
        #[prost(string, tag = "3")]
        Remove(::prost::alloc::string::String),
    }
}
/// Response message for an ad group extension setting mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAdGroupExtensionSettingsResponse {
    /// Errors that pertain to operation failures in the partial failure mode.
    /// Returned only when partial_failure = true and all errors occur inside the
    /// operations. If any errors occur outside the operations (for example, auth
    /// errors), we return an RPC level error.
    #[prost(message, optional, tag = "3")]
    pub partial_failure_error: ::core::option::Option<
        super::super::super::super::rpc::Status,
    >,
    /// All results for the mutate.
    #[prost(message, repeated, tag = "2")]
    pub results: ::prost::alloc::vec::Vec<MutateAdGroupExtensionSettingResult>,
}
/// The result for the ad group extension setting mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAdGroupExtensionSettingResult {
    /// Returned for successful operations.
    #[prost(string, tag = "1")]
    pub resource_name: ::prost::alloc::string::String,
    /// The mutated AdGroupExtensionSetting with only mutable fields after mutate.
    /// The field will only be returned when response_content_type is set to
    /// "MUTABLE_RESOURCE".
    #[prost(message, optional, tag = "2")]
    pub ad_group_extension_setting: ::core::option::Option<
        super::resources::AdGroupExtensionSetting,
    >,
}
/// Generated server implementations.
pub mod ad_group_extension_setting_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with AdGroupExtensionSettingServiceServer.
    #[async_trait]
    pub trait AdGroupExtensionSettingService: std::marker::Send + std::marker::Sync + 'static {
        /// Creates, updates, or removes ad group extension settings. Operation
        /// statuses are returned.
        ///
        /// List of thrown errors:
        ///   [AuthenticationError]()
        ///   [AuthorizationError]()
        ///   [CollectionSizeError]()
        ///   [CriterionError]()
        ///   [DatabaseError]()
        ///   [DateError]()
        ///   [DistinctError]()
        ///   [ExtensionSettingError]()
        ///   [FieldError]()
        ///   [FieldMaskError]()
        ///   [HeaderError]()
        ///   [IdError]()
        ///   [InternalError]()
        ///   [ListOperationError]()
        ///   [MutateError]()
        ///   [NewResourceCreationError]()
        ///   [NotEmptyError]()
        ///   [NullError]()
        ///   [OperationAccessDeniedError]()
        ///   [OperatorError]()
        ///   [QuotaError]()
        ///   [RangeError]()
        ///   [RequestError]()
        ///   [ResourceCountLimitExceededError]()
        ///   [SizeLimitError]()
        ///   [StringFormatError]()
        ///   [StringLengthError]()
        ///   [UrlFieldError]()
        async fn mutate_ad_group_extension_settings(
            &self,
            request: tonic::Request<super::MutateAdGroupExtensionSettingsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MutateAdGroupExtensionSettingsResponse>,
            tonic::Status,
        >;
    }
    /// Service to manage ad group extension settings.
    #[derive(Debug)]
    pub struct AdGroupExtensionSettingServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> AdGroupExtensionSettingServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>>
    for AdGroupExtensionSettingServiceServer<T>
    where
        T: AdGroupExtensionSettingService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/google.ads.googleads.v16.services.AdGroupExtensionSettingService/MutateAdGroupExtensionSettings" => {
                    #[allow(non_camel_case_types)]
                    struct MutateAdGroupExtensionSettingsSvc<
                        T: AdGroupExtensionSettingService,
                    >(
                        pub Arc<T>,
                    );
                    impl<
                        T: AdGroupExtensionSettingService,
                    > tonic::server::UnaryService<
                        super::MutateAdGroupExtensionSettingsRequest,
                    > for MutateAdGroupExtensionSettingsSvc<T> {
                        type Response = super::MutateAdGroupExtensionSettingsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::MutateAdGroupExtensionSettingsRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as AdGroupExtensionSettingService>::mutate_ad_group_extension_settings(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = MutateAdGroupExtensionSettingsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for AdGroupExtensionSettingServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "google.ads.googleads.v16.services.AdGroupExtensionSettingService";
    impl<T> tonic::server::NamedService for AdGroupExtensionSettingServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Request message for
/// [AdGroupFeedService.MutateAdGroupFeeds][google.ads.googleads.v16.services.AdGroupFeedService.MutateAdGroupFeeds].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAdGroupFeedsRequest {
    /// Required. The ID of the customer whose ad group feeds are being modified.
    #[prost(string, tag = "1")]
    pub customer_id: ::prost::alloc::string::String,
    /// Required. The list of operations to perform on individual ad group feeds.
    #[prost(message, repeated, tag = "2")]
    pub operations: ::prost::alloc::vec::Vec<AdGroupFeedOperation>,
    /// If true, successful operations will be carried out and invalid
    /// operations will return errors. If false, all operations will be carried
    /// out in one transaction if and only if they are all valid.
    /// Default is false.
    #[prost(bool, tag = "3")]
    pub partial_failure: bool,
    /// If true, the request is validated but not executed. Only errors are
    /// returned, not results.
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
    /// The response content type setting. Determines whether the mutable resource
    /// or just the resource name should be returned post mutation.
    #[prost(
        enumeration = "super::enums::response_content_type_enum::ResponseContentType",
        tag = "5"
    )]
    pub response_content_type: i32,
}
/// A single operation (create, update, remove) on an ad group feed.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AdGroupFeedOperation {
    /// FieldMask that determines which resource fields are modified in an update.
    #[prost(message, optional, tag = "4")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// The mutate operation.
    #[prost(oneof = "ad_group_feed_operation::Operation", tags = "1, 2, 3")]
    pub operation: ::core::option::Option<ad_group_feed_operation::Operation>,
}
/// Nested message and enum types in `AdGroupFeedOperation`.
pub mod ad_group_feed_operation {
    /// The mutate operation.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Operation {
        /// Create operation: No resource name is expected for the new ad group feed.
        #[prost(message, tag = "1")]
        Create(super::super::resources::AdGroupFeed),
        /// Update operation: The ad group feed is expected to have a valid resource
        /// name.
        #[prost(message, tag = "2")]
        Update(super::super::resources::AdGroupFeed),
        /// Remove operation: A resource name for the removed ad group feed is
        /// expected, in this format:
        ///
        /// `customers/{customer_id}/adGroupFeeds/{ad_group_id}~{feed_id}`
        #[prost(string, tag = "3")]
        Remove(::prost::alloc::string::String),
    }
}
/// Response message for an ad group feed mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAdGroupFeedsResponse {
    /// Errors that pertain to operation failures in the partial failure mode.
    /// Returned only when partial_failure = true and all errors occur inside the
    /// operations. If any errors occur outside the operations (for example, auth
    /// errors), we return an RPC level error.
    #[prost(message, optional, tag = "3")]
    pub partial_failure_error: ::core::option::Option<
        super::super::super::super::rpc::Status,
    >,
    /// All results for the mutate.
    #[prost(message, repeated, tag = "2")]
    pub results: ::prost::alloc::vec::Vec<MutateAdGroupFeedResult>,
}
/// The result for the ad group feed mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAdGroupFeedResult {
    /// Returned for successful operations.
    #[prost(string, tag = "1")]
    pub resource_name: ::prost::alloc::string::String,
    /// The mutated ad group feed with only mutable fields after mutate. The field
    /// will only be returned when response_content_type is set to
    /// "MUTABLE_RESOURCE".
    #[prost(message, optional, tag = "2")]
    pub ad_group_feed: ::core::option::Option<super::resources::AdGroupFeed>,
}
/// Generated server implementations.
pub mod ad_group_feed_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with AdGroupFeedServiceServer.
    #[async_trait]
    pub trait AdGroupFeedService: std::marker::Send + std::marker::Sync + 'static {
        /// Creates, updates, or removes ad group feeds. Operation statuses are
        /// returned.
        ///
        /// List of thrown errors:
        ///   [AdGroupFeedError]()
        ///   [AuthenticationError]()
        ///   [AuthorizationError]()
        ///   [CollectionSizeError]()
        ///   [DatabaseError]()
        ///   [DistinctError]()
        ///   [FieldError]()
        ///   [FunctionError]()
        ///   [FunctionParsingError]()
        ///   [HeaderError]()
        ///   [IdError]()
        ///   [InternalError]()
        ///   [MutateError]()
        ///   [NotEmptyError]()
        ///   [NullError]()
        ///   [OperatorError]()
        ///   [QuotaError]()
        ///   [RangeError]()
        ///   [RequestError]()
        ///   [SizeLimitError]()
        ///   [StringFormatError]()
        ///   [StringLengthError]()
        async fn mutate_ad_group_feeds(
            &self,
            request: tonic::Request<super::MutateAdGroupFeedsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MutateAdGroupFeedsResponse>,
            tonic::Status,
        >;
    }
    /// Service to manage ad group feeds.
    #[derive(Debug)]
    pub struct AdGroupFeedServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> AdGroupFeedServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for AdGroupFeedServiceServer<T>
    where
        T: AdGroupFeedService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/google.ads.googleads.v16.services.AdGroupFeedService/MutateAdGroupFeeds" => {
                    #[allow(non_camel_case_types)]
                    struct MutateAdGroupFeedsSvc<T: AdGroupFeedService>(pub Arc<T>);
                    impl<
                        T: AdGroupFeedService,
                    > tonic::server::UnaryService<super::MutateAdGroupFeedsRequest>
                    for MutateAdGroupFeedsSvc<T> {
                        type Response = super::MutateAdGroupFeedsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::MutateAdGroupFeedsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as AdGroupFeedService>::mutate_ad_group_feeds(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = MutateAdGroupFeedsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for AdGroupFeedServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "google.ads.googleads.v16.services.AdGroupFeedService";
    impl<T> tonic::server::NamedService for AdGroupFeedServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Request message for
/// [AdGroupLabelService.MutateAdGroupLabels][google.ads.googleads.v16.services.AdGroupLabelService.MutateAdGroupLabels].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAdGroupLabelsRequest {
    /// Required. ID of the customer whose ad group labels are being modified.
    #[prost(string, tag = "1")]
    pub customer_id: ::prost::alloc::string::String,
    /// Required. The list of operations to perform on ad group labels.
    #[prost(message, repeated, tag = "2")]
    pub operations: ::prost::alloc::vec::Vec<AdGroupLabelOperation>,
    /// If true, successful operations will be carried out and invalid
    /// operations will return errors. If false, all operations will be carried
    /// out in one transaction if and only if they are all valid.
    /// Default is false.
    #[prost(bool, tag = "3")]
    pub partial_failure: bool,
    /// If true, the request is validated but not executed. Only errors are
    /// returned, not results.
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
}
/// A single operation (create, remove) on an ad group label.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AdGroupLabelOperation {
    /// The mutate operation.
    #[prost(oneof = "ad_group_label_operation::Operation", tags = "1, 2")]
    pub operation: ::core::option::Option<ad_group_label_operation::Operation>,
}
/// Nested message and enum types in `AdGroupLabelOperation`.
pub mod ad_group_label_operation {
    /// The mutate operation.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Operation {
        /// Create operation: No resource name is expected for the new ad group
        /// label.
        #[prost(message, tag = "1")]
        Create(super::super::resources::AdGroupLabel),
        /// Remove operation: A resource name for the ad group label
        /// being removed, in this format:
        ///
        /// `customers/{customer_id}/adGroupLabels/{ad_group_id}~{label_id}`
        #[prost(string, tag = "2")]
        Remove(::prost::alloc::string::String),
    }
}
/// Response message for an ad group labels mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAdGroupLabelsResponse {
    /// Errors that pertain to operation failures in the partial failure mode.
    /// Returned only when partial_failure = true and all errors occur inside the
    /// operations. If any errors occur outside the operations (for example, auth
    /// errors), we return an RPC level error.
    #[prost(message, optional, tag = "3")]
    pub partial_failure_error: ::core::option::Option<
        super::super::super::super::rpc::Status,
    >,
    /// All results for the mutate.
    #[prost(message, repeated, tag = "2")]
    pub results: ::prost::alloc::vec::Vec<MutateAdGroupLabelResult>,
}
/// The result for an ad group label mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAdGroupLabelResult {
    /// Returned for successful operations.
    #[prost(string, tag = "1")]
    pub resource_name: ::prost::alloc::string::String,
}
/// Generated server implementations.
pub mod ad_group_label_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with AdGroupLabelServiceServer.
    #[async_trait]
    pub trait AdGroupLabelService: std::marker::Send + std::marker::Sync + 'static {
        /// Creates and removes ad group labels.
        /// Operation statuses are returned.
        ///
        /// List of thrown errors:
        ///   [AuthenticationError]()
        ///   [AuthorizationError]()
        ///   [DatabaseError]()
        ///   [FieldError]()
        ///   [HeaderError]()
        ///   [InternalError]()
        ///   [LabelError]()
        ///   [MutateError]()
        ///   [NewResourceCreationError]()
        ///   [QuotaError]()
        ///   [RequestError]()
        async fn mutate_ad_group_labels(
            &self,
            request: tonic::Request<super::MutateAdGroupLabelsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MutateAdGroupLabelsResponse>,
            tonic::Status,
        >;
    }
    /// Service to manage labels on ad groups.
    #[derive(Debug)]
    pub struct AdGroupLabelServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> AdGroupLabelServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for AdGroupLabelServiceServer<T>
    where
        T: AdGroupLabelService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/google.ads.googleads.v16.services.AdGroupLabelService/MutateAdGroupLabels" => {
                    #[allow(non_camel_case_types)]
                    struct MutateAdGroupLabelsSvc<T: AdGroupLabelService>(pub Arc<T>);
                    impl<
                        T: AdGroupLabelService,
                    > tonic::server::UnaryService<super::MutateAdGroupLabelsRequest>
                    for MutateAdGroupLabelsSvc<T> {
                        type Response = super::MutateAdGroupLabelsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::MutateAdGroupLabelsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as AdGroupLabelService>::mutate_ad_group_labels(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = MutateAdGroupLabelsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for AdGroupLabelServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "google.ads.googleads.v16.services.AdGroupLabelService";
    impl<T> tonic::server::NamedService for AdGroupLabelServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Request message for
/// [AdGroupService.MutateAdGroups][google.ads.googleads.v16.services.AdGroupService.MutateAdGroups].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAdGroupsRequest {
    /// Required. The ID of the customer whose ad groups are being modified.
    #[prost(string, tag = "1")]
    pub customer_id: ::prost::alloc::string::String,
    /// Required. The list of operations to perform on individual ad groups.
    #[prost(message, repeated, tag = "2")]
    pub operations: ::prost::alloc::vec::Vec<AdGroupOperation>,
    /// If true, successful operations will be carried out and invalid
    /// operations will return errors. If false, all operations will be carried
    /// out in one transaction if and only if they are all valid.
    /// Default is false.
    #[prost(bool, tag = "3")]
    pub partial_failure: bool,
    /// If true, the request is validated but not executed. Only errors are
    /// returned, not results.
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
    /// The response content type setting. Determines whether the mutable resource
    /// or just the resource name should be returned post mutation.
    #[prost(
        enumeration = "super::enums::response_content_type_enum::ResponseContentType",
        tag = "5"
    )]
    pub response_content_type: i32,
}
/// A single operation (create, update, remove) on an ad group.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AdGroupOperation {
    /// FieldMask that determines which resource fields are modified in an update.
    #[prost(message, optional, tag = "4")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// The mutate operation.
    #[prost(oneof = "ad_group_operation::Operation", tags = "1, 2, 3")]
    pub operation: ::core::option::Option<ad_group_operation::Operation>,
}
/// Nested message and enum types in `AdGroupOperation`.
pub mod ad_group_operation {
    /// The mutate operation.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Operation {
        /// Create operation: No resource name is expected for the new ad group.
        #[prost(message, tag = "1")]
        Create(super::super::resources::AdGroup),
        /// Update operation: The ad group is expected to have a valid resource name.
        #[prost(message, tag = "2")]
        Update(super::super::resources::AdGroup),
        /// Remove operation: A resource name for the removed ad group is expected,
        /// in this format:
        ///
        /// `customers/{customer_id}/adGroups/{ad_group_id}`
        #[prost(string, tag = "3")]
        Remove(::prost::alloc::string::String),
    }
}
/// Response message for an ad group mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAdGroupsResponse {
    /// Errors that pertain to operation failures in the partial failure mode.
    /// Returned only when partial_failure = true and all errors occur inside the
    /// operations. If any errors occur outside the operations (for example, auth
    /// errors), we return an RPC level error.
    #[prost(message, optional, tag = "3")]
    pub partial_failure_error: ::core::option::Option<
        super::super::super::super::rpc::Status,
    >,
    /// All results for the mutate.
    #[prost(message, repeated, tag = "2")]
    pub results: ::prost::alloc::vec::Vec<MutateAdGroupResult>,
}
/// The result for the ad group mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAdGroupResult {
    /// Returned for successful operations.
    #[prost(string, tag = "1")]
    pub resource_name: ::prost::alloc::string::String,
    /// The mutated ad group with only mutable fields after mutate. The field will
    /// only be returned when response_content_type is set to "MUTABLE_RESOURCE".
    #[prost(message, optional, tag = "2")]
    pub ad_group: ::core::option::Option<super::resources::AdGroup>,
}
/// Generated server implementations.
pub mod ad_group_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with AdGroupServiceServer.
    #[async_trait]
    pub trait AdGroupService: std::marker::Send + std::marker::Sync + 'static {
        /// Creates, updates, or removes ad groups. Operation statuses are returned.
        ///
        /// List of thrown errors:
        ///   [AdGroupError]()
        ///   [AdxError]()
        ///   [AuthenticationError]()
        ///   [AuthorizationError]()
        ///   [BiddingError]()
        ///   [BiddingStrategyError]()
        ///   [DatabaseError]()
        ///   [DateError]()
        ///   [DistinctError]()
        ///   [FieldError]()
        ///   [FieldMaskError]()
        ///   [HeaderError]()
        ///   [IdError]()
        ///   [InternalError]()
        ///   [ListOperationError]()
        ///   [MultiplierError]()
        ///   [MutateError]()
        ///   [NewResourceCreationError]()
        ///   [NotEmptyError]()
        ///   [NullError]()
        ///   [OperationAccessDeniedError]()
        ///   [OperatorError]()
        ///   [QuotaError]()
        ///   [RangeError]()
        ///   [RequestError]()
        ///   [ResourceCountLimitExceededError]()
        ///   [SettingError]()
        ///   [SizeLimitError]()
        ///   [StringFormatError]()
        ///   [StringLengthError]()
        ///   [UrlFieldError]()
        async fn mutate_ad_groups(
            &self,
            request: tonic::Request<super::MutateAdGroupsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MutateAdGroupsResponse>,
            tonic::Status,
        >;
    }
    /// Service to manage ad groups.
    #[derive(Debug)]
    pub struct AdGroupServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> AdGroupServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for AdGroupServiceServer<T>
    where
        T: AdGroupService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/google.ads.googleads.v16.services.AdGroupService/MutateAdGroups" => {
                    #[allow(non_camel_case_types)]
                    struct MutateAdGroupsSvc<T: AdGroupService>(pub Arc<T>);
                    impl<
                        T: AdGroupService,
                    > tonic::server::UnaryService<super::MutateAdGroupsRequest>
                    for MutateAdGroupsSvc<T> {
                        type Response = super::MutateAdGroupsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::MutateAdGroupsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as AdGroupService>::mutate_ad_groups(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = MutateAdGroupsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for AdGroupServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "google.ads.googleads.v16.services.AdGroupService";
    impl<T> tonic::server::NamedService for AdGroupServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Request message for
/// [AdParameterService.MutateAdParameters][google.ads.googleads.v16.services.AdParameterService.MutateAdParameters]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAdParametersRequest {
    /// Required. The ID of the customer whose ad parameters are being modified.
    #[prost(string, tag = "1")]
    pub customer_id: ::prost::alloc::string::String,
    /// Required. The list of operations to perform on individual ad parameters.
    #[prost(message, repeated, tag = "2")]
    pub operations: ::prost::alloc::vec::Vec<AdParameterOperation>,
    /// If true, successful operations will be carried out and invalid
    /// operations will return errors. If false, all operations will be carried
    /// out in one transaction if and only if they are all valid.
    /// Default is false.
    #[prost(bool, tag = "3")]
    pub partial_failure: bool,
    /// If true, the request is validated but not executed. Only errors are
    /// returned, not results.
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
    /// The response content type setting. Determines whether the mutable resource
    /// or just the resource name should be returned post mutation.
    #[prost(
        enumeration = "super::enums::response_content_type_enum::ResponseContentType",
        tag = "5"
    )]
    pub response_content_type: i32,
}
/// A single operation (create, update, remove) on ad parameter.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AdParameterOperation {
    /// FieldMask that determines which resource fields are modified in an update.
    #[prost(message, optional, tag = "4")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// The mutate operation.
    #[prost(oneof = "ad_parameter_operation::Operation", tags = "1, 2, 3")]
    pub operation: ::core::option::Option<ad_parameter_operation::Operation>,
}
/// Nested message and enum types in `AdParameterOperation`.
pub mod ad_parameter_operation {
    /// The mutate operation.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Operation {
        /// Create operation: No resource name is expected for the new ad parameter.
        #[prost(message, tag = "1")]
        Create(super::super::resources::AdParameter),
        /// Update operation: The ad parameter is expected to have a valid resource
        /// name.
        #[prost(message, tag = "2")]
        Update(super::super::resources::AdParameter),
        /// Remove operation: A resource name for the ad parameter to remove is
        /// expected in this format:
        ///
        /// `customers/{customer_id}/adParameters/{ad_group_id}~{criterion_id}~{parameter_index}`
        #[prost(string, tag = "3")]
        Remove(::prost::alloc::string::String),
    }
}
/// Response message for an ad parameter mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAdParametersResponse {
    /// Errors that pertain to operation failures in the partial failure mode.
    /// Returned only when partial_failure = true and all errors occur inside the
    /// operations. If any errors occur outside the operations (for example, auth
    /// errors), we return an RPC level error.
    #[prost(message, optional, tag = "3")]
    pub partial_failure_error: ::core::option::Option<
        super::super::super::super::rpc::Status,
    >,
    /// All results for the mutate.
    #[prost(message, repeated, tag = "2")]
    pub results: ::prost::alloc::vec::Vec<MutateAdParameterResult>,
}
/// The result for the ad parameter mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAdParameterResult {
    /// The resource name returned for successful operations.
    #[prost(string, tag = "1")]
    pub resource_name: ::prost::alloc::string::String,
    /// The mutated AdParameter with only mutable fields after mutate. The field
    /// will only be returned when response_content_type is set to
    /// "MUTABLE_RESOURCE".
    #[prost(message, optional, tag = "2")]
    pub ad_parameter: ::core::option::Option<super::resources::AdParameter>,
}
/// Generated server implementations.
pub mod ad_parameter_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with AdParameterServiceServer.
    #[async_trait]
    pub trait AdParameterService: std::marker::Send + std::marker::Sync + 'static {
        /// Creates, updates, or removes ad parameters. Operation statuses are
        /// returned.
        ///
        /// List of thrown errors:
        ///   [AdParameterError]()
        ///   [AuthenticationError]()
        ///   [AuthorizationError]()
        ///   [ContextError]()
        ///   [DatabaseError]()
        ///   [FieldError]()
        ///   [FieldMaskError]()
        ///   [HeaderError]()
        ///   [InternalError]()
        ///   [MutateError]()
        ///   [QuotaError]()
        ///   [RequestError]()
        async fn mutate_ad_parameters(
            &self,
            request: tonic::Request<super::MutateAdParametersRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MutateAdParametersResponse>,
            tonic::Status,
        >;
    }
    /// Service to manage ad parameters.
    #[derive(Debug)]
    pub struct AdParameterServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> AdParameterServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for AdParameterServiceServer<T>
    where
        T: AdParameterService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/google.ads.googleads.v16.services.AdParameterService/MutateAdParameters" => {
                    #[allow(non_camel_case_types)]
                    struct MutateAdParametersSvc<T: AdParameterService>(pub Arc<T>);
                    impl<
                        T: AdParameterService,
                    > tonic::server::UnaryService<super::MutateAdParametersRequest>
                    for MutateAdParametersSvc<T> {
                        type Response = super::MutateAdParametersResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::MutateAdParametersRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as AdParameterService>::mutate_ad_parameters(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = MutateAdParametersSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for AdParameterServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "google.ads.googleads.v16.services.AdParameterService";
    impl<T> tonic::server::NamedService for AdParameterServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Request message for
/// [AdService.GetAd][google.ads.googleads.v16.services.AdService.GetAd].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetAdRequest {
    /// Required. The resource name of the ad to fetch.
    #[prost(string, tag = "1")]
    pub resource_name: ::prost::alloc::string::String,
}
/// Request message for
/// [AdService.MutateAds][google.ads.googleads.v16.services.AdService.MutateAds].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAdsRequest {
    /// Required. The ID of the customer whose ads are being modified.
    #[prost(string, tag = "1")]
    pub customer_id: ::prost::alloc::string::String,
    /// Required. The list of operations to perform on individual ads.
    #[prost(message, repeated, tag = "2")]
    pub operations: ::prost::alloc::vec::Vec<AdOperation>,
    /// If true, successful operations will be carried out and invalid
    /// operations will return errors. If false, all operations will be carried
    /// out in one transaction if and only if they are all valid.
    /// Default is false.
    #[prost(bool, tag = "4")]
    pub partial_failure: bool,
    /// The response content type setting. Determines whether the mutable resource
    /// or just the resource name should be returned post mutation.
    #[prost(
        enumeration = "super::enums::response_content_type_enum::ResponseContentType",
        tag = "5"
    )]
    pub response_content_type: i32,
    /// If true, the request is validated but not executed. Only errors are
    /// returned, not results.
    #[prost(bool, tag = "3")]
    pub validate_only: bool,
}
/// A single update operation on an ad.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AdOperation {
    /// FieldMask that determines which resource fields are modified in an update.
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// Configuration for how policies are validated.
    #[prost(message, optional, tag = "3")]
    pub policy_validation_parameter: ::core::option::Option<
        super::common::PolicyValidationParameter,
    >,
    /// The mutate operation.
    #[prost(oneof = "ad_operation::Operation", tags = "1")]
    pub operation: ::core::option::Option<ad_operation::Operation>,
}
/// Nested message and enum types in `AdOperation`.
pub mod ad_operation {
    /// The mutate operation.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Operation {
        /// Update operation: The ad is expected to have a valid resource name
        /// in this format:
        ///
        /// `customers/{customer_id}/ads/{ad_id}`
        #[prost(message, tag = "1")]
        Update(super::super::resources::Ad),
    }
}
/// Response message for an ad mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAdsResponse {
    /// Errors that pertain to operation failures in the partial failure mode.
    /// Returned only when partial_failure = true and all errors occur inside the
    /// operations. If any errors occur outside the operations (for example, auth
    /// errors), we return an RPC level error.
    #[prost(message, optional, tag = "3")]
    pub partial_failure_error: ::core::option::Option<
        super::super::super::super::rpc::Status,
    >,
    /// All results for the mutate.
    #[prost(message, repeated, tag = "2")]
    pub results: ::prost::alloc::vec::Vec<MutateAdResult>,
}
/// The result for the ad mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAdResult {
    /// The resource name returned for successful operations.
    #[prost(string, tag = "1")]
    pub resource_name: ::prost::alloc::string::String,
    /// The mutated ad with only mutable fields after mutate. The field will only
    /// be returned when response_content_type is set to "MUTABLE_RESOURCE".
    #[prost(message, optional, tag = "2")]
    pub ad: ::core::option::Option<super::resources::Ad>,
}
/// Generated server implementations.
pub mod ad_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with AdServiceServer.
    #[async_trait]
    pub trait AdService: std::marker::Send + std::marker::Sync + 'static {
        /// Returns the requested ad in full detail.
        ///
        /// List of thrown errors:
        ///   [AuthenticationError]()
        ///   [AuthorizationError]()
        ///   [HeaderError]()
        ///   [InternalError]()
        ///   [QuotaError]()
        ///   [RequestError]()
        async fn get_ad(
            &self,
            request: tonic::Request<super::GetAdRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::resources::Ad>,
            tonic::Status,
        >;
        /// Updates ads. Operation statuses are returned. Updating ads is not supported
        /// for TextAd, ExpandedDynamicSearchAd, GmailAd and ImageAd.
        ///
        /// List of thrown errors:
        ///   [AdCustomizerError]()
        ///   [AdError]()
        ///   [AdSharingError]()
        ///   [AdxError]()
        ///   [AssetError]()
        ///   [AssetLinkError]()
        ///   [AuthenticationError]()
        ///   [AuthorizationError]()
        ///   [CollectionSizeError]()
        ///   [DatabaseError]()
        ///   [DateError]()
        ///   [DistinctError]()
        ///   [FeedAttributeReferenceError]()
        ///   [FieldError]()
        ///   [FieldMaskError]()
        ///   [FunctionError]()
        ///   [FunctionParsingError]()
        ///   [HeaderError]()
        ///   [IdError]()
        ///   [ImageError]()
        ///   [InternalError]()
        ///   [ListOperationError]()
        ///   [MediaBundleError]()
        ///   [MediaFileError]()
        ///   [MutateError]()
        ///   [NewResourceCreationError]()
        ///   [NotEmptyError]()
        ///   [NullError]()
        ///   [OperatorError]()
        ///   [PolicyFindingError]()
        ///   [PolicyViolationError]()
        ///   [QuotaError]()
        ///   [RangeError]()
        ///   [RequestError]()
        ///   [SizeLimitError]()
        ///   [StringFormatError]()
        ///   [StringLengthError]()
        ///   [UrlFieldError]()
        async fn mutate_ads(
            &self,
            request: tonic::Request<super::MutateAdsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MutateAdsResponse>,
            tonic::Status,
        >;
    }
    /// Service to manage ads.
    #[derive(Debug)]
    pub struct AdServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> AdServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for AdServiceServer<T>
    where
        T: AdService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/google.ads.googleads.v16.services.AdService/GetAd" => {
                    #[allow(non_camel_case_types)]
                    struct GetAdSvc<T: AdService>(pub Arc<T>);
                    impl<T: AdService> tonic::server::UnaryService<super::GetAdRequest>
                    for GetAdSvc<T> {
                        type Response = super::super::resources::Ad;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetAdRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as AdService>::get_ad(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetAdSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.ads.googleads.v16.services.AdService/MutateAds" => {
                    #[allow(non_camel_case_types)]
                    struct MutateAdsSvc<T: AdService>(pub Arc<T>);
                    impl<
                        T: AdService,
                    > tonic::server::UnaryService<super::MutateAdsRequest>
                    for MutateAdsSvc<T> {
                        type Response = super::MutateAdsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::MutateAdsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as AdService>::mutate_ads(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = MutateAdsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for AdServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "google.ads.googleads.v16.services.AdService";
    impl<T> tonic::server::NamedService for AdServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Request message for
/// [AssetGroupAssetService.MutateAssetGroupAssets][google.ads.googleads.v16.services.AssetGroupAssetService.MutateAssetGroupAssets].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAssetGroupAssetsRequest {
    /// Required. The ID of the customer whose asset group assets are being
    /// modified.
    #[prost(string, tag = "1")]
    pub customer_id: ::prost::alloc::string::String,
    /// Required. The list of operations to perform on individual asset group
    /// assets.
    #[prost(message, repeated, tag = "2")]
    pub operations: ::prost::alloc::vec::Vec<AssetGroupAssetOperation>,
    /// If true, successful operations will be carried out and invalid
    /// operations will return errors. If false, all operations will be carried
    /// out in one transaction if and only if they are all valid.
    /// Default is false.
    #[prost(bool, tag = "3")]
    pub partial_failure: bool,
    /// If true, the request is validated but not executed. Only errors are
    /// returned, not results.
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
}
/// A single operation (create, remove) on an asset group asset.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AssetGroupAssetOperation {
    /// FieldMask that determines which resource fields are modified in an update.
    #[prost(message, optional, tag = "4")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// The mutate operation.
    #[prost(oneof = "asset_group_asset_operation::Operation", tags = "1, 2, 3")]
    pub operation: ::core::option::Option<asset_group_asset_operation::Operation>,
}
/// Nested message and enum types in `AssetGroupAssetOperation`.
pub mod asset_group_asset_operation {
    /// The mutate operation.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Operation {
        /// Create operation: No resource name is expected for the new asset group
        /// asset.
        #[prost(message, tag = "1")]
        Create(super::super::resources::AssetGroupAsset),
        /// Update operation: The asset group asset is expected to have a valid
        /// resource name.
        #[prost(message, tag = "2")]
        Update(super::super::resources::AssetGroupAsset),
        /// Remove operation: A resource name for the removed asset group asset is
        /// expected, in this format:
        /// `customers/{customer_id}/assetGroupAssets/{asset_group_id}~{asset_id}~{field_type}`
        #[prost(string, tag = "3")]
        Remove(::prost::alloc::string::String),
    }
}
/// Response message for an asset group asset mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAssetGroupAssetsResponse {
    /// All results for the mutate.
    #[prost(message, repeated, tag = "1")]
    pub results: ::prost::alloc::vec::Vec<MutateAssetGroupAssetResult>,
    /// Errors that pertain to operation failures in the partial failure mode.
    /// Returned only when partial_failure = true and all errors occur inside the
    /// operations. If any errors occur outside the operations (for example, auth
    /// errors), we return an RPC level error.
    #[prost(message, optional, tag = "2")]
    pub partial_failure_error: ::core::option::Option<
        super::super::super::super::rpc::Status,
    >,
}
/// The result for the asset group asset mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAssetGroupAssetResult {
    /// Returned for successful operations.
    #[prost(string, tag = "1")]
    pub resource_name: ::prost::alloc::string::String,
}
/// Generated server implementations.
pub mod asset_group_asset_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with AssetGroupAssetServiceServer.
    #[async_trait]
    pub trait AssetGroupAssetService: std::marker::Send + std::marker::Sync + 'static {
        /// Creates, updates or removes asset group assets. Operation statuses are
        /// returned.
        async fn mutate_asset_group_assets(
            &self,
            request: tonic::Request<super::MutateAssetGroupAssetsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MutateAssetGroupAssetsResponse>,
            tonic::Status,
        >;
    }
    /// Service to manage asset group asset.
    #[derive(Debug)]
    pub struct AssetGroupAssetServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> AssetGroupAssetServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>>
    for AssetGroupAssetServiceServer<T>
    where
        T: AssetGroupAssetService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/google.ads.googleads.v16.services.AssetGroupAssetService/MutateAssetGroupAssets" => {
                    #[allow(non_camel_case_types)]
                    struct MutateAssetGroupAssetsSvc<T: AssetGroupAssetService>(
                        pub Arc<T>,
                    );
                    impl<
                        T: AssetGroupAssetService,
                    > tonic::server::UnaryService<super::MutateAssetGroupAssetsRequest>
                    for MutateAssetGroupAssetsSvc<T> {
                        type Response = super::MutateAssetGroupAssetsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::MutateAssetGroupAssetsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as AssetGroupAssetService>::mutate_asset_group_assets(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = MutateAssetGroupAssetsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for AssetGroupAssetServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "google.ads.googleads.v16.services.AssetGroupAssetService";
    impl<T> tonic::server::NamedService for AssetGroupAssetServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Request message for
/// [AssetGroupListingGroupFilterService.MutateAssetGroupListingGroupFilters][google.ads.googleads.v16.services.AssetGroupListingGroupFilterService.MutateAssetGroupListingGroupFilters].
/// partial_failure is not supported because the tree needs to be validated
/// together.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAssetGroupListingGroupFiltersRequest {
    /// Required. The ID of the customer whose asset group listing group filters
    /// are being modified.
    #[prost(string, tag = "1")]
    pub customer_id: ::prost::alloc::string::String,
    /// Required. The list of operations to perform on individual asset group
    /// listing group filters.
    #[prost(message, repeated, tag = "2")]
    pub operations: ::prost::alloc::vec::Vec<AssetGroupListingGroupFilterOperation>,
    /// If true, the request is validated but not executed. Only errors are
    /// returned, not results.
    #[prost(bool, tag = "3")]
    pub validate_only: bool,
    /// The response content type setting. Determines whether the mutable resource
    /// or just the resource name should be returned post mutation.
    #[prost(
        enumeration = "super::enums::response_content_type_enum::ResponseContentType",
        tag = "4"
    )]
    pub response_content_type: i32,
}
/// A single operation (create, remove) on an asset group listing group filter.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AssetGroupListingGroupFilterOperation {
    /// FieldMask that determines which resource fields are modified in an update.
    #[prost(message, optional, tag = "4")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// The mutate operation.
    #[prost(
        oneof = "asset_group_listing_group_filter_operation::Operation",
        tags = "1, 2, 3"
    )]
    pub operation: ::core::option::Option<
        asset_group_listing_group_filter_operation::Operation,
    >,
}
/// Nested message and enum types in `AssetGroupListingGroupFilterOperation`.
pub mod asset_group_listing_group_filter_operation {
    /// The mutate operation.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Operation {
        /// Create operation: No resource name is expected for the new asset group
        /// listing group filter.
        #[prost(message, tag = "1")]
        Create(super::super::resources::AssetGroupListingGroupFilter),
        /// Update operation: The asset group listing group filter is expected to
        /// have a valid resource name.
        #[prost(message, tag = "2")]
        Update(super::super::resources::AssetGroupListingGroupFilter),
        /// Remove operation: A resource name for the removed asset group listing
        /// group filter is expected, in this format:
        /// `customers/{customer_id}/assetGroupListingGroupFilters/{asset_group_id}~{listing_group_filter_id}`
        /// An entity can be removed only if it's not referenced by other
        /// parent_listing_group_id. If multiple entities are being deleted, the
        /// mutates must be in the correct order.
        #[prost(string, tag = "3")]
        Remove(::prost::alloc::string::String),
    }
}
/// Response message for an asset group listing group filter mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAssetGroupListingGroupFiltersResponse {
    /// All results for the mutate.
    #[prost(message, repeated, tag = "1")]
    pub results: ::prost::alloc::vec::Vec<MutateAssetGroupListingGroupFilterResult>,
}
/// The result for the asset group listing group filter mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAssetGroupListingGroupFilterResult {
    /// Returned for successful operations.
    #[prost(string, tag = "1")]
    pub resource_name: ::prost::alloc::string::String,
    /// The mutated AssetGroupListingGroupFilter with only mutable fields after
    /// mutate. The field will only be returned when response_content_type is set
    /// to "MUTABLE_RESOURCE".
    #[prost(message, optional, tag = "2")]
    pub asset_group_listing_group_filter: ::core::option::Option<
        super::resources::AssetGroupListingGroupFilter,
    >,
}
/// Generated server implementations.
pub mod asset_group_listing_group_filter_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with AssetGroupListingGroupFilterServiceServer.
    #[async_trait]
    pub trait AssetGroupListingGroupFilterService: std::marker::Send + std::marker::Sync + 'static {
        /// Creates, updates or removes asset group listing group filters. Operation
        /// statuses are returned.
        async fn mutate_asset_group_listing_group_filters(
            &self,
            request: tonic::Request<super::MutateAssetGroupListingGroupFiltersRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MutateAssetGroupListingGroupFiltersResponse>,
            tonic::Status,
        >;
    }
    /// Service to manage asset group listing group filter.
    #[derive(Debug)]
    pub struct AssetGroupListingGroupFilterServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> AssetGroupListingGroupFilterServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>>
    for AssetGroupListingGroupFilterServiceServer<T>
    where
        T: AssetGroupListingGroupFilterService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/google.ads.googleads.v16.services.AssetGroupListingGroupFilterService/MutateAssetGroupListingGroupFilters" => {
                    #[allow(non_camel_case_types)]
                    struct MutateAssetGroupListingGroupFiltersSvc<
                        T: AssetGroupListingGroupFilterService,
                    >(
                        pub Arc<T>,
                    );
                    impl<
                        T: AssetGroupListingGroupFilterService,
                    > tonic::server::UnaryService<
                        super::MutateAssetGroupListingGroupFiltersRequest,
                    > for MutateAssetGroupListingGroupFiltersSvc<T> {
                        type Response = super::MutateAssetGroupListingGroupFiltersResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::MutateAssetGroupListingGroupFiltersRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as AssetGroupListingGroupFilterService>::mutate_asset_group_listing_group_filters(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = MutateAssetGroupListingGroupFiltersSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for AssetGroupListingGroupFilterServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "google.ads.googleads.v16.services.AssetGroupListingGroupFilterService";
    impl<T> tonic::server::NamedService
    for AssetGroupListingGroupFilterServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Request message for
/// [AssetGroupService.MutateAssetGroups][google.ads.googleads.v16.services.AssetGroupService.MutateAssetGroups].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAssetGroupsRequest {
    /// Required. The ID of the customer whose asset groups are being modified.
    #[prost(string, tag = "1")]
    pub customer_id: ::prost::alloc::string::String,
    /// Required. The list of operations to perform on individual asset groups.
    #[prost(message, repeated, tag = "2")]
    pub operations: ::prost::alloc::vec::Vec<AssetGroupOperation>,
    /// If true, the request is validated but not executed. Only errors are
    /// returned, not results.
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
}
/// A single operation (create, remove) on an asset group.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AssetGroupOperation {
    /// FieldMask that determines which resource fields are modified in an update.
    #[prost(message, optional, tag = "4")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// The mutate operation.
    #[prost(oneof = "asset_group_operation::Operation", tags = "1, 2, 3")]
    pub operation: ::core::option::Option<asset_group_operation::Operation>,
}
/// Nested message and enum types in `AssetGroupOperation`.
pub mod asset_group_operation {
    /// The mutate operation.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Operation {
        /// Create operation: No resource name is expected for the new asset group
        #[prost(message, tag = "1")]
        Create(super::super::resources::AssetGroup),
        /// Update operation: The asset group is expected to have a valid resource
        /// name.
        #[prost(message, tag = "2")]
        Update(super::super::resources::AssetGroup),
        /// Remove operation: A resource name for the removed asset group is
        /// expected, in this format:
        /// `customers/{customer_id}/assetGroups/{asset_group_id}`
        #[prost(string, tag = "3")]
        Remove(::prost::alloc::string::String),
    }
}
/// Response message for an asset group mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAssetGroupsResponse {
    /// All results for the mutate.
    #[prost(message, repeated, tag = "1")]
    pub results: ::prost::alloc::vec::Vec<MutateAssetGroupResult>,
    /// Errors that pertain to operation failures in the partial failure mode.
    /// Returned only when partial_failure = true and all errors occur inside the
    /// operations. If any errors occur outside the operations (for example, auth
    /// errors), we return an RPC level error.
    #[prost(message, optional, tag = "2")]
    pub partial_failure_error: ::core::option::Option<
        super::super::super::super::rpc::Status,
    >,
}
/// The result for the asset group mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAssetGroupResult {
    /// Returned for successful operations.
    #[prost(string, tag = "1")]
    pub resource_name: ::prost::alloc::string::String,
}
/// Generated server implementations.
pub mod asset_group_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with AssetGroupServiceServer.
    #[async_trait]
    pub trait AssetGroupService: std::marker::Send + std::marker::Sync + 'static {
        /// Creates, updates or removes asset groups. Operation statuses are
        /// returned.
        async fn mutate_asset_groups(
            &self,
            request: tonic::Request<super::MutateAssetGroupsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MutateAssetGroupsResponse>,
            tonic::Status,
        >;
    }
    /// Service to manage asset group
    #[derive(Debug)]
    pub struct AssetGroupServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> AssetGroupServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for AssetGroupServiceServer<T>
    where
        T: AssetGroupService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/google.ads.googleads.v16.services.AssetGroupService/MutateAssetGroups" => {
                    #[allow(non_camel_case_types)]
                    struct MutateAssetGroupsSvc<T: AssetGroupService>(pub Arc<T>);
                    impl<
                        T: AssetGroupService,
                    > tonic::server::UnaryService<super::MutateAssetGroupsRequest>
                    for MutateAssetGroupsSvc<T> {
                        type Response = super::MutateAssetGroupsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::MutateAssetGroupsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as AssetGroupService>::mutate_asset_groups(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = MutateAssetGroupsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for AssetGroupServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "google.ads.googleads.v16.services.AssetGroupService";
    impl<T> tonic::server::NamedService for AssetGroupServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Request message for
/// [AssetGroupSignalService.MutateAssetGroupSignals][google.ads.googleads.v16.services.AssetGroupSignalService.MutateAssetGroupSignals].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAssetGroupSignalsRequest {
    /// Required. The ID of the customer whose asset group signals are being
    /// modified.
    #[prost(string, tag = "1")]
    pub customer_id: ::prost::alloc::string::String,
    /// Required. The list of operations to perform on individual asset group
    /// signals.
    #[prost(message, repeated, tag = "2")]
    pub operations: ::prost::alloc::vec::Vec<AssetGroupSignalOperation>,
    /// If true, successful operations will be carried out and invalid operations
    /// will return errors. If false, all operations will be carried out in one
    /// transaction if and only if they are all valid. Default is false.
    #[prost(bool, tag = "3")]
    pub partial_failure: bool,
    /// If true, the request is validated but not executed. Only errors are
    /// returned, not results.
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
    /// The response content type setting. Determines whether the mutable resource
    /// or just the resource name should be returned post mutation.
    #[prost(
        enumeration = "super::enums::response_content_type_enum::ResponseContentType",
        tag = "5"
    )]
    pub response_content_type: i32,
}
/// A single operation (create, remove) on an asset group signal.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AssetGroupSignalOperation {
    /// Optional. The list of policy violation keys that should not cause a
    /// PolicyViolationError to be reported. Not all policy violations are
    /// exemptable, refer to the is_exemptible field in the returned
    /// PolicyViolationError.
    ///
    /// Resources violating these polices will be saved, but will not be eligible
    /// to serve. They may begin serving at a later time due to a change in
    /// policies, re-review of the resource, or a change in advertiser
    /// certificates.
    #[prost(message, repeated, tag = "3")]
    pub exempt_policy_violation_keys: ::prost::alloc::vec::Vec<
        super::common::PolicyViolationKey,
    >,
    /// The mutate operation. Update is not supported.
    #[prost(oneof = "asset_group_signal_operation::Operation", tags = "1, 2")]
    pub operation: ::core::option::Option<asset_group_signal_operation::Operation>,
}
/// Nested message and enum types in `AssetGroupSignalOperation`.
pub mod asset_group_signal_operation {
    /// The mutate operation. Update is not supported.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Operation {
        /// Create operation: No resource name is expected for the new asset group
        /// signal.
        #[prost(message, tag = "1")]
        Create(super::super::resources::AssetGroupSignal),
        /// Remove operation: A resource name for the removed asset group signal is
        /// expected, in this format:
        /// `customers/{customer_id}/assetGroupSignals/{asset_group_id}~{criterion_id}`
        #[prost(string, tag = "2")]
        Remove(::prost::alloc::string::String),
    }
}
/// Response message for an asset group signal mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAssetGroupSignalsResponse {
    /// All results for the mutate.
    #[prost(message, repeated, tag = "1")]
    pub results: ::prost::alloc::vec::Vec<MutateAssetGroupSignalResult>,
    /// Errors that pertain to operation failures in the partial failure mode.
    /// Returned only when partial_failure = true and all errors occur inside the
    /// operations. If any errors occur outside the operations (for example, auth
    /// errors), we return an RPC level error.
    #[prost(message, optional, tag = "2")]
    pub partial_failure_error: ::core::option::Option<
        super::super::super::super::rpc::Status,
    >,
}
/// The result for the asset group signal mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAssetGroupSignalResult {
    /// Returned for successful operations.
    #[prost(string, tag = "1")]
    pub resource_name: ::prost::alloc::string::String,
    /// The mutated AssetGroupSignal with only mutable fields after mutate. The
    /// field will only be returned when response_content_type is set to
    /// "MUTABLE_RESOURCE".
    #[prost(message, optional, tag = "2")]
    pub asset_group_signal: ::core::option::Option<super::resources::AssetGroupSignal>,
}
/// Generated server implementations.
pub mod asset_group_signal_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with AssetGroupSignalServiceServer.
    #[async_trait]
    pub trait AssetGroupSignalService: std::marker::Send + std::marker::Sync + 'static {
        /// Creates or removes asset group signals. Operation statuses are
        /// returned.
        async fn mutate_asset_group_signals(
            &self,
            request: tonic::Request<super::MutateAssetGroupSignalsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MutateAssetGroupSignalsResponse>,
            tonic::Status,
        >;
    }
    /// Service to manage asset group signal.
    #[derive(Debug)]
    pub struct AssetGroupSignalServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> AssetGroupSignalServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>>
    for AssetGroupSignalServiceServer<T>
    where
        T: AssetGroupSignalService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/google.ads.googleads.v16.services.AssetGroupSignalService/MutateAssetGroupSignals" => {
                    #[allow(non_camel_case_types)]
                    struct MutateAssetGroupSignalsSvc<T: AssetGroupSignalService>(
                        pub Arc<T>,
                    );
                    impl<
                        T: AssetGroupSignalService,
                    > tonic::server::UnaryService<super::MutateAssetGroupSignalsRequest>
                    for MutateAssetGroupSignalsSvc<T> {
                        type Response = super::MutateAssetGroupSignalsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::MutateAssetGroupSignalsRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as AssetGroupSignalService>::mutate_asset_group_signals(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = MutateAssetGroupSignalsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for AssetGroupSignalServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "google.ads.googleads.v16.services.AssetGroupSignalService";
    impl<T> tonic::server::NamedService for AssetGroupSignalServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Request message for
/// [AssetService.MutateAssets][google.ads.googleads.v16.services.AssetService.MutateAssets]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAssetsRequest {
    /// Required. The ID of the customer whose assets are being modified.
    #[prost(string, tag = "1")]
    pub customer_id: ::prost::alloc::string::String,
    /// Required. The list of operations to perform on individual assets.
    #[prost(message, repeated, tag = "2")]
    pub operations: ::prost::alloc::vec::Vec<AssetOperation>,
    /// If true, successful operations will be carried out and invalid
    /// operations will return errors. If false, all operations will be carried
    /// out in one transaction if and only if they are all valid.
    /// Default is false.
    #[prost(bool, tag = "5")]
    pub partial_failure: bool,
    /// The response content type setting. Determines whether the mutable resource
    /// or just the resource name should be returned post mutation.
    #[prost(
        enumeration = "super::enums::response_content_type_enum::ResponseContentType",
        tag = "3"
    )]
    pub response_content_type: i32,
    /// If true, the request is validated but not executed. Only errors are
    /// returned, not results.
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
}
/// A single operation to create an asset. Supported asset types are
/// YoutubeVideoAsset, MediaBundleAsset, ImageAsset, LeadFormAsset,
/// LocationAsset, and ImageAsset. TextAsset can be created with an Ad inline,
/// but it can also be created apart from an Ad like other assets.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AssetOperation {
    /// FieldMask that determines which resource fields are modified in an update.
    #[prost(message, optional, tag = "3")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// The mutate operation.
    #[prost(oneof = "asset_operation::Operation", tags = "1, 2")]
    pub operation: ::core::option::Option<asset_operation::Operation>,
}
/// Nested message and enum types in `AssetOperation`.
pub mod asset_operation {
    /// The mutate operation.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Operation {
        /// Create operation: No resource name is expected for the new asset.
        #[prost(message, tag = "1")]
        Create(super::super::resources::Asset),
        /// Update operation: The asset is expected to have a valid resource name in
        /// this format:
        ///
        /// `customers/{customer_id}/assets/{asset_id}`
        #[prost(message, tag = "2")]
        Update(super::super::resources::Asset),
    }
}
/// Response message for an asset mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAssetsResponse {
    /// Errors that pertain to operation failures in the partial failure mode.
    /// Returned only when partial_failure = true and all errors occur inside the
    /// operations. If any errors occur outside the operations (for example, auth
    /// errors), we return an RPC level error.
    #[prost(message, optional, tag = "3")]
    pub partial_failure_error: ::core::option::Option<
        super::super::super::super::rpc::Status,
    >,
    /// All results for the mutate.
    #[prost(message, repeated, tag = "2")]
    pub results: ::prost::alloc::vec::Vec<MutateAssetResult>,
}
/// The result for the asset mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAssetResult {
    /// The resource name returned for successful operations.
    #[prost(string, tag = "1")]
    pub resource_name: ::prost::alloc::string::String,
    /// The mutated asset with only mutable fields after mutate. The field will
    /// only be returned when response_content_type is set to "MUTABLE_RESOURCE".
    #[prost(message, optional, tag = "2")]
    pub asset: ::core::option::Option<super::resources::Asset>,
}
/// Generated server implementations.
pub mod asset_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with AssetServiceServer.
    #[async_trait]
    pub trait AssetService: std::marker::Send + std::marker::Sync + 'static {
        /// Creates assets. Operation statuses are returned.
        ///
        /// List of thrown errors:
        ///   [AssetError]()
        ///   [AuthenticationError]()
        ///   [AuthorizationError]()
        ///   [CollectionSizeError]()
        ///   [CurrencyCodeError]()
        ///   [DatabaseError]()
        ///   [DateError]()
        ///   [DistinctError]()
        ///   [FieldError]()
        ///   [FieldMaskError]()
        ///   [HeaderError]()
        ///   [IdError]()
        ///   [InternalError]()
        ///   [ListOperationError]()
        ///   [MediaUploadError]()
        ///   [MutateError]()
        ///   [NotAllowlistedError]()
        ///   [NotEmptyError]()
        ///   [OperatorError]()
        ///   [QuotaError]()
        ///   [RangeError]()
        ///   [RequestError]()
        ///   [SizeLimitError]()
        ///   [StringFormatError]()
        ///   [StringLengthError]()
        ///   [UrlFieldError]()
        ///   [YoutubeVideoRegistrationError]()
        async fn mutate_assets(
            &self,
            request: tonic::Request<super::MutateAssetsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MutateAssetsResponse>,
            tonic::Status,
        >;
    }
    /// Service to manage assets. Asset types can be created with AssetService are
    /// YoutubeVideoAsset, MediaBundleAsset and ImageAsset. TextAsset should be
    /// created with Ad inline.
    #[derive(Debug)]
    pub struct AssetServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> AssetServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for AssetServiceServer<T>
    where
        T: AssetService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/google.ads.googleads.v16.services.AssetService/MutateAssets" => {
                    #[allow(non_camel_case_types)]
                    struct MutateAssetsSvc<T: AssetService>(pub Arc<T>);
                    impl<
                        T: AssetService,
                    > tonic::server::UnaryService<super::MutateAssetsRequest>
                    for MutateAssetsSvc<T> {
                        type Response = super::MutateAssetsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::MutateAssetsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as AssetService>::mutate_assets(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = MutateAssetsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for AssetServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "google.ads.googleads.v16.services.AssetService";
    impl<T> tonic::server::NamedService for AssetServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Request message for
/// [AssetSetAssetService.MutateAssetSetAssets][google.ads.googleads.v16.services.AssetSetAssetService.MutateAssetSetAssets].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAssetSetAssetsRequest {
    /// Required. The ID of the customer whose asset set assets are being modified.
    #[prost(string, tag = "1")]
    pub customer_id: ::prost::alloc::string::String,
    /// Required. The list of operations to perform on individual asset set assets.
    #[prost(message, repeated, tag = "2")]
    pub operations: ::prost::alloc::vec::Vec<AssetSetAssetOperation>,
    /// If true, successful operations will be carried out and invalid
    /// operations will return errors. If false, all operations will be carried
    /// out in one transaction if and only if they are all valid.
    /// Default is false.
    #[prost(bool, tag = "3")]
    pub partial_failure: bool,
    /// If true, the request is validated but not executed. Only errors are
    /// returned, not results.
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
    /// The response content type setting. Determines whether the mutable resource
    /// or just the resource name should be returned post mutation.
    #[prost(
        enumeration = "super::enums::response_content_type_enum::ResponseContentType",
        tag = "5"
    )]
    pub response_content_type: i32,
}
/// A single operation (create, remove) on an asset set asset.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AssetSetAssetOperation {
    /// The mutate operation.
    #[prost(oneof = "asset_set_asset_operation::Operation", tags = "1, 2")]
    pub operation: ::core::option::Option<asset_set_asset_operation::Operation>,
}
/// Nested message and enum types in `AssetSetAssetOperation`.
pub mod asset_set_asset_operation {
    /// The mutate operation.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Operation {
        /// Create operation: No resource name is expected for the new asset set
        /// asset
        #[prost(message, tag = "1")]
        Create(super::super::resources::AssetSetAsset),
        /// Remove operation: A resource name for the removed asset set asset is
        /// expected, in this format:
        /// `customers/{customer_id}/assetSetAssets/{asset_set_id}~{asset_id}`
        #[prost(string, tag = "2")]
        Remove(::prost::alloc::string::String),
    }
}
/// Response message for an asset set asset mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAssetSetAssetsResponse {
    /// All results for the mutate.
    #[prost(message, repeated, tag = "1")]
    pub results: ::prost::alloc::vec::Vec<MutateAssetSetAssetResult>,
    /// Errors that pertain to operation failures in the partial failure mode.
    /// Returned only when partial_failure = true and all errors occur inside the
    /// operations. If any errors occur outside the operations (for example, auth
    /// errors), we return an RPC level error.
    #[prost(message, optional, tag = "2")]
    pub partial_failure_error: ::core::option::Option<
        super::super::super::super::rpc::Status,
    >,
}
/// The result for the asset set asset mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAssetSetAssetResult {
    /// Returned for successful operations.
    #[prost(string, tag = "1")]
    pub resource_name: ::prost::alloc::string::String,
    /// The mutated asset set asset with only mutable fields after mutate. The
    /// field will only be returned when response_content_type is set to
    /// "MUTABLE_RESOURCE".
    #[prost(message, optional, tag = "2")]
    pub asset_set_asset: ::core::option::Option<super::resources::AssetSetAsset>,
}
/// Generated server implementations.
pub mod asset_set_asset_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with AssetSetAssetServiceServer.
    #[async_trait]
    pub trait AssetSetAssetService: std::marker::Send + std::marker::Sync + 'static {
        /// Creates, updates or removes asset set assets. Operation statuses are
        /// returned.
        async fn mutate_asset_set_assets(
            &self,
            request: tonic::Request<super::MutateAssetSetAssetsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MutateAssetSetAssetsResponse>,
            tonic::Status,
        >;
    }
    /// Service to manage asset set asset.
    #[derive(Debug)]
    pub struct AssetSetAssetServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> AssetSetAssetServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>>
    for AssetSetAssetServiceServer<T>
    where
        T: AssetSetAssetService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/google.ads.googleads.v16.services.AssetSetAssetService/MutateAssetSetAssets" => {
                    #[allow(non_camel_case_types)]
                    struct MutateAssetSetAssetsSvc<T: AssetSetAssetService>(pub Arc<T>);
                    impl<
                        T: AssetSetAssetService,
                    > tonic::server::UnaryService<super::MutateAssetSetAssetsRequest>
                    for MutateAssetSetAssetsSvc<T> {
                        type Response = super::MutateAssetSetAssetsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::MutateAssetSetAssetsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as AssetSetAssetService>::mutate_asset_set_assets(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = MutateAssetSetAssetsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for AssetSetAssetServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "google.ads.googleads.v16.services.AssetSetAssetService";
    impl<T> tonic::server::NamedService for AssetSetAssetServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Request message for
/// [AssetSetService.MutateAssetSets][google.ads.googleads.v16.services.AssetSetService.MutateAssetSets].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAssetSetsRequest {
    /// Required. The ID of the customer whose asset sets are being modified.
    #[prost(string, tag = "1")]
    pub customer_id: ::prost::alloc::string::String,
    /// Required. The list of operations to perform on individual asset sets.
    #[prost(message, repeated, tag = "2")]
    pub operations: ::prost::alloc::vec::Vec<AssetSetOperation>,
    /// If true, successful operations will be carried out and invalid
    /// operations will return errors. If false, all operations will be carried
    /// out in one transaction if and only if they are all valid.
    /// Default is false.
    #[prost(bool, tag = "3")]
    pub partial_failure: bool,
    /// If true, the request is validated but not executed. Only errors are
    /// returned, not results.
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
    /// The response content type setting. Determines whether the mutable resource
    /// or just the resource name should be returned post mutation.
    #[prost(
        enumeration = "super::enums::response_content_type_enum::ResponseContentType",
        tag = "5"
    )]
    pub response_content_type: i32,
}
/// A single operation (create, remove) on an asset set.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AssetSetOperation {
    /// FieldMask that determines which resource fields are modified in an update.
    #[prost(message, optional, tag = "4")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// The mutate operation.
    #[prost(oneof = "asset_set_operation::Operation", tags = "1, 2, 3")]
    pub operation: ::core::option::Option<asset_set_operation::Operation>,
}
/// Nested message and enum types in `AssetSetOperation`.
pub mod asset_set_operation {
    /// The mutate operation.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Operation {
        /// Create operation: No resource name is expected for the new asset set
        #[prost(message, tag = "1")]
        Create(super::super::resources::AssetSet),
        /// Update operation: The asset set is expected to have a valid resource
        /// name.
        #[prost(message, tag = "2")]
        Update(super::super::resources::AssetSet),
        /// Remove operation: A resource name for the removed asset set is
        /// expected, in this format:
        /// `customers/{customer_id}/assetSets/{asset_set_id}`
        #[prost(string, tag = "3")]
        Remove(::prost::alloc::string::String),
    }
}
/// Response message for an asset set mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAssetSetsResponse {
    /// All results for the mutate.
    #[prost(message, repeated, tag = "1")]
    pub results: ::prost::alloc::vec::Vec<MutateAssetSetResult>,
    /// Errors that pertain to operation failures in the partial failure mode.
    /// Returned only when partial_failure = true and all errors occur inside the
    /// operations. If any errors occur outside the operations (for example, auth
    /// errors), we return an RPC level error.
    #[prost(message, optional, tag = "2")]
    pub partial_failure_error: ::core::option::Option<
        super::super::super::super::rpc::Status,
    >,
}
/// The result for the asset set mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAssetSetResult {
    /// Returned for successful operations.
    #[prost(string, tag = "1")]
    pub resource_name: ::prost::alloc::string::String,
    /// The mutated asset set with only mutable fields after mutate. The field will
    /// only be returned when response_content_type is set to "MUTABLE_RESOURCE".
    #[prost(message, optional, tag = "2")]
    pub asset_set: ::core::option::Option<super::resources::AssetSet>,
}
/// Generated server implementations.
pub mod asset_set_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with AssetSetServiceServer.
    #[async_trait]
    pub trait AssetSetService: std::marker::Send + std::marker::Sync + 'static {
        /// Creates, updates or removes asset sets. Operation statuses are
        /// returned.
        async fn mutate_asset_sets(
            &self,
            request: tonic::Request<super::MutateAssetSetsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MutateAssetSetsResponse>,
            tonic::Status,
        >;
    }
    /// Service to manage asset set
    #[derive(Debug)]
    pub struct AssetSetServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> AssetSetServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for AssetSetServiceServer<T>
    where
        T: AssetSetService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/google.ads.googleads.v16.services.AssetSetService/MutateAssetSets" => {
                    #[allow(non_camel_case_types)]
                    struct MutateAssetSetsSvc<T: AssetSetService>(pub Arc<T>);
                    impl<
                        T: AssetSetService,
                    > tonic::server::UnaryService<super::MutateAssetSetsRequest>
                    for MutateAssetSetsSvc<T> {
                        type Response = super::MutateAssetSetsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::MutateAssetSetsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as AssetSetService>::mutate_asset_sets(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = MutateAssetSetsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for AssetSetServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "google.ads.googleads.v16.services.AssetSetService";
    impl<T> tonic::server::NamedService for AssetSetServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Request message for
/// [AudienceInsightsService.GenerateInsightsFinderReport][google.ads.googleads.v16.services.AudienceInsightsService.GenerateInsightsFinderReport].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenerateInsightsFinderReportRequest {
    /// Required. The ID of the customer.
    #[prost(string, tag = "1")]
    pub customer_id: ::prost::alloc::string::String,
    /// Required. A baseline audience for this report, typically all people in a
    /// region.
    #[prost(message, optional, tag = "2")]
    pub baseline_audience: ::core::option::Option<BasicInsightsAudience>,
    /// Required. The specific audience of interest for this report.  The insights
    /// in the report will be based on attributes more prevalent in this audience
    /// than in the report's baseline audience.
    #[prost(message, optional, tag = "3")]
    pub specific_audience: ::core::option::Option<BasicInsightsAudience>,
    /// The name of the customer being planned for.  This is a user-defined value.
    #[prost(string, tag = "4")]
    pub customer_insights_group: ::prost::alloc::string::String,
}
/// The response message for
/// [AudienceInsightsService.GenerateInsightsFinderReport][google.ads.googleads.v16.services.AudienceInsightsService.GenerateInsightsFinderReport],
/// containing the shareable URL for the report.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenerateInsightsFinderReportResponse {
    /// An HTTPS URL providing a deep link into the Insights Finder UI with the
    /// report inputs filled in according to the request.
    #[prost(string, tag = "1")]
    pub saved_report_url: ::prost::alloc::string::String,
}
/// Request message for
/// [AudienceInsightsService.GenerateAudienceCompositionInsights][google.ads.googleads.v16.services.AudienceInsightsService.GenerateAudienceCompositionInsights].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenerateAudienceCompositionInsightsRequest {
    /// Required. The ID of the customer.
    #[prost(string, tag = "1")]
    pub customer_id: ::prost::alloc::string::String,
    /// Required. The audience of interest for which insights are being requested.
    #[prost(message, optional, tag = "2")]
    pub audience: ::core::option::Option<InsightsAudience>,
    /// The baseline audience to which the audience of interest is being
    /// compared.
    #[prost(message, optional, tag = "6")]
    pub baseline_audience: ::core::option::Option<InsightsAudience>,
    /// The one-month range of historical data to use for insights, in the format
    /// "yyyy-mm". If unset, insights will be returned for the last thirty days of
    /// data.
    #[prost(string, tag = "3")]
    pub data_month: ::prost::alloc::string::String,
    /// Required. The audience dimensions for which composition insights should be
    /// returned.
    #[prost(
        enumeration = "super::enums::audience_insights_dimension_enum::AudienceInsightsDimension",
        repeated,
        packed = "false",
        tag = "4"
    )]
    pub dimensions: ::prost::alloc::vec::Vec<i32>,
    /// The name of the customer being planned for.  This is a user-defined value.
    #[prost(string, tag = "5")]
    pub customer_insights_group: ::prost::alloc::string::String,
}
/// Response message for
/// [AudienceInsightsService.GenerateAudienceCompositionInsights][google.ads.googleads.v16.services.AudienceInsightsService.GenerateAudienceCompositionInsights].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenerateAudienceCompositionInsightsResponse {
    /// The contents of the insights report, organized into sections.
    /// Each section is associated with one of the AudienceInsightsDimension values
    /// in the request. There may be more than one section per dimension.
    #[prost(message, repeated, tag = "1")]
    pub sections: ::prost::alloc::vec::Vec<AudienceCompositionSection>,
}
/// Request message for
/// [AudienceInsightsService.GenerateSuggestedTargetingInsights][google.ads.googleads.v16.services.AudienceInsightsService.GenerateSuggestedTargetingInsights].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenerateSuggestedTargetingInsightsRequest {
    /// Required. The ID of the customer.
    #[prost(string, tag = "1")]
    pub customer_id: ::prost::alloc::string::String,
    /// Required. The audience of interest for which insights are being requested.
    #[prost(message, optional, tag = "2")]
    pub audience: ::core::option::Option<InsightsAudience>,
    /// Optional. The baseline audience.  The default, if unspecified, is all
    /// people in the same country as the audience of interest.
    #[prost(message, optional, tag = "3")]
    pub baseline_audience: ::core::option::Option<InsightsAudience>,
    /// Optional. The one-month range of historical data to use for insights, in
    /// the format "yyyy-mm". If unset, insights will be returned for the last
    /// thirty days of data.
    #[prost(string, tag = "4")]
    pub data_month: ::prost::alloc::string::String,
    /// Optional. The name of the customer being planned for.  This is a
    /// user-defined value.
    #[prost(string, tag = "5")]
    pub customer_insights_group: ::prost::alloc::string::String,
}
/// Response message for
/// [AudienceInsightsService.GenerateSuggestedTargetingInsights][google.ads.googleads.v16.services.AudienceInsightsService.GenerateSuggestedTargetingInsights].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenerateSuggestedTargetingInsightsResponse {
    /// Suggested insights for targetable audiences.
    #[prost(message, repeated, tag = "1")]
    pub suggestions: ::prost::alloc::vec::Vec<TargetingSuggestionMetrics>,
}
/// A suggested targetable audience relevant to the requested audience.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TargetingSuggestionMetrics {
    /// Suggested location targeting.  These attributes all have dimension
    /// GEO_TARGET_COUNTRY or SUB_COUNTRY_LOCATION
    #[prost(message, repeated, tag = "1")]
    pub locations: ::prost::alloc::vec::Vec<AudienceInsightsAttributeMetadata>,
    /// Suggested age targeting; may be empty indicating no age targeting.
    #[prost(message, repeated, tag = "2")]
    pub age_ranges: ::prost::alloc::vec::Vec<super::common::AgeRangeInfo>,
    /// Suggested gender targeting.  If present, this attribute has dimension
    /// GENDER.
    #[prost(message, optional, tag = "3")]
    pub gender: ::core::option::Option<super::common::GenderInfo>,
    /// Suggested audience segments to target.  These attributes all have dimension
    /// AFFINITY_USER_INTEREST or IN_MARKET_USER_INTEREST
    #[prost(message, repeated, tag = "4")]
    pub user_interests: ::prost::alloc::vec::Vec<AudienceInsightsAttributeMetadata>,
    /// The fraction (from 0 to 1 inclusive) of the requested audience that can be
    /// reached using the suggested targeting.
    #[prost(double, tag = "5")]
    pub coverage: f64,
    /// The ratio of coverage to the coverage of the baseline audience or zero if
    /// this ratio is undefined or is not meaningful.
    #[prost(double, tag = "6")]
    pub index: f64,
    /// The approximate estimated number of people that can be reached on YouTube
    /// using this targeting.
    #[prost(int64, tag = "7")]
    pub potential_youtube_reach: i64,
}
/// Request message for
/// [AudienceInsightsService.ListAudienceInsightsAttributes][google.ads.googleads.v16.services.AudienceInsightsService.ListAudienceInsightsAttributes].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListAudienceInsightsAttributesRequest {
    /// Required. The ID of the customer.
    #[prost(string, tag = "1")]
    pub customer_id: ::prost::alloc::string::String,
    /// Required. The types of attributes to be returned.
    #[prost(
        enumeration = "super::enums::audience_insights_dimension_enum::AudienceInsightsDimension",
        repeated,
        packed = "false",
        tag = "2"
    )]
    pub dimensions: ::prost::alloc::vec::Vec<i32>,
    /// Required. A free text query.  If the requested dimensions include
    /// Attributes CATEGORY or KNOWLEDGE_GRAPH, then the attributes returned for
    /// those dimensions will match or be related to this string.  For other
    /// dimensions, this field is ignored and all available attributes are
    /// returned.
    #[prost(string, tag = "3")]
    pub query_text: ::prost::alloc::string::String,
    /// The name of the customer being planned for.  This is a user-defined value.
    #[prost(string, tag = "4")]
    pub customer_insights_group: ::prost::alloc::string::String,
    /// If SUB_COUNTRY_LOCATION attributes are one of the requested dimensions and
    /// this field is present, then the SUB_COUNTRY_LOCATION attributes returned
    /// will be located in these countries. If this field is absent, then location
    /// attributes are not filtered by country. Setting this field when
    /// SUB_COUNTRY_LOCATION attributes are not requested will return an error.
    #[prost(message, repeated, tag = "5")]
    pub location_country_filters: ::prost::alloc::vec::Vec<super::common::LocationInfo>,
}
/// Response message for
/// [AudienceInsightsService.ListAudienceInsightsAttributes][google.ads.googleads.v16.services.AudienceInsightsService.ListAudienceInsightsAttributes].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListAudienceInsightsAttributesResponse {
    /// The attributes matching the search query.
    #[prost(message, repeated, tag = "1")]
    pub attributes: ::prost::alloc::vec::Vec<AudienceInsightsAttributeMetadata>,
}
/// Request message for
/// [AudienceInsightsService.ListInsightsEligibleDates][google.ads.googleads.v16.services.AudienceInsightsService.ListInsightsEligibleDates].
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ListInsightsEligibleDatesRequest {}
/// Response message for
/// [AudienceInsightsService.ListInsightsEligibleDates][google.ads.googleads.v16.services.AudienceInsightsService.ListInsightsEligibleDates].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListInsightsEligibleDatesResponse {
    /// The months for which AudienceInsights data is currently
    /// available, each represented as a string in the form "YYYY-MM".
    #[prost(string, repeated, tag = "1")]
    pub data_months: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// The actual dates covered by the "last 30 days" date range that will be used
    /// implicitly for
    /// [AudienceInsightsService.GenerateAudienceCompositionInsights][google.ads.googleads.v16.services.AudienceInsightsService.GenerateAudienceCompositionInsights]
    /// requests that have no data_month set.
    #[prost(message, optional, tag = "2")]
    pub last_thirty_days: ::core::option::Option<super::common::DateRange>,
}
/// An audience attribute that can be used to request insights about the
/// audience.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AudienceInsightsAttribute {
    /// An audience attribute.
    #[prost(
        oneof = "audience_insights_attribute::Attribute",
        tags = "1, 2, 3, 4, 5, 6, 7, 8, 9, 10"
    )]
    pub attribute: ::core::option::Option<audience_insights_attribute::Attribute>,
}
/// Nested message and enum types in `AudienceInsightsAttribute`.
pub mod audience_insights_attribute {
    /// An audience attribute.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Attribute {
        /// An audience attribute defined by an age range.
        #[prost(message, tag = "1")]
        AgeRange(super::super::common::AgeRangeInfo),
        /// An audience attribute defined by a gender.
        #[prost(message, tag = "2")]
        Gender(super::super::common::GenderInfo),
        /// An audience attribute defined by a geographic location.
        #[prost(message, tag = "3")]
        Location(super::super::common::LocationInfo),
        /// An Affinity or In-Market audience.
        #[prost(message, tag = "4")]
        UserInterest(super::super::common::UserInterestInfo),
        /// An audience attribute defined by interest in a topic represented by a
        /// Knowledge Graph entity.
        #[prost(message, tag = "5")]
        Entity(super::AudienceInsightsEntity),
        /// An audience attribute defined by interest in a Product & Service
        /// category.
        #[prost(message, tag = "6")]
        Category(super::AudienceInsightsCategory),
        /// A YouTube Dynamic Lineup
        #[prost(message, tag = "7")]
        DynamicLineup(super::AudienceInsightsDynamicLineup),
        /// A Parental Status value (parent, or not a parent).
        #[prost(message, tag = "8")]
        ParentalStatus(super::super::common::ParentalStatusInfo),
        /// A household income percentile range.
        #[prost(message, tag = "9")]
        IncomeRange(super::super::common::IncomeRangeInfo),
        /// A YouTube channel.
        #[prost(message, tag = "10")]
        YoutubeChannel(super::super::common::YouTubeChannelInfo),
    }
}
/// An entity or category representing a topic that defines an audience.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AudienceInsightsTopic {
    /// An entity or category attribute.
    #[prost(oneof = "audience_insights_topic::Topic", tags = "1, 2")]
    pub topic: ::core::option::Option<audience_insights_topic::Topic>,
}
/// Nested message and enum types in `AudienceInsightsTopic`.
pub mod audience_insights_topic {
    /// An entity or category attribute.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Topic {
        /// A Knowledge Graph entity
        #[prost(message, tag = "1")]
        Entity(super::AudienceInsightsEntity),
        /// A Product & Service category
        #[prost(message, tag = "2")]
        Category(super::AudienceInsightsCategory),
    }
}
/// A Knowledge Graph entity, represented by its machine id.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AudienceInsightsEntity {
    /// Required. The machine id (mid) of the Knowledge Graph entity.
    #[prost(string, tag = "1")]
    pub knowledge_graph_machine_id: ::prost::alloc::string::String,
}
/// A Product and Service category.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AudienceInsightsCategory {
    /// Required. The criterion id of the category.
    #[prost(string, tag = "1")]
    pub category_id: ::prost::alloc::string::String,
}
/// A YouTube Dynamic Lineup.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AudienceInsightsDynamicLineup {
    /// Required. The numeric ID of the dynamic lineup.
    #[prost(string, tag = "1")]
    pub dynamic_lineup_id: ::prost::alloc::string::String,
}
/// A description of an audience used for requesting insights.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BasicInsightsAudience {
    /// Required. The countries for this audience.
    #[prost(message, repeated, tag = "1")]
    pub country_location: ::prost::alloc::vec::Vec<super::common::LocationInfo>,
    /// Sub-country geographic location attributes.  If present, each of these
    /// must be contained in one of the countries in this audience.
    #[prost(message, repeated, tag = "2")]
    pub sub_country_locations: ::prost::alloc::vec::Vec<super::common::LocationInfo>,
    /// Gender for the audience.  If absent, the audience does not restrict by
    /// gender.
    #[prost(message, optional, tag = "3")]
    pub gender: ::core::option::Option<super::common::GenderInfo>,
    /// Age ranges for the audience.  If absent, the audience represents all people
    /// over 18 that match the other attributes.
    #[prost(message, repeated, tag = "4")]
    pub age_ranges: ::prost::alloc::vec::Vec<super::common::AgeRangeInfo>,
    /// User interests defining this audience.  Affinity and In-Market audiences
    /// are supported.
    #[prost(message, repeated, tag = "5")]
    pub user_interests: ::prost::alloc::vec::Vec<super::common::UserInterestInfo>,
    /// Topics, represented by Knowledge Graph entities and/or Product & Service
    /// categories, that this audience is interested in.
    #[prost(message, repeated, tag = "6")]
    pub topics: ::prost::alloc::vec::Vec<AudienceInsightsTopic>,
}
/// An audience attribute, with metadata about it, returned in response to a
/// search.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AudienceInsightsAttributeMetadata {
    /// The type of the attribute.
    #[prost(
        enumeration = "super::enums::audience_insights_dimension_enum::AudienceInsightsDimension",
        tag = "1"
    )]
    pub dimension: i32,
    /// The attribute itself.
    #[prost(message, optional, tag = "2")]
    pub attribute: ::core::option::Option<AudienceInsightsAttribute>,
    /// The human-readable name of the attribute.
    #[prost(string, tag = "3")]
    pub display_name: ::prost::alloc::string::String,
    /// A string that supplements the display_name to identify the attribute.
    /// If the dimension is TOPIC, this is a brief description of the
    /// Knowledge Graph entity, such as "American singer-songwriter".
    /// If the dimension is CATEGORY, this is the complete path to the category in
    /// The Product & Service taxonomy, for example
    /// "/Apparel/Clothing/Outerwear".
    #[prost(string, tag = "5")]
    pub display_info: ::prost::alloc::string::String,
    /// Metadata specific to the dimension of this attribute.
    #[prost(
        oneof = "audience_insights_attribute_metadata::DimensionMetadata",
        tags = "6, 7, 8"
    )]
    pub dimension_metadata: ::core::option::Option<
        audience_insights_attribute_metadata::DimensionMetadata,
    >,
}
/// Nested message and enum types in `AudienceInsightsAttributeMetadata`.
pub mod audience_insights_attribute_metadata {
    /// Metadata specific to the dimension of this attribute.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum DimensionMetadata {
        /// Special metadata for a YouTube channel.
        #[prost(message, tag = "6")]
        YoutubeChannelMetadata(super::YouTubeChannelAttributeMetadata),
        /// Special metadata for a YouTube Dynamic Lineup.
        #[prost(message, tag = "7")]
        DynamicAttributeMetadata(super::DynamicLineupAttributeMetadata),
        /// Special metadata for a Location.
        #[prost(message, tag = "8")]
        LocationAttributeMetadata(super::LocationAttributeMetadata),
    }
}
/// Metadata associated with a YouTube channel attribute.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct YouTubeChannelAttributeMetadata {
    /// The approximate number of subscribers to the YouTube channel.
    #[prost(int64, tag = "1")]
    pub subscriber_count: i64,
}
/// Metadata associated with a Dynamic Lineup attribute.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DynamicLineupAttributeMetadata {
    /// The national market associated with the lineup.
    #[prost(message, optional, tag = "1")]
    pub inventory_country: ::core::option::Option<super::common::LocationInfo>,
    /// The median number of impressions per month on this lineup.
    #[prost(int64, optional, tag = "2")]
    pub median_monthly_inventory: ::core::option::Option<i64>,
    /// The lower end of a range containing the number of channels in the lineup.
    #[prost(int64, optional, tag = "3")]
    pub channel_count_lower_bound: ::core::option::Option<i64>,
    /// The upper end of a range containing the number of channels in the lineup.
    #[prost(int64, optional, tag = "4")]
    pub channel_count_upper_bound: ::core::option::Option<i64>,
    /// Examples of channels that are included in the lineup.
    #[prost(message, repeated, tag = "5")]
    pub sample_channels: ::prost::alloc::vec::Vec<
        dynamic_lineup_attribute_metadata::SampleChannel,
    >,
}
/// Nested message and enum types in `DynamicLineupAttributeMetadata`.
pub mod dynamic_lineup_attribute_metadata {
    /// A YouTube channel returned as an example of the content in a lineup.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SampleChannel {
        /// A YouTube channel.
        #[prost(message, optional, tag = "1")]
        pub youtube_channel: ::core::option::Option<
            super::super::common::YouTubeChannelInfo,
        >,
        /// The name of the sample channel.
        #[prost(string, tag = "2")]
        pub display_name: ::prost::alloc::string::String,
        /// Metadata for the sample channel.
        #[prost(message, optional, tag = "3")]
        pub youtube_channel_metadata: ::core::option::Option<
            super::YouTubeChannelAttributeMetadata,
        >,
    }
}
/// Metadata associated with a Location attribute.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LocationAttributeMetadata {
    /// The country location of the sub country location.
    #[prost(message, optional, tag = "1")]
    pub country_location: ::core::option::Option<super::common::LocationInfo>,
}
/// A set of users, defined by various characteristics, for which insights can
/// be requested in AudienceInsightsService.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InsightsAudience {
    /// Required. The countries for the audience.
    #[prost(message, repeated, tag = "1")]
    pub country_locations: ::prost::alloc::vec::Vec<super::common::LocationInfo>,
    /// Sub-country geographic location attributes.  If present, each of these
    /// must be contained in one of the countries in this audience.  If absent, the
    /// audience is geographically to the country_locations and no further.
    #[prost(message, repeated, tag = "2")]
    pub sub_country_locations: ::prost::alloc::vec::Vec<super::common::LocationInfo>,
    /// Gender for the audience.  If absent, the audience does not restrict by
    /// gender.
    #[prost(message, optional, tag = "3")]
    pub gender: ::core::option::Option<super::common::GenderInfo>,
    /// Age ranges for the audience.  If absent, the audience represents all people
    /// over 18 that match the other attributes.
    #[prost(message, repeated, tag = "4")]
    pub age_ranges: ::prost::alloc::vec::Vec<super::common::AgeRangeInfo>,
    /// Parental status for the audience.  If absent, the audience does not
    /// restrict by parental status.
    #[prost(message, optional, tag = "5")]
    pub parental_status: ::core::option::Option<super::common::ParentalStatusInfo>,
    /// Household income percentile ranges for the audience.  If absent, the
    /// audience does not restrict by household income range.
    #[prost(message, repeated, tag = "6")]
    pub income_ranges: ::prost::alloc::vec::Vec<super::common::IncomeRangeInfo>,
    /// Dynamic lineups representing the YouTube content viewed by the audience.
    #[prost(message, repeated, tag = "7")]
    pub dynamic_lineups: ::prost::alloc::vec::Vec<AudienceInsightsDynamicLineup>,
    /// A combination of entity, category and user interest attributes defining the
    /// audience. The combination has a logical AND-of-ORs structure: Attributes
    /// within each InsightsAudienceAttributeGroup are combined with OR, and
    /// the combinations themselves are combined together with AND.  For example,
    /// the expression (Entity OR Affinity) AND (In-Market OR Category) can be
    /// formed using two InsightsAudienceAttributeGroups with two Attributes
    /// each.
    #[prost(message, repeated, tag = "8")]
    pub topic_audience_combinations: ::prost::alloc::vec::Vec<
        InsightsAudienceAttributeGroup,
    >,
}
/// A list of AudienceInsightsAttributes.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InsightsAudienceAttributeGroup {
    /// Required. A collection of audience attributes to be combined with logical
    /// OR. Attributes need not all be the same dimension.  Only Knowledge Graph
    /// entities, Product & Service Categories, and Affinity and In-Market
    /// audiences are supported in this context.
    #[prost(message, repeated, tag = "1")]
    pub attributes: ::prost::alloc::vec::Vec<AudienceInsightsAttribute>,
}
/// A collection of related attributes of the same type in an audience
/// composition insights report.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AudienceCompositionSection {
    /// The type of the attributes in this section.
    #[prost(
        enumeration = "super::enums::audience_insights_dimension_enum::AudienceInsightsDimension",
        tag = "1"
    )]
    pub dimension: i32,
    /// The most relevant segments for this audience.  If dimension is GENDER,
    /// AGE_RANGE or PARENTAL_STATUS, then this list of attributes is exhaustive.
    #[prost(message, repeated, tag = "3")]
    pub top_attributes: ::prost::alloc::vec::Vec<AudienceCompositionAttribute>,
    /// Additional attributes for this audience, grouped into clusters.  Only
    /// populated if dimension is YOUTUBE_CHANNEL.
    #[prost(message, repeated, tag = "4")]
    pub clustered_attributes: ::prost::alloc::vec::Vec<
        AudienceCompositionAttributeCluster,
    >,
}
/// A collection of related attributes, with metadata and metrics, in an audience
/// composition insights report.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AudienceCompositionAttributeCluster {
    /// The name of this cluster of attributes
    #[prost(string, tag = "1")]
    pub cluster_display_name: ::prost::alloc::string::String,
    /// If the dimension associated with this cluster is YOUTUBE_CHANNEL, then
    /// cluster_metrics are metrics associated with the cluster as a whole.
    /// For other dimensions, this field is unset.
    #[prost(message, optional, tag = "3")]
    pub cluster_metrics: ::core::option::Option<AudienceCompositionMetrics>,
    /// The individual attributes that make up this cluster, with metadata and
    /// metrics.
    #[prost(message, repeated, tag = "4")]
    pub attributes: ::prost::alloc::vec::Vec<AudienceCompositionAttribute>,
}
/// The share and index metrics associated with an attribute in an audience
/// composition insights report.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AudienceCompositionMetrics {
    /// The fraction (from 0 to 1 inclusive) of the baseline audience that match
    /// the attribute.
    #[prost(double, tag = "1")]
    pub baseline_audience_share: f64,
    /// The fraction (from 0 to 1 inclusive) of the specific audience that match
    /// the attribute.
    #[prost(double, tag = "2")]
    pub audience_share: f64,
    /// The ratio of audience_share to baseline_audience_share, or zero if this
    /// ratio is undefined or is not meaningful.
    #[prost(double, tag = "3")]
    pub index: f64,
    /// A relevance score from 0 to 1 inclusive.
    #[prost(double, tag = "4")]
    pub score: f64,
}
/// An audience attribute with metadata and metrics.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AudienceCompositionAttribute {
    /// The attribute with its metadata.
    #[prost(message, optional, tag = "1")]
    pub attribute_metadata: ::core::option::Option<AudienceInsightsAttributeMetadata>,
    /// Share and index metrics for the attribute.
    #[prost(message, optional, tag = "2")]
    pub metrics: ::core::option::Option<AudienceCompositionMetrics>,
}
/// Generated server implementations.
pub mod audience_insights_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with AudienceInsightsServiceServer.
    #[async_trait]
    pub trait AudienceInsightsService: std::marker::Send + std::marker::Sync + 'static {
        /// Creates a saved report that can be viewed in the Insights Finder tool.
        ///
        /// List of thrown errors:
        ///   [AuthenticationError]()
        ///   [AuthorizationError]()
        ///   [FieldError]()
        ///   [HeaderError]()
        ///   [InternalError]()
        ///   [QuotaError]()
        ///   [RangeError]()
        ///   [RequestError]()
        async fn generate_insights_finder_report(
            &self,
            request: tonic::Request<super::GenerateInsightsFinderReportRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GenerateInsightsFinderReportResponse>,
            tonic::Status,
        >;
        /// Searches for audience attributes that can be used to generate insights.
        ///
        /// List of thrown errors:
        ///   [AuthenticationError]()
        ///   [AuthorizationError]()
        ///   [FieldError]()
        ///   [HeaderError]()
        ///   [InternalError]()
        ///   [QuotaError]()
        ///   [RangeError]()
        ///   [RequestError]()
        async fn list_audience_insights_attributes(
            &self,
            request: tonic::Request<super::ListAudienceInsightsAttributesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListAudienceInsightsAttributesResponse>,
            tonic::Status,
        >;
        /// Lists date ranges for which audience insights data can be requested.
        ///
        /// List of thrown errors:
        ///   [AuthenticationError]()
        ///   [AuthorizationError]()
        ///   [FieldError]()
        ///   [HeaderError]()
        ///   [InternalError]()
        ///   [QuotaError]()
        ///   [RangeError]()
        ///   [RequestError]()
        async fn list_insights_eligible_dates(
            &self,
            request: tonic::Request<super::ListInsightsEligibleDatesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListInsightsEligibleDatesResponse>,
            tonic::Status,
        >;
        /// Returns a collection of attributes that are represented in an audience of
        /// interest, with metrics that compare each attribute's share of the audience
        /// with its share of a baseline audience.
        ///
        /// List of thrown errors:
        ///   [AudienceInsightsError]()
        ///   [AuthenticationError]()
        ///   [AuthorizationError]()
        ///   [FieldError]()
        ///   [HeaderError]()
        ///   [InternalError]()
        ///   [QuotaError]()
        ///   [RangeError]()
        ///   [RequestError]()
        async fn generate_audience_composition_insights(
            &self,
            request: tonic::Request<super::GenerateAudienceCompositionInsightsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GenerateAudienceCompositionInsightsResponse>,
            tonic::Status,
        >;
        /// Returns a collection of targeting insights (e.g. targetable audiences) that
        /// are relevant to the requested audience.
        ///
        /// List of thrown errors:
        ///   [AudienceInsightsError]()
        ///   [AuthenticationError]()
        ///   [AuthorizationError]()
        ///   [FieldError]()
        ///   [HeaderError]()
        ///   [InternalError]()
        ///   [QuotaError]()
        ///   [RangeError]()
        ///   [RequestError]()
        async fn generate_suggested_targeting_insights(
            &self,
            request: tonic::Request<super::GenerateSuggestedTargetingInsightsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GenerateSuggestedTargetingInsightsResponse>,
            tonic::Status,
        >;
    }
    /// Audience Insights Service helps users find information about groups of
    /// people and how they can be reached with Google Ads. Accessible to
    /// allowlisted customers only.
    #[derive(Debug)]
    pub struct AudienceInsightsServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> AudienceInsightsServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>>
    for AudienceInsightsServiceServer<T>
    where
        T: AudienceInsightsService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/google.ads.googleads.v16.services.AudienceInsightsService/GenerateInsightsFinderReport" => {
                    #[allow(non_camel_case_types)]
                    struct GenerateInsightsFinderReportSvc<T: AudienceInsightsService>(
                        pub Arc<T>,
                    );
                    impl<
                        T: AudienceInsightsService,
                    > tonic::server::UnaryService<
                        super::GenerateInsightsFinderReportRequest,
                    > for GenerateInsightsFinderReportSvc<T> {
                        type Response = super::GenerateInsightsFinderReportResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::GenerateInsightsFinderReportRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as AudienceInsightsService>::generate_insights_finder_report(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GenerateInsightsFinderReportSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.ads.googleads.v16.services.AudienceInsightsService/ListAudienceInsightsAttributes" => {
                    #[allow(non_camel_case_types)]
                    struct ListAudienceInsightsAttributesSvc<T: AudienceInsightsService>(
                        pub Arc<T>,
                    );
                    impl<
                        T: AudienceInsightsService,
                    > tonic::server::UnaryService<
                        super::ListAudienceInsightsAttributesRequest,
                    > for ListAudienceInsightsAttributesSvc<T> {
                        type Response = super::ListAudienceInsightsAttributesResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::ListAudienceInsightsAttributesRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as AudienceInsightsService>::list_audience_insights_attributes(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ListAudienceInsightsAttributesSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.ads.googleads.v16.services.AudienceInsightsService/ListInsightsEligibleDates" => {
                    #[allow(non_camel_case_types)]
                    struct ListInsightsEligibleDatesSvc<T: AudienceInsightsService>(
                        pub Arc<T>,
                    );
                    impl<
                        T: AudienceInsightsService,
                    > tonic::server::UnaryService<
                        super::ListInsightsEligibleDatesRequest,
                    > for ListInsightsEligibleDatesSvc<T> {
                        type Response = super::ListInsightsEligibleDatesResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::ListInsightsEligibleDatesRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as AudienceInsightsService>::list_insights_eligible_dates(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ListInsightsEligibleDatesSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.ads.googleads.v16.services.AudienceInsightsService/GenerateAudienceCompositionInsights" => {
                    #[allow(non_camel_case_types)]
                    struct GenerateAudienceCompositionInsightsSvc<
                        T: AudienceInsightsService,
                    >(
                        pub Arc<T>,
                    );
                    impl<
                        T: AudienceInsightsService,
                    > tonic::server::UnaryService<
                        super::GenerateAudienceCompositionInsightsRequest,
                    > for GenerateAudienceCompositionInsightsSvc<T> {
                        type Response = super::GenerateAudienceCompositionInsightsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::GenerateAudienceCompositionInsightsRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as AudienceInsightsService>::generate_audience_composition_insights(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GenerateAudienceCompositionInsightsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.ads.googleads.v16.services.AudienceInsightsService/GenerateSuggestedTargetingInsights" => {
                    #[allow(non_camel_case_types)]
                    struct GenerateSuggestedTargetingInsightsSvc<
                        T: AudienceInsightsService,
                    >(
                        pub Arc<T>,
                    );
                    impl<
                        T: AudienceInsightsService,
                    > tonic::server::UnaryService<
                        super::GenerateSuggestedTargetingInsightsRequest,
                    > for GenerateSuggestedTargetingInsightsSvc<T> {
                        type Response = super::GenerateSuggestedTargetingInsightsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::GenerateSuggestedTargetingInsightsRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as AudienceInsightsService>::generate_suggested_targeting_insights(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GenerateSuggestedTargetingInsightsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for AudienceInsightsServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "google.ads.googleads.v16.services.AudienceInsightsService";
    impl<T> tonic::server::NamedService for AudienceInsightsServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Request message for
/// [AudienceService.MutateAudiences][google.ads.googleads.v16.services.AudienceService.MutateAudiences].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAudiencesRequest {
    /// Required. The ID of the customer whose audiences are being modified.
    #[prost(string, tag = "1")]
    pub customer_id: ::prost::alloc::string::String,
    /// Required. The list of operations to perform on individual audiences.
    #[prost(message, repeated, tag = "2")]
    pub operations: ::prost::alloc::vec::Vec<AudienceOperation>,
    /// If true, successful operations will be carried out and invalid operations
    /// will return errors. If false, all operations will be carried out in one
    /// transaction if and only if they are all valid. Default is false.
    #[prost(bool, tag = "3")]
    pub partial_failure: bool,
    /// If true, the request is validated but not executed. Only errors are
    /// returned, not results.
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
    /// The response content type setting. Determines whether the mutable resource
    /// or just the resource name should be returned post mutation.
    #[prost(
        enumeration = "super::enums::response_content_type_enum::ResponseContentType",
        tag = "5"
    )]
    pub response_content_type: i32,
}
/// Response message for an audience mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAudiencesResponse {
    /// All results for the mutate.
    #[prost(message, repeated, tag = "1")]
    pub results: ::prost::alloc::vec::Vec<MutateAudienceResult>,
    /// Errors that pertain to operation failures in the partial failure mode.
    /// Returned only when partial_failure = true and all errors occur inside the
    /// operations. If any errors occur outside the operations (for example, auth
    /// errors), we return an RPC level error.
    #[prost(message, optional, tag = "2")]
    pub partial_failure_error: ::core::option::Option<
        super::super::super::super::rpc::Status,
    >,
}
/// A single operation (create, update) on an audience.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AudienceOperation {
    /// FieldMask that determines which resource fields are modified in an update.
    #[prost(message, optional, tag = "4")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// The mutate operation.
    #[prost(oneof = "audience_operation::Operation", tags = "1, 2")]
    pub operation: ::core::option::Option<audience_operation::Operation>,
}
/// Nested message and enum types in `AudienceOperation`.
pub mod audience_operation {
    /// The mutate operation.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Operation {
        /// Create operation: No resource name is expected for the new audience
        #[prost(message, tag = "1")]
        Create(super::super::resources::Audience),
        /// Update operation: The audience is expected to have a valid resource
        /// name.
        #[prost(message, tag = "2")]
        Update(super::super::resources::Audience),
    }
}
/// The result for the audience mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAudienceResult {
    /// Returned for successful operations.
    #[prost(string, tag = "1")]
    pub resource_name: ::prost::alloc::string::String,
    /// The mutated Audience with only mutable fields after mutate. The
    /// field will only be returned when response_content_type is set to
    /// "MUTABLE_RESOURCE".
    #[prost(message, optional, tag = "2")]
    pub audience: ::core::option::Option<super::resources::Audience>,
}
/// Generated server implementations.
pub mod audience_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with AudienceServiceServer.
    #[async_trait]
    pub trait AudienceService: std::marker::Send + std::marker::Sync + 'static {
        /// Creates audiences. Operation statuses are returned.
        ///
        /// List of thrown errors:
        ///   [AudienceError]()
        async fn mutate_audiences(
            &self,
            request: tonic::Request<super::MutateAudiencesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MutateAudiencesResponse>,
            tonic::Status,
        >;
    }
    /// Service to manage audiences.
    #[derive(Debug)]
    pub struct AudienceServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> AudienceServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for AudienceServiceServer<T>
    where
        T: AudienceService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/google.ads.googleads.v16.services.AudienceService/MutateAudiences" => {
                    #[allow(non_camel_case_types)]
                    struct MutateAudiencesSvc<T: AudienceService>(pub Arc<T>);
                    impl<
                        T: AudienceService,
                    > tonic::server::UnaryService<super::MutateAudiencesRequest>
                    for MutateAudiencesSvc<T> {
                        type Response = super::MutateAudiencesResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::MutateAudiencesRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as AudienceService>::mutate_audiences(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = MutateAudiencesSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for AudienceServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "google.ads.googleads.v16.services.AudienceService";
    impl<T> tonic::server::NamedService for AudienceServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Request message for
/// [BiddingDataExclusionService.MutateBiddingDataExclusions][google.ads.googleads.v16.services.BiddingDataExclusionService.MutateBiddingDataExclusions].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateBiddingDataExclusionsRequest {
    /// Required. ID of the customer whose data exclusions are being modified.
    #[prost(string, tag = "1")]
    pub customer_id: ::prost::alloc::string::String,
    /// Required. The list of operations to perform on individual data exclusions.
    #[prost(message, repeated, tag = "2")]
    pub operations: ::prost::alloc::vec::Vec<BiddingDataExclusionOperation>,
    /// If true, successful operations will be carried out and invalid
    /// operations will return errors. If false, all operations will be carried
    /// out in one transaction if and only if they are all valid.
    /// Default is false.
    #[prost(bool, tag = "3")]
    pub partial_failure: bool,
    /// If true, the request is validated but not executed. Only errors are
    /// returned, not results.
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
    /// The response content type setting. Determines whether the mutable resource
    /// or just the resource name should be returned post mutation.
    #[prost(
        enumeration = "super::enums::response_content_type_enum::ResponseContentType",
        tag = "5"
    )]
    pub response_content_type: i32,
}
/// A single operation (create, remove, update) on a data exclusion.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BiddingDataExclusionOperation {
    /// FieldMask that determines which resource fields are modified in an update.
    #[prost(message, optional, tag = "4")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// The mutate operation.
    #[prost(oneof = "bidding_data_exclusion_operation::Operation", tags = "1, 2, 3")]
    pub operation: ::core::option::Option<bidding_data_exclusion_operation::Operation>,
}
/// Nested message and enum types in `BiddingDataExclusionOperation`.
pub mod bidding_data_exclusion_operation {
    /// The mutate operation.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Operation {
        /// Create operation: No resource name is expected for the new data
        /// exclusion.
        #[prost(message, tag = "1")]
        Create(super::super::resources::BiddingDataExclusion),
        /// Update operation: The data exclusion is expected to have a valid
        /// resource name.
        #[prost(message, tag = "2")]
        Update(super::super::resources::BiddingDataExclusion),
        /// Remove operation: A resource name for the removed data exclusion
        /// is expected, in this format:
        ///
        /// `customers/{customer_id}/biddingDataExclusions/{data_exclusion_id}`
        #[prost(string, tag = "3")]
        Remove(::prost::alloc::string::String),
    }
}
/// Response message for data exlusions mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateBiddingDataExclusionsResponse {
    /// Errors that pertain to operation failures in the partial failure mode.
    /// Returned only when partial_failure = true and all errors occur inside the
    /// operations. If any errors occur outside the operations (for example, auth
    /// errors), we return an RPC level error.
    #[prost(message, optional, tag = "3")]
    pub partial_failure_error: ::core::option::Option<
        super::super::super::super::rpc::Status,
    >,
    /// All results for the mutate.
    #[prost(message, repeated, tag = "2")]
    pub results: ::prost::alloc::vec::Vec<MutateBiddingDataExclusionsResult>,
}
/// The result for the data exclusion mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateBiddingDataExclusionsResult {
    /// Returned for successful operations.
    #[prost(string, tag = "1")]
    pub resource_name: ::prost::alloc::string::String,
    /// The mutated bidding data exclusion with only mutable fields after mutate.
    /// The field will only be returned when response_content_type is set
    /// to "MUTABLE_RESOURCE".
    #[prost(message, optional, tag = "2")]
    pub bidding_data_exclusion: ::core::option::Option<
        super::resources::BiddingDataExclusion,
    >,
}
/// Generated server implementations.
pub mod bidding_data_exclusion_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with BiddingDataExclusionServiceServer.
    #[async_trait]
    pub trait BiddingDataExclusionService: std::marker::Send + std::marker::Sync + 'static {
        /// Creates, updates, or removes data exclusions.
        /// Operation statuses are returned.
        async fn mutate_bidding_data_exclusions(
            &self,
            request: tonic::Request<super::MutateBiddingDataExclusionsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MutateBiddingDataExclusionsResponse>,
            tonic::Status,
        >;
    }
    /// Service to manage bidding data exclusions.
    #[derive(Debug)]
    pub struct BiddingDataExclusionServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> BiddingDataExclusionServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>>
    for BiddingDataExclusionServiceServer<T>
    where
        T: BiddingDataExclusionService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/google.ads.googleads.v16.services.BiddingDataExclusionService/MutateBiddingDataExclusions" => {
                    #[allow(non_camel_case_types)]
                    struct MutateBiddingDataExclusionsSvc<
                        T: BiddingDataExclusionService,
                    >(
                        pub Arc<T>,
                    );
                    impl<
                        T: BiddingDataExclusionService,
                    > tonic::server::UnaryService<
                        super::MutateBiddingDataExclusionsRequest,
                    > for MutateBiddingDataExclusionsSvc<T> {
                        type Response = super::MutateBiddingDataExclusionsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::MutateBiddingDataExclusionsRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as BiddingDataExclusionService>::mutate_bidding_data_exclusions(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = MutateBiddingDataExclusionsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for BiddingDataExclusionServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "google.ads.googleads.v16.services.BiddingDataExclusionService";
    impl<T> tonic::server::NamedService for BiddingDataExclusionServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Request message for
/// [BiddingSeasonalityAdjustmentService.MutateBiddingSeasonalityAdjustments][google.ads.googleads.v16.services.BiddingSeasonalityAdjustmentService.MutateBiddingSeasonalityAdjustments].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateBiddingSeasonalityAdjustmentsRequest {
    /// Required. ID of the customer whose seasonality adjustments are being
    /// modified.
    #[prost(string, tag = "1")]
    pub customer_id: ::prost::alloc::string::String,
    /// Required. The list of operations to perform on individual seasonality
    /// adjustments.
    #[prost(message, repeated, tag = "2")]
    pub operations: ::prost::alloc::vec::Vec<BiddingSeasonalityAdjustmentOperation>,
    /// If true, successful operations will be carried out and invalid
    /// operations will return errors. If false, all operations will be carried
    /// out in one transaction if and only if they are all valid.
    /// Default is false.
    #[prost(bool, tag = "3")]
    pub partial_failure: bool,
    /// If true, the request is validated but not executed. Only errors are
    /// returned, not results.
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
    /// The response content type setting. Determines whether the mutable resource
    /// or just the resource name should be returned post mutation.
    #[prost(
        enumeration = "super::enums::response_content_type_enum::ResponseContentType",
        tag = "5"
    )]
    pub response_content_type: i32,
}
/// A single operation (create, remove, update) on a seasonality adjustment.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BiddingSeasonalityAdjustmentOperation {
    /// FieldMask that determines which resource fields are modified in an update.
    #[prost(message, optional, tag = "4")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// The mutate operation.
    #[prost(
        oneof = "bidding_seasonality_adjustment_operation::Operation",
        tags = "1, 2, 3"
    )]
    pub operation: ::core::option::Option<
        bidding_seasonality_adjustment_operation::Operation,
    >,
}
/// Nested message and enum types in `BiddingSeasonalityAdjustmentOperation`.
pub mod bidding_seasonality_adjustment_operation {
    /// The mutate operation.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Operation {
        /// Create operation: No resource name is expected for the new seasonality
        /// adjustment.
        #[prost(message, tag = "1")]
        Create(super::super::resources::BiddingSeasonalityAdjustment),
        /// Update operation: The seasonality adjustment is expected to have a valid
        /// resource name.
        #[prost(message, tag = "2")]
        Update(super::super::resources::BiddingSeasonalityAdjustment),
        /// Remove operation: A resource name for the removed seasonality adjustment
        /// is expected, in this format:
        ///
        /// `customers/{customer_id}/biddingSeasonalityAdjustments/{seasonality_adjustment_id}`
        #[prost(string, tag = "3")]
        Remove(::prost::alloc::string::String),
    }
}
/// Response message for seasonality adjustments mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateBiddingSeasonalityAdjustmentsResponse {
    /// Errors that pertain to operation failures in the partial failure mode.
    /// Returned only when partial_failure = true and all errors occur inside the
    /// operations. If any errors occur outside the operations (for example, auth
    /// errors), we return an RPC level error.
    #[prost(message, optional, tag = "3")]
    pub partial_failure_error: ::core::option::Option<
        super::super::super::super::rpc::Status,
    >,
    /// All results for the mutate.
    #[prost(message, repeated, tag = "2")]
    pub results: ::prost::alloc::vec::Vec<MutateBiddingSeasonalityAdjustmentsResult>,
}
/// The result for the seasonality adjustment mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateBiddingSeasonalityAdjustmentsResult {
    /// Returned for successful operations.
    #[prost(string, tag = "1")]
    pub resource_name: ::prost::alloc::string::String,
    /// The mutated bidding seasonality adjustment with only mutable fields after
    /// mutate. The field will only be returned when response_content_type is set
    /// to "MUTABLE_RESOURCE".
    #[prost(message, optional, tag = "2")]
    pub bidding_seasonality_adjustment: ::core::option::Option<
        super::resources::BiddingSeasonalityAdjustment,
    >,
}
/// Generated server implementations.
pub mod bidding_seasonality_adjustment_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with BiddingSeasonalityAdjustmentServiceServer.
    #[async_trait]
    pub trait BiddingSeasonalityAdjustmentService: std::marker::Send + std::marker::Sync + 'static {
        /// Creates, updates, or removes seasonality adjustments.
        /// Operation statuses are returned.
        async fn mutate_bidding_seasonality_adjustments(
            &self,
            request: tonic::Request<super::MutateBiddingSeasonalityAdjustmentsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MutateBiddingSeasonalityAdjustmentsResponse>,
            tonic::Status,
        >;
    }
    /// Service to manage bidding seasonality adjustments.
    #[derive(Debug)]
    pub struct BiddingSeasonalityAdjustmentServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> BiddingSeasonalityAdjustmentServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>>
    for BiddingSeasonalityAdjustmentServiceServer<T>
    where
        T: BiddingSeasonalityAdjustmentService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/google.ads.googleads.v16.services.BiddingSeasonalityAdjustmentService/MutateBiddingSeasonalityAdjustments" => {
                    #[allow(non_camel_case_types)]
                    struct MutateBiddingSeasonalityAdjustmentsSvc<
                        T: BiddingSeasonalityAdjustmentService,
                    >(
                        pub Arc<T>,
                    );
                    impl<
                        T: BiddingSeasonalityAdjustmentService,
                    > tonic::server::UnaryService<
                        super::MutateBiddingSeasonalityAdjustmentsRequest,
                    > for MutateBiddingSeasonalityAdjustmentsSvc<T> {
                        type Response = super::MutateBiddingSeasonalityAdjustmentsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::MutateBiddingSeasonalityAdjustmentsRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as BiddingSeasonalityAdjustmentService>::mutate_bidding_seasonality_adjustments(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = MutateBiddingSeasonalityAdjustmentsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for BiddingSeasonalityAdjustmentServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "google.ads.googleads.v16.services.BiddingSeasonalityAdjustmentService";
    impl<T> tonic::server::NamedService
    for BiddingSeasonalityAdjustmentServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Request message for
/// [BiddingStrategyService.MutateBiddingStrategies][google.ads.googleads.v16.services.BiddingStrategyService.MutateBiddingStrategies].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateBiddingStrategiesRequest {
    /// Required. The ID of the customer whose bidding strategies are being
    /// modified.
    #[prost(string, tag = "1")]
    pub customer_id: ::prost::alloc::string::String,
    /// Required. The list of operations to perform on individual bidding
    /// strategies.
    #[prost(message, repeated, tag = "2")]
    pub operations: ::prost::alloc::vec::Vec<BiddingStrategyOperation>,
    /// If true, successful operations will be carried out and invalid
    /// operations will return errors. If false, all operations will be carried
    /// out in one transaction if and only if they are all valid.
    /// Default is false.
    #[prost(bool, tag = "3")]
    pub partial_failure: bool,
    /// If true, the request is validated but not executed. Only errors are
    /// returned, not results.
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
    /// The response content type setting. Determines whether the mutable resource
    /// or just the resource name should be returned post mutation.
    #[prost(
        enumeration = "super::enums::response_content_type_enum::ResponseContentType",
        tag = "5"
    )]
    pub response_content_type: i32,
}
/// A single operation (create, update, remove) on a bidding strategy.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BiddingStrategyOperation {
    /// FieldMask that determines which resource fields are modified in an update.
    #[prost(message, optional, tag = "4")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// The mutate operation.
    #[prost(oneof = "bidding_strategy_operation::Operation", tags = "1, 2, 3")]
    pub operation: ::core::option::Option<bidding_strategy_operation::Operation>,
}
/// Nested message and enum types in `BiddingStrategyOperation`.
pub mod bidding_strategy_operation {
    /// The mutate operation.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Operation {
        /// Create operation: No resource name is expected for the new bidding
        /// strategy.
        #[prost(message, tag = "1")]
        Create(super::super::resources::BiddingStrategy),
        /// Update operation: The bidding strategy is expected to have a valid
        /// resource name.
        #[prost(message, tag = "2")]
        Update(super::super::resources::BiddingStrategy),
        /// Remove operation: A resource name for the removed bidding strategy is
        /// expected, in this format:
        ///
        /// `customers/{customer_id}/biddingStrategies/{bidding_strategy_id}`
        #[prost(string, tag = "3")]
        Remove(::prost::alloc::string::String),
    }
}
/// Response message for bidding strategy mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateBiddingStrategiesResponse {
    /// Errors that pertain to operation failures in the partial failure mode.
    /// Returned only when partial_failure = true and all errors occur inside the
    /// operations. If any errors occur outside the operations (for example, auth
    /// errors), we return an RPC level error.
    #[prost(message, optional, tag = "3")]
    pub partial_failure_error: ::core::option::Option<
        super::super::super::super::rpc::Status,
    >,
    /// All results for the mutate.
    #[prost(message, repeated, tag = "2")]
    pub results: ::prost::alloc::vec::Vec<MutateBiddingStrategyResult>,
}
/// The result for the bidding strategy mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateBiddingStrategyResult {
    /// Returned for successful operations.
    #[prost(string, tag = "1")]
    pub resource_name: ::prost::alloc::string::String,
    /// The mutated bidding strategy with only mutable fields after mutate. The
    /// field will only be returned when response_content_type is set to
    /// "MUTABLE_RESOURCE".
    #[prost(message, optional, tag = "2")]
    pub bidding_strategy: ::core::option::Option<super::resources::BiddingStrategy>,
}
/// Generated server implementations.
pub mod bidding_strategy_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with BiddingStrategyServiceServer.
    #[async_trait]
    pub trait BiddingStrategyService: std::marker::Send + std::marker::Sync + 'static {
        /// Creates, updates, or removes bidding strategies. Operation statuses are
        /// returned.
        ///
        /// List of thrown errors:
        ///   [AdxError]()
        ///   [AuthenticationError]()
        ///   [AuthorizationError]()
        ///   [BiddingError]()
        ///   [BiddingStrategyError]()
        ///   [ContextError]()
        ///   [DatabaseError]()
        ///   [DateError]()
        ///   [DistinctError]()
        ///   [FieldError]()
        ///   [FieldMaskError]()
        ///   [HeaderError]()
        ///   [IdError]()
        ///   [InternalError]()
        ///   [MutateError]()
        ///   [NewResourceCreationError]()
        ///   [NotEmptyError]()
        ///   [NullError]()
        ///   [OperationAccessDeniedError]()
        ///   [OperatorError]()
        ///   [QuotaError]()
        ///   [RangeError]()
        ///   [RequestError]()
        ///   [SizeLimitError]()
        ///   [StringFormatError]()
        ///   [StringLengthError]()
        async fn mutate_bidding_strategies(
            &self,
            request: tonic::Request<super::MutateBiddingStrategiesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MutateBiddingStrategiesResponse>,
            tonic::Status,
        >;
    }
    /// Service to manage bidding strategies.
    #[derive(Debug)]
    pub struct BiddingStrategyServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> BiddingStrategyServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>>
    for BiddingStrategyServiceServer<T>
    where
        T: BiddingStrategyService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/google.ads.googleads.v16.services.BiddingStrategyService/MutateBiddingStrategies" => {
                    #[allow(non_camel_case_types)]
                    struct MutateBiddingStrategiesSvc<T: BiddingStrategyService>(
                        pub Arc<T>,
                    );
                    impl<
                        T: BiddingStrategyService,
                    > tonic::server::UnaryService<super::MutateBiddingStrategiesRequest>
                    for MutateBiddingStrategiesSvc<T> {
                        type Response = super::MutateBiddingStrategiesResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::MutateBiddingStrategiesRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as BiddingStrategyService>::mutate_bidding_strategies(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = MutateBiddingStrategiesSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for BiddingStrategyServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "google.ads.googleads.v16.services.BiddingStrategyService";
    impl<T> tonic::server::NamedService for BiddingStrategyServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Request message for
/// [CampaignAssetService.MutateCampaignAssets][google.ads.googleads.v16.services.CampaignAssetService.MutateCampaignAssets].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCampaignAssetsRequest {
    /// Required. The ID of the customer whose campaign assets are being modified.
    #[prost(string, tag = "1")]
    pub customer_id: ::prost::alloc::string::String,
    /// Required. The list of operations to perform on individual campaign assets.
    #[prost(message, repeated, tag = "2")]
    pub operations: ::prost::alloc::vec::Vec<CampaignAssetOperation>,
    /// If true, successful operations will be carried out and invalid
    /// operations will return errors. If false, all operations will be carried
    /// out in one transaction if and only if they are all valid.
    /// Default is false.
    #[prost(bool, tag = "3")]
    pub partial_failure: bool,
    /// If true, the request is validated but not executed. Only errors are
    /// returned, not results.
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
    /// The response content type setting. Determines whether the mutable resource
    /// or just the resource name should be returned post mutation.
    #[prost(
        enumeration = "super::enums::response_content_type_enum::ResponseContentType",
        tag = "5"
    )]
    pub response_content_type: i32,
}
/// A single operation (create, update, remove) on a campaign asset.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CampaignAssetOperation {
    /// FieldMask that determines which resource fields are modified in an update.
    #[prost(message, optional, tag = "4")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// The mutate operation.
    #[prost(oneof = "campaign_asset_operation::Operation", tags = "1, 3, 2")]
    pub operation: ::core::option::Option<campaign_asset_operation::Operation>,
}
/// Nested message and enum types in `CampaignAssetOperation`.
pub mod campaign_asset_operation {
    /// The mutate operation.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Operation {
        /// Create operation: No resource name is expected for the new campaign
        /// asset.
        #[prost(message, tag = "1")]
        Create(super::super::resources::CampaignAsset),
        /// Update operation: The campaign asset is expected to have a valid resource
        /// name.
        #[prost(message, tag = "3")]
        Update(super::super::resources::CampaignAsset),
        /// Remove operation: A resource name for the removed campaign asset is
        /// expected, in this format:
        ///
        /// `customers/{customer_id}/campaignAssets/{campaign_id}~{asset_id}~{field_type}`
        #[prost(string, tag = "2")]
        Remove(::prost::alloc::string::String),
    }
}
/// Response message for a campaign asset mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCampaignAssetsResponse {
    /// Errors that pertain to operation failures in the partial failure mode.
    /// Returned only when partial_failure = true and all errors occur inside the
    /// operations. If any errors occur outside the operations (for example, auth
    /// errors), we return an RPC level error.
    #[prost(message, optional, tag = "1")]
    pub partial_failure_error: ::core::option::Option<
        super::super::super::super::rpc::Status,
    >,
    /// All results for the mutate.
    #[prost(message, repeated, tag = "2")]
    pub results: ::prost::alloc::vec::Vec<MutateCampaignAssetResult>,
}
/// The result for the campaign asset mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCampaignAssetResult {
    /// Returned for successful operations.
    #[prost(string, tag = "1")]
    pub resource_name: ::prost::alloc::string::String,
    /// The mutated campaign asset with only mutable fields after
    /// mutate. The field will only be returned when response_content_type is set
    /// to "MUTABLE_RESOURCE".
    #[prost(message, optional, tag = "2")]
    pub campaign_asset: ::core::option::Option<super::resources::CampaignAsset>,
}
/// Generated server implementations.
pub mod campaign_asset_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with CampaignAssetServiceServer.
    #[async_trait]
    pub trait CampaignAssetService: std::marker::Send + std::marker::Sync + 'static {
        /// Creates, updates, or removes campaign assets. Operation statuses are
        /// returned.
        ///
        /// List of thrown errors:
        ///   [AssetLinkError]()
        ///   [AuthenticationError]()
        ///   [AuthorizationError]()
        ///   [ContextError]()
        ///   [DatabaseError]()
        ///   [FieldError]()
        ///   [HeaderError]()
        ///   [InternalError]()
        ///   [MutateError]()
        ///   [NotAllowlistedError]()
        ///   [QuotaError]()
        ///   [RequestError]()
        async fn mutate_campaign_assets(
            &self,
            request: tonic::Request<super::MutateCampaignAssetsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MutateCampaignAssetsResponse>,
            tonic::Status,
        >;
    }
    /// Service to manage campaign assets.
    #[derive(Debug)]
    pub struct CampaignAssetServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> CampaignAssetServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>>
    for CampaignAssetServiceServer<T>
    where
        T: CampaignAssetService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/google.ads.googleads.v16.services.CampaignAssetService/MutateCampaignAssets" => {
                    #[allow(non_camel_case_types)]
                    struct MutateCampaignAssetsSvc<T: CampaignAssetService>(pub Arc<T>);
                    impl<
                        T: CampaignAssetService,
                    > tonic::server::UnaryService<super::MutateCampaignAssetsRequest>
                    for MutateCampaignAssetsSvc<T> {
                        type Response = super::MutateCampaignAssetsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::MutateCampaignAssetsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as CampaignAssetService>::mutate_campaign_assets(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = MutateCampaignAssetsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for CampaignAssetServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "google.ads.googleads.v16.services.CampaignAssetService";
    impl<T> tonic::server::NamedService for CampaignAssetServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Request message for
/// [CampaignAssetSetService.MutateCampaignAssetSets][google.ads.googleads.v16.services.CampaignAssetSetService.MutateCampaignAssetSets].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCampaignAssetSetsRequest {
    /// Required. The ID of the customer whose campaign asset sets are being
    /// modified.
    #[prost(string, tag = "1")]
    pub customer_id: ::prost::alloc::string::String,
    /// Required. The list of operations to perform on individual campaign asset
    /// sets.
    #[prost(message, repeated, tag = "2")]
    pub operations: ::prost::alloc::vec::Vec<CampaignAssetSetOperation>,
    /// If true, successful operations will be carried out and invalid
    /// operations will return errors. If false, all operations will be carried
    /// out in one transaction if and only if they are all valid.
    /// Default is false.
    #[prost(bool, tag = "3")]
    pub partial_failure: bool,
    /// If true, the request is validated but not executed. Only errors are
    /// returned, not results.
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
    /// The response content type setting. Determines whether the mutable resource
    /// or just the resource name should be returned post mutation.
    #[prost(
        enumeration = "super::enums::response_content_type_enum::ResponseContentType",
        tag = "5"
    )]
    pub response_content_type: i32,
}
/// A single operation (create, remove) on a campaign asset set.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CampaignAssetSetOperation {
    /// The mutate operation.
    #[prost(oneof = "campaign_asset_set_operation::Operation", tags = "1, 2")]
    pub operation: ::core::option::Option<campaign_asset_set_operation::Operation>,
}
/// Nested message and enum types in `CampaignAssetSetOperation`.
pub mod campaign_asset_set_operation {
    /// The mutate operation.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Operation {
        /// Create operation: No resource name is expected for the new campaign asset
        /// set.
        #[prost(message, tag = "1")]
        Create(super::super::resources::CampaignAssetSet),
        /// Remove operation: A resource name for the removed campaign asset set is
        /// expected, in this format:
        /// `customers/{customer_id}/campaignAssetSets/{campaign_id}~{asset_set_id}`
        #[prost(string, tag = "2")]
        Remove(::prost::alloc::string::String),
    }
}
/// Response message for a campaign asset set mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCampaignAssetSetsResponse {
    /// All results for the mutate.
    #[prost(message, repeated, tag = "1")]
    pub results: ::prost::alloc::vec::Vec<MutateCampaignAssetSetResult>,
    /// Errors that pertain to operation failures in the partial failure mode.
    /// Returned only when partial_failure = true and all errors occur inside the
    /// operations. If any errors occur outside the operations (for example, auth
    /// errors), we return an RPC level error.
    #[prost(message, optional, tag = "2")]
    pub partial_failure_error: ::core::option::Option<
        super::super::super::super::rpc::Status,
    >,
}
/// The result for the campaign asset set mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCampaignAssetSetResult {
    /// Returned for successful operations.
    #[prost(string, tag = "1")]
    pub resource_name: ::prost::alloc::string::String,
    /// The mutated campaign asset set with only mutable fields after mutate. The
    /// field will only be returned when response_content_type is set to
    /// "MUTABLE_RESOURCE".
    #[prost(message, optional, tag = "2")]
    pub campaign_asset_set: ::core::option::Option<super::resources::CampaignAssetSet>,
}
/// Generated server implementations.
pub mod campaign_asset_set_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with CampaignAssetSetServiceServer.
    #[async_trait]
    pub trait CampaignAssetSetService: std::marker::Send + std::marker::Sync + 'static {
        /// Creates, updates or removes campaign asset sets. Operation statuses are
        /// returned.
        async fn mutate_campaign_asset_sets(
            &self,
            request: tonic::Request<super::MutateCampaignAssetSetsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MutateCampaignAssetSetsResponse>,
            tonic::Status,
        >;
    }
    /// Service to manage campaign asset set
    #[derive(Debug)]
    pub struct CampaignAssetSetServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> CampaignAssetSetServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>>
    for CampaignAssetSetServiceServer<T>
    where
        T: CampaignAssetSetService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/google.ads.googleads.v16.services.CampaignAssetSetService/MutateCampaignAssetSets" => {
                    #[allow(non_camel_case_types)]
                    struct MutateCampaignAssetSetsSvc<T: CampaignAssetSetService>(
                        pub Arc<T>,
                    );
                    impl<
                        T: CampaignAssetSetService,
                    > tonic::server::UnaryService<super::MutateCampaignAssetSetsRequest>
                    for MutateCampaignAssetSetsSvc<T> {
                        type Response = super::MutateCampaignAssetSetsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::MutateCampaignAssetSetsRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as CampaignAssetSetService>::mutate_campaign_asset_sets(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = MutateCampaignAssetSetsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for CampaignAssetSetServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "google.ads.googleads.v16.services.CampaignAssetSetService";
    impl<T> tonic::server::NamedService for CampaignAssetSetServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Request message for
/// [CampaignBidModifierService.MutateCampaignBidModifiers][google.ads.googleads.v16.services.CampaignBidModifierService.MutateCampaignBidModifiers].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCampaignBidModifiersRequest {
    /// Required. ID of the customer whose campaign bid modifiers are being
    /// modified.
    #[prost(string, tag = "1")]
    pub customer_id: ::prost::alloc::string::String,
    /// Required. The list of operations to perform on individual campaign bid
    /// modifiers.
    #[prost(message, repeated, tag = "2")]
    pub operations: ::prost::alloc::vec::Vec<CampaignBidModifierOperation>,
    /// If true, successful operations will be carried out and invalid
    /// operations will return errors. If false, all operations will be carried
    /// out in one transaction if and only if they are all valid.
    /// Default is false.
    #[prost(bool, tag = "3")]
    pub partial_failure: bool,
    /// If true, the request is validated but not executed. Only errors are
    /// returned, not results.
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
    /// The response content type setting. Determines whether the mutable resource
    /// or just the resource name should be returned post mutation.
    #[prost(
        enumeration = "super::enums::response_content_type_enum::ResponseContentType",
        tag = "5"
    )]
    pub response_content_type: i32,
}
/// A single operation (create, remove, update) on a campaign bid modifier.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CampaignBidModifierOperation {
    /// FieldMask that determines which resource fields are modified in an update.
    #[prost(message, optional, tag = "4")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// The mutate operation.
    #[prost(oneof = "campaign_bid_modifier_operation::Operation", tags = "1, 2, 3")]
    pub operation: ::core::option::Option<campaign_bid_modifier_operation::Operation>,
}
/// Nested message and enum types in `CampaignBidModifierOperation`.
pub mod campaign_bid_modifier_operation {
    /// The mutate operation.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Operation {
        /// Create operation: No resource name is expected for the new campaign bid
        /// modifier.
        #[prost(message, tag = "1")]
        Create(super::super::resources::CampaignBidModifier),
        /// Update operation: The campaign bid modifier is expected to have a valid
        /// resource name.
        #[prost(message, tag = "2")]
        Update(super::super::resources::CampaignBidModifier),
        /// Remove operation: A resource name for the removed campaign bid modifier
        /// is expected, in this format:
        ///
        /// `customers/{customer_id}/CampaignBidModifiers/{campaign_id}~{criterion_id}`
        #[prost(string, tag = "3")]
        Remove(::prost::alloc::string::String),
    }
}
/// Response message for campaign bid modifiers mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCampaignBidModifiersResponse {
    /// Errors that pertain to operation failures in the partial failure mode.
    /// Returned only when partial_failure = true and all errors occur inside the
    /// operations. If any errors occur outside the operations (for example, auth
    /// errors), we return an RPC level error.
    #[prost(message, optional, tag = "3")]
    pub partial_failure_error: ::core::option::Option<
        super::super::super::super::rpc::Status,
    >,
    /// All results for the mutate.
    #[prost(message, repeated, tag = "2")]
    pub results: ::prost::alloc::vec::Vec<MutateCampaignBidModifierResult>,
}
/// The result for the criterion mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCampaignBidModifierResult {
    /// Returned for successful operations.
    #[prost(string, tag = "1")]
    pub resource_name: ::prost::alloc::string::String,
    /// The mutated campaign bid modifier with only mutable fields after mutate.
    /// The field will only be returned when response_content_type is set to
    /// "MUTABLE_RESOURCE".
    #[prost(message, optional, tag = "2")]
    pub campaign_bid_modifier: ::core::option::Option<
        super::resources::CampaignBidModifier,
    >,
}
/// Generated server implementations.
pub mod campaign_bid_modifier_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with CampaignBidModifierServiceServer.
    #[async_trait]
    pub trait CampaignBidModifierService: std::marker::Send + std::marker::Sync + 'static {
        /// Creates, updates, or removes campaign bid modifiers.
        /// Operation statuses are returned.
        ///
        /// List of thrown errors:
        ///   [AuthenticationError]()
        ///   [AuthorizationError]()
        ///   [ContextError]()
        ///   [CriterionError]()
        ///   [DatabaseError]()
        ///   [DateError]()
        ///   [DistinctError]()
        ///   [FieldError]()
        ///   [HeaderError]()
        ///   [IdError]()
        ///   [InternalError]()
        ///   [MutateError]()
        ///   [NewResourceCreationError]()
        ///   [NotEmptyError]()
        ///   [NullError]()
        ///   [OperatorError]()
        ///   [QuotaError]()
        ///   [RangeError]()
        ///   [RequestError]()
        ///   [SizeLimitError]()
        ///   [StringFormatError]()
        ///   [StringLengthError]()
        async fn mutate_campaign_bid_modifiers(
            &self,
            request: tonic::Request<super::MutateCampaignBidModifiersRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MutateCampaignBidModifiersResponse>,
            tonic::Status,
        >;
    }
    /// Service to manage campaign bid modifiers.
    #[derive(Debug)]
    pub struct CampaignBidModifierServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> CampaignBidModifierServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>>
    for CampaignBidModifierServiceServer<T>
    where
        T: CampaignBidModifierService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/google.ads.googleads.v16.services.CampaignBidModifierService/MutateCampaignBidModifiers" => {
                    #[allow(non_camel_case_types)]
                    struct MutateCampaignBidModifiersSvc<T: CampaignBidModifierService>(
                        pub Arc<T>,
                    );
                    impl<
                        T: CampaignBidModifierService,
                    > tonic::server::UnaryService<
                        super::MutateCampaignBidModifiersRequest,
                    > for MutateCampaignBidModifiersSvc<T> {
                        type Response = super::MutateCampaignBidModifiersResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::MutateCampaignBidModifiersRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as CampaignBidModifierService>::mutate_campaign_bid_modifiers(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = MutateCampaignBidModifiersSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for CampaignBidModifierServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "google.ads.googleads.v16.services.CampaignBidModifierService";
    impl<T> tonic::server::NamedService for CampaignBidModifierServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Request message for
/// [CampaignBudgetService.MutateCampaignBudgets][google.ads.googleads.v16.services.CampaignBudgetService.MutateCampaignBudgets].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCampaignBudgetsRequest {
    /// Required. The ID of the customer whose campaign budgets are being modified.
    #[prost(string, tag = "1")]
    pub customer_id: ::prost::alloc::string::String,
    /// Required. The list of operations to perform on individual campaign budgets.
    #[prost(message, repeated, tag = "2")]
    pub operations: ::prost::alloc::vec::Vec<CampaignBudgetOperation>,
    /// If true, successful operations will be carried out and invalid
    /// operations will return errors. If false, all operations will be carried
    /// out in one transaction if and only if they are all valid.
    /// Default is false.
    #[prost(bool, tag = "3")]
    pub partial_failure: bool,
    /// If true, the request is validated but not executed. Only errors are
    /// returned, not results.
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
    /// The response content type setting. Determines whether the mutable resource
    /// or just the resource name should be returned post mutation.
    #[prost(
        enumeration = "super::enums::response_content_type_enum::ResponseContentType",
        tag = "5"
    )]
    pub response_content_type: i32,
}
/// A single operation (create, update, remove) on a campaign budget.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CampaignBudgetOperation {
    /// FieldMask that determines which resource fields are modified in an update.
    #[prost(message, optional, tag = "4")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// The mutate operation.
    #[prost(oneof = "campaign_budget_operation::Operation", tags = "1, 2, 3")]
    pub operation: ::core::option::Option<campaign_budget_operation::Operation>,
}
/// Nested message and enum types in `CampaignBudgetOperation`.
pub mod campaign_budget_operation {
    /// The mutate operation.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Operation {
        /// Create operation: No resource name is expected for the new budget.
        #[prost(message, tag = "1")]
        Create(super::super::resources::CampaignBudget),
        /// Update operation: The campaign budget is expected to have a valid
        /// resource name.
        #[prost(message, tag = "2")]
        Update(super::super::resources::CampaignBudget),
        /// Remove operation: A resource name for the removed budget is expected, in
        /// this format:
        ///
        /// `customers/{customer_id}/campaignBudgets/{budget_id}`
        #[prost(string, tag = "3")]
        Remove(::prost::alloc::string::String),
    }
}
/// Response message for campaign budget mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCampaignBudgetsResponse {
    /// Errors that pertain to operation failures in the partial failure mode.
    /// Returned only when partial_failure = true and all errors occur inside the
    /// operations. If any errors occur outside the operations (for example, auth
    /// errors), we return an RPC level error.
    #[prost(message, optional, tag = "3")]
    pub partial_failure_error: ::core::option::Option<
        super::super::super::super::rpc::Status,
    >,
    /// All results for the mutate.
    #[prost(message, repeated, tag = "2")]
    pub results: ::prost::alloc::vec::Vec<MutateCampaignBudgetResult>,
}
/// The result for the campaign budget mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCampaignBudgetResult {
    /// Returned for successful operations.
    #[prost(string, tag = "1")]
    pub resource_name: ::prost::alloc::string::String,
    /// The mutated campaign budget with only mutable fields after mutate. The
    /// field will only be returned when response_content_type is set to
    /// "MUTABLE_RESOURCE".
    #[prost(message, optional, tag = "2")]
    pub campaign_budget: ::core::option::Option<super::resources::CampaignBudget>,
}
/// Generated server implementations.
pub mod campaign_budget_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with CampaignBudgetServiceServer.
    #[async_trait]
    pub trait CampaignBudgetService: std::marker::Send + std::marker::Sync + 'static {
        /// Creates, updates, or removes campaign budgets. Operation statuses are
        /// returned.
        ///
        /// List of thrown errors:
        ///   [AuthenticationError]()
        ///   [AuthorizationError]()
        ///   [CampaignBudgetError]()
        ///   [DatabaseError]()
        ///   [DistinctError]()
        ///   [FieldError]()
        ///   [FieldMaskError]()
        ///   [HeaderError]()
        ///   [InternalError]()
        ///   [MutateError]()
        ///   [NewResourceCreationError]()
        ///   [OperationAccessDeniedError]()
        ///   [QuotaError]()
        ///   [RangeError]()
        ///   [RequestError]()
        ///   [ResourceCountLimitExceededError]()
        ///   [StringLengthError]()
        async fn mutate_campaign_budgets(
            &self,
            request: tonic::Request<super::MutateCampaignBudgetsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MutateCampaignBudgetsResponse>,
            tonic::Status,
        >;
    }
    /// Service to manage campaign budgets.
    #[derive(Debug)]
    pub struct CampaignBudgetServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> CampaignBudgetServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>>
    for CampaignBudgetServiceServer<T>
    where
        T: CampaignBudgetService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/google.ads.googleads.v16.services.CampaignBudgetService/MutateCampaignBudgets" => {
                    #[allow(non_camel_case_types)]
                    struct MutateCampaignBudgetsSvc<T: CampaignBudgetService>(
                        pub Arc<T>,
                    );
                    impl<
                        T: CampaignBudgetService,
                    > tonic::server::UnaryService<super::MutateCampaignBudgetsRequest>
                    for MutateCampaignBudgetsSvc<T> {
                        type Response = super::MutateCampaignBudgetsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::MutateCampaignBudgetsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as CampaignBudgetService>::mutate_campaign_budgets(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = MutateCampaignBudgetsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for CampaignBudgetServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "google.ads.googleads.v16.services.CampaignBudgetService";
    impl<T> tonic::server::NamedService for CampaignBudgetServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Request message for
/// [CampaignConversionGoalService.MutateCampaignConversionGoals][google.ads.googleads.v16.services.CampaignConversionGoalService.MutateCampaignConversionGoals].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCampaignConversionGoalsRequest {
    /// Required. The ID of the customer whose campaign conversion goals are being
    /// modified.
    #[prost(string, tag = "1")]
    pub customer_id: ::prost::alloc::string::String,
    /// Required. The list of operations to perform on individual campaign
    /// conversion goal.
    #[prost(message, repeated, tag = "2")]
    pub operations: ::prost::alloc::vec::Vec<CampaignConversionGoalOperation>,
    /// If true, the request is validated but not executed. Only errors are
    /// returned, not results.
    #[prost(bool, tag = "3")]
    pub validate_only: bool,
}
/// A single operation (update) on a campaign conversion goal.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CampaignConversionGoalOperation {
    /// FieldMask that determines which resource fields are modified in an update.
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// The mutate operation.
    #[prost(oneof = "campaign_conversion_goal_operation::Operation", tags = "1")]
    pub operation: ::core::option::Option<campaign_conversion_goal_operation::Operation>,
}
/// Nested message and enum types in `CampaignConversionGoalOperation`.
pub mod campaign_conversion_goal_operation {
    /// The mutate operation.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Operation {
        /// Update operation: The customer conversion goal is expected to have a
        /// valid resource name.
        #[prost(message, tag = "1")]
        Update(super::super::resources::CampaignConversionGoal),
    }
}
/// Response message for a campaign conversion goal mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCampaignConversionGoalsResponse {
    /// All results for the mutate.
    #[prost(message, repeated, tag = "1")]
    pub results: ::prost::alloc::vec::Vec<MutateCampaignConversionGoalResult>,
}
/// The result for the campaign conversion goal mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCampaignConversionGoalResult {
    /// Returned for successful operations.
    #[prost(string, tag = "1")]
    pub resource_name: ::prost::alloc::string::String,
}
/// Generated server implementations.
pub mod campaign_conversion_goal_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with CampaignConversionGoalServiceServer.
    #[async_trait]
    pub trait CampaignConversionGoalService: std::marker::Send + std::marker::Sync + 'static {
        /// Creates, updates or removes campaign conversion goals. Operation statuses
        /// are returned.
        async fn mutate_campaign_conversion_goals(
            &self,
            request: tonic::Request<super::MutateCampaignConversionGoalsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MutateCampaignConversionGoalsResponse>,
            tonic::Status,
        >;
    }
    /// Service to manage campaign conversion goal.
    #[derive(Debug)]
    pub struct CampaignConversionGoalServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> CampaignConversionGoalServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>>
    for CampaignConversionGoalServiceServer<T>
    where
        T: CampaignConversionGoalService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/google.ads.googleads.v16.services.CampaignConversionGoalService/MutateCampaignConversionGoals" => {
                    #[allow(non_camel_case_types)]
                    struct MutateCampaignConversionGoalsSvc<
                        T: CampaignConversionGoalService,
                    >(
                        pub Arc<T>,
                    );
                    impl<
                        T: CampaignConversionGoalService,
                    > tonic::server::UnaryService<
                        super::MutateCampaignConversionGoalsRequest,
                    > for MutateCampaignConversionGoalsSvc<T> {
                        type Response = super::MutateCampaignConversionGoalsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::MutateCampaignConversionGoalsRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as CampaignConversionGoalService>::mutate_campaign_conversion_goals(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = MutateCampaignConversionGoalsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for CampaignConversionGoalServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "google.ads.googleads.v16.services.CampaignConversionGoalService";
    impl<T> tonic::server::NamedService for CampaignConversionGoalServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Request message for
/// [CampaignCriterionService.MutateCampaignCriteria][google.ads.googleads.v16.services.CampaignCriterionService.MutateCampaignCriteria].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCampaignCriteriaRequest {
    /// Required. The ID of the customer whose criteria are being modified.
    #[prost(string, tag = "1")]
    pub customer_id: ::prost::alloc::string::String,
    /// Required. The list of operations to perform on individual criteria.
    #[prost(message, repeated, tag = "2")]
    pub operations: ::prost::alloc::vec::Vec<CampaignCriterionOperation>,
    /// If true, successful operations will be carried out and invalid
    /// operations will return errors. If false, all operations will be carried
    /// out in one transaction if and only if they are all valid.
    /// Default is false.
    #[prost(bool, tag = "3")]
    pub partial_failure: bool,
    /// If true, the request is validated but not executed. Only errors are
    /// returned, not results.
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
    /// The response content type setting. Determines whether the mutable resource
    /// or just the resource name should be returned post mutation.
    #[prost(
        enumeration = "super::enums::response_content_type_enum::ResponseContentType",
        tag = "5"
    )]
    pub response_content_type: i32,
}
/// A single operation (create, update, remove) on a campaign criterion.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CampaignCriterionOperation {
    /// FieldMask that determines which resource fields are modified in an update.
    #[prost(message, optional, tag = "4")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// The mutate operation.
    #[prost(oneof = "campaign_criterion_operation::Operation", tags = "1, 2, 3")]
    pub operation: ::core::option::Option<campaign_criterion_operation::Operation>,
}
/// Nested message and enum types in `CampaignCriterionOperation`.
pub mod campaign_criterion_operation {
    /// The mutate operation.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Operation {
        /// Create operation: No resource name is expected for the new criterion.
        #[prost(message, tag = "1")]
        Create(super::super::resources::CampaignCriterion),
        /// Update operation: The criterion is expected to have a valid resource
        /// name.
        #[prost(message, tag = "2")]
        Update(super::super::resources::CampaignCriterion),
        /// Remove operation: A resource name for the removed criterion is expected,
        /// in this format:
        ///
        /// `customers/{customer_id}/campaignCriteria/{campaign_id}~{criterion_id}`
        #[prost(string, tag = "3")]
        Remove(::prost::alloc::string::String),
    }
}
/// Response message for campaign criterion mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCampaignCriteriaResponse {
    /// Errors that pertain to operation failures in the partial failure mode.
    /// Returned only when partial_failure = true and all errors occur inside the
    /// operations. If any errors occur outside the operations (for example, auth
    /// errors), we return an RPC level error.
    #[prost(message, optional, tag = "3")]
    pub partial_failure_error: ::core::option::Option<
        super::super::super::super::rpc::Status,
    >,
    /// All results for the mutate.
    #[prost(message, repeated, tag = "2")]
    pub results: ::prost::alloc::vec::Vec<MutateCampaignCriterionResult>,
}
/// The result for the criterion mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCampaignCriterionResult {
    /// Returned for successful operations.
    #[prost(string, tag = "1")]
    pub resource_name: ::prost::alloc::string::String,
    /// The mutated campaign criterion with only mutable fields after mutate. The
    /// field will only be returned when response_content_type is set to
    /// "MUTABLE_RESOURCE".
    #[prost(message, optional, tag = "2")]
    pub campaign_criterion: ::core::option::Option<super::resources::CampaignCriterion>,
}
/// Generated server implementations.
pub mod campaign_criterion_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with CampaignCriterionServiceServer.
    #[async_trait]
    pub trait CampaignCriterionService: std::marker::Send + std::marker::Sync + 'static {
        /// Creates, updates, or removes criteria. Operation statuses are returned.
        ///
        /// List of thrown errors:
        ///   [AdxError]()
        ///   [AuthenticationError]()
        ///   [AuthorizationError]()
        ///   [CampaignCriterionError]()
        ///   [CollectionSizeError]()
        ///   [ContextError]()
        ///   [CriterionError]()
        ///   [DatabaseError]()
        ///   [DistinctError]()
        ///   [FieldError]()
        ///   [FieldMaskError]()
        ///   [FunctionError]()
        ///   [HeaderError]()
        ///   [IdError]()
        ///   [InternalError]()
        ///   [MutateError]()
        ///   [NewResourceCreationError]()
        ///   [NotEmptyError]()
        ///   [NullError]()
        ///   [OperationAccessDeniedError]()
        ///   [OperatorError]()
        ///   [QuotaError]()
        ///   [RangeError]()
        ///   [RegionCodeError]()
        ///   [RequestError]()
        ///   [ResourceCountLimitExceededError]()
        ///   [SizeLimitError]()
        ///   [StringFormatError]()
        ///   [StringLengthError]()
        async fn mutate_campaign_criteria(
            &self,
            request: tonic::Request<super::MutateCampaignCriteriaRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MutateCampaignCriteriaResponse>,
            tonic::Status,
        >;
    }
    /// Service to manage campaign criteria.
    #[derive(Debug)]
    pub struct CampaignCriterionServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> CampaignCriterionServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>>
    for CampaignCriterionServiceServer<T>
    where
        T: CampaignCriterionService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/google.ads.googleads.v16.services.CampaignCriterionService/MutateCampaignCriteria" => {
                    #[allow(non_camel_case_types)]
                    struct MutateCampaignCriteriaSvc<T: CampaignCriterionService>(
                        pub Arc<T>,
                    );
                    impl<
                        T: CampaignCriterionService,
                    > tonic::server::UnaryService<super::MutateCampaignCriteriaRequest>
                    for MutateCampaignCriteriaSvc<T> {
                        type Response = super::MutateCampaignCriteriaResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::MutateCampaignCriteriaRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as CampaignCriterionService>::mutate_campaign_criteria(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = MutateCampaignCriteriaSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for CampaignCriterionServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "google.ads.googleads.v16.services.CampaignCriterionService";
    impl<T> tonic::server::NamedService for CampaignCriterionServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Request message for
/// [CampaignCustomizerService.MutateCampaignCustomizers][google.ads.googleads.v16.services.CampaignCustomizerService.MutateCampaignCustomizers].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCampaignCustomizersRequest {
    /// Required. The ID of the customer whose campaign customizers are being
    /// modified.
    #[prost(string, tag = "1")]
    pub customer_id: ::prost::alloc::string::String,
    /// Required. The list of operations to perform on individual campaign
    /// customizers.
    #[prost(message, repeated, tag = "2")]
    pub operations: ::prost::alloc::vec::Vec<CampaignCustomizerOperation>,
    /// If true, successful operations will be carried out and invalid
    /// operations will return errors. If false, all operations will be carried
    /// out in one transaction if and only if they are all valid.
    /// Default is false.
    #[prost(bool, tag = "3")]
    pub partial_failure: bool,
    /// If true, the request is validated but not executed. Only errors are
    /// returned, not results.
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
    /// The response content type setting. Determines whether the mutable resource
    /// or just the resource name should be returned post mutation.
    #[prost(
        enumeration = "super::enums::response_content_type_enum::ResponseContentType",
        tag = "5"
    )]
    pub response_content_type: i32,
}
/// A single operation (create, remove) on a customizer attribute.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CampaignCustomizerOperation {
    /// The mutate operation.
    #[prost(oneof = "campaign_customizer_operation::Operation", tags = "1, 2")]
    pub operation: ::core::option::Option<campaign_customizer_operation::Operation>,
}
/// Nested message and enum types in `CampaignCustomizerOperation`.
pub mod campaign_customizer_operation {
    /// The mutate operation.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Operation {
        /// Create operation: No resource name is expected for the new campaign
        /// customizer
        #[prost(message, tag = "1")]
        Create(super::super::resources::CampaignCustomizer),
        /// Remove operation: A resource name for the removed campaign customizer is
        /// expected, in this format:
        /// `customers/{customer_id}/campaignCustomizers/{campaign_id}~{customizer_attribute_id}`
        #[prost(string, tag = "2")]
        Remove(::prost::alloc::string::String),
    }
}
/// Response message for a campaign customizer mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCampaignCustomizersResponse {
    /// All results for the mutate.
    #[prost(message, repeated, tag = "1")]
    pub results: ::prost::alloc::vec::Vec<MutateCampaignCustomizerResult>,
    /// Errors that pertain to operation failures in the partial failure mode.
    /// Returned only when partial_failure = true and all errors occur inside the
    /// operations. If any errors occur outside the operations (for example, auth
    /// errors), we return an RPC level error.
    #[prost(message, optional, tag = "2")]
    pub partial_failure_error: ::core::option::Option<
        super::super::super::super::rpc::Status,
    >,
}
/// The result for the campaign customizer mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCampaignCustomizerResult {
    /// Returned for successful operations.
    #[prost(string, tag = "1")]
    pub resource_name: ::prost::alloc::string::String,
    /// The mutated CampaignCustomizer with only mutable fields after mutate.
    /// The field will only be returned when response_content_type is set to
    /// "MUTABLE_RESOURCE".
    #[prost(message, optional, tag = "2")]
    pub campaign_customizer: ::core::option::Option<
        super::resources::CampaignCustomizer,
    >,
}
/// Generated server implementations.
pub mod campaign_customizer_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with CampaignCustomizerServiceServer.
    #[async_trait]
    pub trait CampaignCustomizerService: std::marker::Send + std::marker::Sync + 'static {
        /// Creates, updates or removes campaign customizers. Operation statuses are
        /// returned.
        async fn mutate_campaign_customizers(
            &self,
            request: tonic::Request<super::MutateCampaignCustomizersRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MutateCampaignCustomizersResponse>,
            tonic::Status,
        >;
    }
    /// Service to manage campaign customizer
    #[derive(Debug)]
    pub struct CampaignCustomizerServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> CampaignCustomizerServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>>
    for CampaignCustomizerServiceServer<T>
    where
        T: CampaignCustomizerService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/google.ads.googleads.v16.services.CampaignCustomizerService/MutateCampaignCustomizers" => {
                    #[allow(non_camel_case_types)]
                    struct MutateCampaignCustomizersSvc<T: CampaignCustomizerService>(
                        pub Arc<T>,
                    );
                    impl<
                        T: CampaignCustomizerService,
                    > tonic::server::UnaryService<
                        super::MutateCampaignCustomizersRequest,
                    > for MutateCampaignCustomizersSvc<T> {
                        type Response = super::MutateCampaignCustomizersResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::MutateCampaignCustomizersRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as CampaignCustomizerService>::mutate_campaign_customizers(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = MutateCampaignCustomizersSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for CampaignCustomizerServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "google.ads.googleads.v16.services.CampaignCustomizerService";
    impl<T> tonic::server::NamedService for CampaignCustomizerServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Request message for
/// [CampaignDraftService.MutateCampaignDrafts][google.ads.googleads.v16.services.CampaignDraftService.MutateCampaignDrafts].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCampaignDraftsRequest {
    /// Required. The ID of the customer whose campaign drafts are being modified.
    #[prost(string, tag = "1")]
    pub customer_id: ::prost::alloc::string::String,
    /// Required. The list of operations to perform on individual campaign drafts.
    #[prost(message, repeated, tag = "2")]
    pub operations: ::prost::alloc::vec::Vec<CampaignDraftOperation>,
    /// If true, successful operations will be carried out and invalid
    /// operations will return errors. If false, all operations will be carried
    /// out in one transaction if and only if they are all valid.
    /// Default is false.
    #[prost(bool, tag = "3")]
    pub partial_failure: bool,
    /// If true, the request is validated but not executed. Only errors are
    /// returned, not results.
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
    /// The response content type setting. Determines whether the mutable resource
    /// or just the resource name should be returned post mutation.
    #[prost(
        enumeration = "super::enums::response_content_type_enum::ResponseContentType",
        tag = "5"
    )]
    pub response_content_type: i32,
}
/// Request message for
/// [CampaignDraftService.PromoteCampaignDraft][google.ads.googleads.v16.services.CampaignDraftService.PromoteCampaignDraft].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PromoteCampaignDraftRequest {
    /// Required. The resource name of the campaign draft to promote.
    #[prost(string, tag = "1")]
    pub campaign_draft: ::prost::alloc::string::String,
    /// If true, the request is validated but no Long Running Operation is created.
    /// Only errors are returned.
    #[prost(bool, tag = "2")]
    pub validate_only: bool,
}
/// A single operation (create, update, remove) on a campaign draft.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CampaignDraftOperation {
    /// FieldMask that determines which resource fields are modified in an update.
    #[prost(message, optional, tag = "4")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// The mutate operation.
    #[prost(oneof = "campaign_draft_operation::Operation", tags = "1, 2, 3")]
    pub operation: ::core::option::Option<campaign_draft_operation::Operation>,
}
/// Nested message and enum types in `CampaignDraftOperation`.
pub mod campaign_draft_operation {
    /// The mutate operation.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Operation {
        /// Create operation: No resource name is expected for the new campaign
        /// draft.
        #[prost(message, tag = "1")]
        Create(super::super::resources::CampaignDraft),
        /// Update operation: The campaign draft is expected to have a valid
        /// resource name.
        #[prost(message, tag = "2")]
        Update(super::super::resources::CampaignDraft),
        /// Remove operation: The campaign draft is expected to have a valid
        /// resource name, in this format:
        ///
        /// `customers/{customer_id}/campaignDrafts/{base_campaign_id}~{draft_id}`
        #[prost(string, tag = "3")]
        Remove(::prost::alloc::string::String),
    }
}
/// Response message for campaign draft mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCampaignDraftsResponse {
    /// Errors that pertain to operation failures in the partial failure mode.
    /// Returned only when partial_failure = true and all errors occur inside the
    /// operations. If any errors occur outside the operations (for example, auth
    /// errors), we return an RPC level error.
    #[prost(message, optional, tag = "3")]
    pub partial_failure_error: ::core::option::Option<
        super::super::super::super::rpc::Status,
    >,
    /// All results for the mutate.
    #[prost(message, repeated, tag = "2")]
    pub results: ::prost::alloc::vec::Vec<MutateCampaignDraftResult>,
}
/// The result for the campaign draft mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCampaignDraftResult {
    /// Returned for successful operations.
    #[prost(string, tag = "1")]
    pub resource_name: ::prost::alloc::string::String,
    /// The mutated campaign draft with only mutable fields after mutate. The field
    /// will only be returned when response_content_type is set to
    /// "MUTABLE_RESOURCE".
    #[prost(message, optional, tag = "2")]
    pub campaign_draft: ::core::option::Option<super::resources::CampaignDraft>,
}
/// Request message for
/// [CampaignDraftService.ListCampaignDraftAsyncErrors][google.ads.googleads.v16.services.CampaignDraftService.ListCampaignDraftAsyncErrors].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListCampaignDraftAsyncErrorsRequest {
    /// Required. The name of the campaign draft from which to retrieve the async
    /// errors.
    #[prost(string, tag = "1")]
    pub resource_name: ::prost::alloc::string::String,
    /// Token of the page to retrieve. If not specified, the first
    /// page of results will be returned. Use the value obtained from
    /// `next_page_token` in the previous response in order to request
    /// the next page of results.
    #[prost(string, tag = "2")]
    pub page_token: ::prost::alloc::string::String,
    /// Number of elements to retrieve in a single page.
    /// When a page request is too large, the server may decide to
    /// further limit the number of returned resources.
    #[prost(int32, tag = "3")]
    pub page_size: i32,
}
/// Response message for
/// [CampaignDraftService.ListCampaignDraftAsyncErrors][google.ads.googleads.v16.services.CampaignDraftService.ListCampaignDraftAsyncErrors].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListCampaignDraftAsyncErrorsResponse {
    /// Details of the errors when performing the asynchronous operation.
    #[prost(message, repeated, tag = "1")]
    pub errors: ::prost::alloc::vec::Vec<super::super::super::super::rpc::Status>,
    /// Pagination token used to retrieve the next page of results.
    /// Pass the content of this string as the `page_token` attribute of
    /// the next request. `next_page_token` is not returned for the last
    /// page.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// Generated server implementations.
pub mod campaign_draft_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with CampaignDraftServiceServer.
    #[async_trait]
    pub trait CampaignDraftService: std::marker::Send + std::marker::Sync + 'static {
        /// Creates, updates, or removes campaign drafts. Operation statuses are
        /// returned.
        ///
        /// List of thrown errors:
        ///   [AuthenticationError]()
        ///   [AuthorizationError]()
        ///   [CampaignDraftError]()
        ///   [DatabaseError]()
        ///   [FieldError]()
        ///   [HeaderError]()
        ///   [InternalError]()
        ///   [MutateError]()
        ///   [QuotaError]()
        ///   [RequestError]()
        async fn mutate_campaign_drafts(
            &self,
            request: tonic::Request<super::MutateCampaignDraftsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MutateCampaignDraftsResponse>,
            tonic::Status,
        >;
        /// Promotes the changes in a draft back to the base campaign.
        ///
        /// This method returns a Long Running Operation (LRO) indicating if the
        /// Promote is done. Use [Operations.GetOperation] to poll the LRO until it
        /// is done. Only a done status is returned in the response. See the status
        /// in the Campaign Draft resource to determine if the promotion was
        /// successful. If the LRO failed, use
        /// [CampaignDraftService.ListCampaignDraftAsyncErrors][google.ads.googleads.v16.services.CampaignDraftService.ListCampaignDraftAsyncErrors]
        /// to view the list of error reasons.
        ///
        /// List of thrown errors:
        ///   [AuthenticationError]()
        ///   [AuthorizationError]()
        ///   [CampaignDraftError]()
        ///   [HeaderError]()
        ///   [InternalError]()
        ///   [QuotaError]()
        ///   [RequestError]()
        async fn promote_campaign_draft(
            &self,
            request: tonic::Request<super::PromoteCampaignDraftRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::super::longrunning::Operation>,
            tonic::Status,
        >;
        /// Returns all errors that occurred during CampaignDraft promote. Throws an
        /// error if called before campaign draft is promoted.
        /// Supports standard list paging.
        ///
        /// List of thrown errors:
        ///   [AuthenticationError]()
        ///   [AuthorizationError]()
        ///   [HeaderError]()
        ///   [InternalError]()
        ///   [QuotaError]()
        ///   [RequestError]()
        async fn list_campaign_draft_async_errors(
            &self,
            request: tonic::Request<super::ListCampaignDraftAsyncErrorsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListCampaignDraftAsyncErrorsResponse>,
            tonic::Status,
        >;
    }
    /// Service to manage campaign drafts.
    #[derive(Debug)]
    pub struct CampaignDraftServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> CampaignDraftServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>>
    for CampaignDraftServiceServer<T>
    where
        T: CampaignDraftService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/google.ads.googleads.v16.services.CampaignDraftService/MutateCampaignDrafts" => {
                    #[allow(non_camel_case_types)]
                    struct MutateCampaignDraftsSvc<T: CampaignDraftService>(pub Arc<T>);
                    impl<
                        T: CampaignDraftService,
                    > tonic::server::UnaryService<super::MutateCampaignDraftsRequest>
                    for MutateCampaignDraftsSvc<T> {
                        type Response = super::MutateCampaignDraftsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::MutateCampaignDraftsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as CampaignDraftService>::mutate_campaign_drafts(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = MutateCampaignDraftsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.ads.googleads.v16.services.CampaignDraftService/PromoteCampaignDraft" => {
                    #[allow(non_camel_case_types)]
                    struct PromoteCampaignDraftSvc<T: CampaignDraftService>(pub Arc<T>);
                    impl<
                        T: CampaignDraftService,
                    > tonic::server::UnaryService<super::PromoteCampaignDraftRequest>
                    for PromoteCampaignDraftSvc<T> {
                        type Response = super::super::super::super::super::longrunning::Operation;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::PromoteCampaignDraftRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as CampaignDraftService>::promote_campaign_draft(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = PromoteCampaignDraftSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.ads.googleads.v16.services.CampaignDraftService/ListCampaignDraftAsyncErrors" => {
                    #[allow(non_camel_case_types)]
                    struct ListCampaignDraftAsyncErrorsSvc<T: CampaignDraftService>(
                        pub Arc<T>,
                    );
                    impl<
                        T: CampaignDraftService,
                    > tonic::server::UnaryService<
                        super::ListCampaignDraftAsyncErrorsRequest,
                    > for ListCampaignDraftAsyncErrorsSvc<T> {
                        type Response = super::ListCampaignDraftAsyncErrorsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::ListCampaignDraftAsyncErrorsRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as CampaignDraftService>::list_campaign_draft_async_errors(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ListCampaignDraftAsyncErrorsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for CampaignDraftServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "google.ads.googleads.v16.services.CampaignDraftService";
    impl<T> tonic::server::NamedService for CampaignDraftServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Request message for
/// [CampaignExtensionSettingService.MutateCampaignExtensionSettings][google.ads.googleads.v16.services.CampaignExtensionSettingService.MutateCampaignExtensionSettings].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCampaignExtensionSettingsRequest {
    /// Required. The ID of the customer whose campaign extension settings are
    /// being modified.
    #[prost(string, tag = "1")]
    pub customer_id: ::prost::alloc::string::String,
    /// Required. The list of operations to perform on individual campaign
    /// extension settings.
    #[prost(message, repeated, tag = "2")]
    pub operations: ::prost::alloc::vec::Vec<CampaignExtensionSettingOperation>,
    /// If true, successful operations will be carried out and invalid
    /// operations will return errors. If false, all operations will be carried
    /// out in one transaction if and only if they are all valid.
    /// Default is false.
    #[prost(bool, tag = "3")]
    pub partial_failure: bool,
    /// If true, the request is validated but not executed. Only errors are
    /// returned, not results.
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
    /// The response content type setting. Determines whether the mutable resource
    /// or just the resource name should be returned post mutation.
    #[prost(
        enumeration = "super::enums::response_content_type_enum::ResponseContentType",
        tag = "5"
    )]
    pub response_content_type: i32,
}
/// A single operation (create, update, remove) on a campaign extension setting.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CampaignExtensionSettingOperation {
    /// FieldMask that determines which resource fields are modified in an update.
    #[prost(message, optional, tag = "4")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// The mutate operation.
    #[prost(oneof = "campaign_extension_setting_operation::Operation", tags = "1, 2, 3")]
    pub operation: ::core::option::Option<
        campaign_extension_setting_operation::Operation,
    >,
}
/// Nested message and enum types in `CampaignExtensionSettingOperation`.
pub mod campaign_extension_setting_operation {
    /// The mutate operation.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Operation {
        /// Create operation: No resource name is expected for the new campaign
        /// extension setting.
        #[prost(message, tag = "1")]
        Create(super::super::resources::CampaignExtensionSetting),
        /// Update operation: The campaign extension setting is expected to have a
        /// valid resource name.
        #[prost(message, tag = "2")]
        Update(super::super::resources::CampaignExtensionSetting),
        /// Remove operation: A resource name for the removed campaign extension
        /// setting is expected, in this format:
        ///
        /// `customers/{customer_id}/campaignExtensionSettings/{campaign_id}~{extension_type}`
        #[prost(string, tag = "3")]
        Remove(::prost::alloc::string::String),
    }
}
/// Response message for a campaign extension setting mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCampaignExtensionSettingsResponse {
    /// Errors that pertain to operation failures in the partial failure mode.
    /// Returned only when partial_failure = true and all errors occur inside the
    /// operations. If any errors occur outside the operations (for example, auth
    /// errors), we return an RPC level error.
    #[prost(message, optional, tag = "3")]
    pub partial_failure_error: ::core::option::Option<
        super::super::super::super::rpc::Status,
    >,
    /// All results for the mutate.
    #[prost(message, repeated, tag = "2")]
    pub results: ::prost::alloc::vec::Vec<MutateCampaignExtensionSettingResult>,
}
/// The result for the campaign extension setting mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCampaignExtensionSettingResult {
    /// Returned for successful operations.
    #[prost(string, tag = "1")]
    pub resource_name: ::prost::alloc::string::String,
    /// The mutated campaign extension setting with only mutable fields after
    /// mutate. The field will only be returned when response_content_type is set
    /// to "MUTABLE_RESOURCE".
    #[prost(message, optional, tag = "2")]
    pub campaign_extension_setting: ::core::option::Option<
        super::resources::CampaignExtensionSetting,
    >,
}
/// Generated server implementations.
pub mod campaign_extension_setting_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with CampaignExtensionSettingServiceServer.
    #[async_trait]
    pub trait CampaignExtensionSettingService: std::marker::Send + std::marker::Sync + 'static {
        /// Creates, updates, or removes campaign extension settings. Operation
        /// statuses are returned.
        ///
        /// List of thrown errors:
        ///   [AuthenticationError]()
        ///   [AuthorizationError]()
        ///   [CollectionSizeError]()
        ///   [CriterionError]()
        ///   [DatabaseError]()
        ///   [DateError]()
        ///   [DistinctError]()
        ///   [ExtensionSettingError]()
        ///   [FieldError]()
        ///   [FieldMaskError]()
        ///   [HeaderError]()
        ///   [IdError]()
        ///   [InternalError]()
        ///   [ListOperationError]()
        ///   [MutateError]()
        ///   [NewResourceCreationError]()
        ///   [NotEmptyError]()
        ///   [NullError]()
        ///   [OperationAccessDeniedError]()
        ///   [OperatorError]()
        ///   [QuotaError]()
        ///   [RangeError]()
        ///   [RequestError]()
        ///   [SizeLimitError]()
        ///   [StringFormatError]()
        ///   [StringLengthError]()
        ///   [UrlFieldError]()
        async fn mutate_campaign_extension_settings(
            &self,
            request: tonic::Request<super::MutateCampaignExtensionSettingsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MutateCampaignExtensionSettingsResponse>,
            tonic::Status,
        >;
    }
    /// Service to manage campaign extension settings.
    #[derive(Debug)]
    pub struct CampaignExtensionSettingServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> CampaignExtensionSettingServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>>
    for CampaignExtensionSettingServiceServer<T>
    where
        T: CampaignExtensionSettingService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/google.ads.googleads.v16.services.CampaignExtensionSettingService/MutateCampaignExtensionSettings" => {
                    #[allow(non_camel_case_types)]
                    struct MutateCampaignExtensionSettingsSvc<
                        T: CampaignExtensionSettingService,
                    >(
                        pub Arc<T>,
                    );
                    impl<
                        T: CampaignExtensionSettingService,
                    > tonic::server::UnaryService<
                        super::MutateCampaignExtensionSettingsRequest,
                    > for MutateCampaignExtensionSettingsSvc<T> {
                        type Response = super::MutateCampaignExtensionSettingsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::MutateCampaignExtensionSettingsRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as CampaignExtensionSettingService>::mutate_campaign_extension_settings(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = MutateCampaignExtensionSettingsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for CampaignExtensionSettingServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "google.ads.googleads.v16.services.CampaignExtensionSettingService";
    impl<T> tonic::server::NamedService for CampaignExtensionSettingServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Request message for
/// [CampaignFeedService.MutateCampaignFeeds][google.ads.googleads.v16.services.CampaignFeedService.MutateCampaignFeeds].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCampaignFeedsRequest {
    /// Required. The ID of the customer whose campaign feeds are being modified.
    #[prost(string, tag = "1")]
    pub customer_id: ::prost::alloc::string::String,
    /// Required. The list of operations to perform on individual campaign feeds.
    #[prost(message, repeated, tag = "2")]
    pub operations: ::prost::alloc::vec::Vec<CampaignFeedOperation>,
    /// If true, successful operations will be carried out and invalid
    /// operations will return errors. If false, all operations will be carried
    /// out in one transaction if and only if they are all valid.
    /// Default is false.
    #[prost(bool, tag = "3")]
    pub partial_failure: bool,
    /// If true, the request is validated but not executed. Only errors are
    /// returned, not results.
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
    /// The response content type setting. Determines whether the mutable resource
    /// or just the resource name should be returned post mutation.
    #[prost(
        enumeration = "super::enums::response_content_type_enum::ResponseContentType",
        tag = "5"
    )]
    pub response_content_type: i32,
}
/// A single operation (create, update, remove) on a campaign feed.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CampaignFeedOperation {
    /// FieldMask that determines which resource fields are modified in an update.
    #[prost(message, optional, tag = "4")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// The mutate operation.
    #[prost(oneof = "campaign_feed_operation::Operation", tags = "1, 2, 3")]
    pub operation: ::core::option::Option<campaign_feed_operation::Operation>,
}
/// Nested message and enum types in `CampaignFeedOperation`.
pub mod campaign_feed_operation {
    /// The mutate operation.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Operation {
        /// Create operation: No resource name is expected for the new campaign feed.
        #[prost(message, tag = "1")]
        Create(super::super::resources::CampaignFeed),
        /// Update operation: The campaign feed is expected to have a valid resource
        /// name.
        #[prost(message, tag = "2")]
        Update(super::super::resources::CampaignFeed),
        /// Remove operation: A resource name for the removed campaign feed is
        /// expected, in this format:
        ///
        /// `customers/{customer_id}/campaignFeeds/{campaign_id}~{feed_id}`
        #[prost(string, tag = "3")]
        Remove(::prost::alloc::string::String),
    }
}
/// Response message for a campaign feed mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCampaignFeedsResponse {
    /// Errors that pertain to operation failures in the partial failure mode.
    /// Returned only when partial_failure = true and all errors occur inside the
    /// operations. If any errors occur outside the operations (for example, auth
    /// errors), we return an RPC level error.
    #[prost(message, optional, tag = "3")]
    pub partial_failure_error: ::core::option::Option<
        super::super::super::super::rpc::Status,
    >,
    /// All results for the mutate.
    #[prost(message, repeated, tag = "2")]
    pub results: ::prost::alloc::vec::Vec<MutateCampaignFeedResult>,
}
/// The result for the campaign feed mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCampaignFeedResult {
    /// Returned for successful operations.
    #[prost(string, tag = "1")]
    pub resource_name: ::prost::alloc::string::String,
    /// The mutated campaign feed with only mutable fields after mutate. The field
    /// will only be returned when response_content_type is set to
    /// "MUTABLE_RESOURCE".
    #[prost(message, optional, tag = "2")]
    pub campaign_feed: ::core::option::Option<super::resources::CampaignFeed>,
}
/// Generated server implementations.
pub mod campaign_feed_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with CampaignFeedServiceServer.
    #[async_trait]
    pub trait CampaignFeedService: std::marker::Send + std::marker::Sync + 'static {
        /// Creates, updates, or removes campaign feeds. Operation statuses are
        /// returned.
        ///
        /// List of thrown errors:
        ///   [AuthenticationError]()
        ///   [AuthorizationError]()
        ///   [CampaignFeedError]()
        ///   [CollectionSizeError]()
        ///   [DatabaseError]()
        ///   [DistinctError]()
        ///   [FieldError]()
        ///   [FunctionError]()
        ///   [FunctionParsingError]()
        ///   [HeaderError]()
        ///   [IdError]()
        ///   [InternalError]()
        ///   [MutateError]()
        ///   [NotEmptyError]()
        ///   [NullError]()
        ///   [OperationAccessDeniedError]()
        ///   [OperatorError]()
        ///   [QuotaError]()
        ///   [RangeError]()
        ///   [RequestError]()
        ///   [SizeLimitError]()
        ///   [StringFormatError]()
        ///   [StringLengthError]()
        async fn mutate_campaign_feeds(
            &self,
            request: tonic::Request<super::MutateCampaignFeedsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MutateCampaignFeedsResponse>,
            tonic::Status,
        >;
    }
    /// Service to manage campaign feeds.
    #[derive(Debug)]
    pub struct CampaignFeedServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> CampaignFeedServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for CampaignFeedServiceServer<T>
    where
        T: CampaignFeedService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/google.ads.googleads.v16.services.CampaignFeedService/MutateCampaignFeeds" => {
                    #[allow(non_camel_case_types)]
                    struct MutateCampaignFeedsSvc<T: CampaignFeedService>(pub Arc<T>);
                    impl<
                        T: CampaignFeedService,
                    > tonic::server::UnaryService<super::MutateCampaignFeedsRequest>
                    for MutateCampaignFeedsSvc<T> {
                        type Response = super::MutateCampaignFeedsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::MutateCampaignFeedsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as CampaignFeedService>::mutate_campaign_feeds(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = MutateCampaignFeedsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for CampaignFeedServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "google.ads.googleads.v16.services.CampaignFeedService";
    impl<T> tonic::server::NamedService for CampaignFeedServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Request message for
/// [CampaignGroupService.MutateCampaignGroups][google.ads.googleads.v16.services.CampaignGroupService.MutateCampaignGroups].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCampaignGroupsRequest {
    /// Required. The ID of the customer whose campaign groups are being modified.
    #[prost(string, tag = "1")]
    pub customer_id: ::prost::alloc::string::String,
    /// Required. The list of operations to perform on individual campaign groups.
    #[prost(message, repeated, tag = "2")]
    pub operations: ::prost::alloc::vec::Vec<CampaignGroupOperation>,
    /// If true, successful operations will be carried out and invalid
    /// operations will return errors. If false, all operations will be carried
    /// out in one transaction if and only if they are all valid.
    /// Default is false.
    #[prost(bool, tag = "3")]
    pub partial_failure: bool,
    /// If true, the request is validated but not executed. Only errors are
    /// returned, not results.
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
    /// The response content type setting. Determines whether the mutable resource
    /// or just the resource name should be returned post mutation.
    #[prost(
        enumeration = "super::enums::response_content_type_enum::ResponseContentType",
        tag = "5"
    )]
    pub response_content_type: i32,
}
/// A single operation (create, update, remove) on a campaign group.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CampaignGroupOperation {
    /// FieldMask that determines which resource fields are modified in an update.
    #[prost(message, optional, tag = "4")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// The mutate operation.
    #[prost(oneof = "campaign_group_operation::Operation", tags = "1, 2, 3")]
    pub operation: ::core::option::Option<campaign_group_operation::Operation>,
}
/// Nested message and enum types in `CampaignGroupOperation`.
pub mod campaign_group_operation {
    /// The mutate operation.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Operation {
        /// Create operation: No resource name is expected for the new campaign
        /// group.
        #[prost(message, tag = "1")]
        Create(super::super::resources::CampaignGroup),
        /// Update operation: The campaign group is expected to have a valid
        /// resource name.
        #[prost(message, tag = "2")]
        Update(super::super::resources::CampaignGroup),
        /// Remove operation: A resource name for the removed campaign group is
        /// expected, in this format:
        ///
        /// `customers/{customer_id}/campaignGroups/{campaign_group_id}`
        #[prost(string, tag = "3")]
        Remove(::prost::alloc::string::String),
    }
}
/// Response message for campaign group mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCampaignGroupsResponse {
    /// All results for the mutate.
    #[prost(message, repeated, tag = "2")]
    pub results: ::prost::alloc::vec::Vec<MutateCampaignGroupResult>,
    /// Errors that pertain to operation failures in the partial failure mode.
    /// Returned only when partial_failure = true and all errors occur inside the
    /// operations. If any errors occur outside the operations (for example, auth
    /// errors), we return an RPC level error.
    #[prost(message, optional, tag = "3")]
    pub partial_failure_error: ::core::option::Option<
        super::super::super::super::rpc::Status,
    >,
}
/// The result for the campaign group mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCampaignGroupResult {
    /// Required. Returned for successful operations.
    #[prost(string, tag = "1")]
    pub resource_name: ::prost::alloc::string::String,
    /// The mutated campaign group with only mutable fields after mutate. The field
    /// will only be returned when response_content_type is set to
    /// "MUTABLE_RESOURCE".
    #[prost(message, optional, tag = "2")]
    pub campaign_group: ::core::option::Option<super::resources::CampaignGroup>,
}
/// Generated server implementations.
pub mod campaign_group_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with CampaignGroupServiceServer.
    #[async_trait]
    pub trait CampaignGroupService: std::marker::Send + std::marker::Sync + 'static {
        /// Creates, updates, or removes campaign groups. Operation statuses are
        /// returned.
        async fn mutate_campaign_groups(
            &self,
            request: tonic::Request<super::MutateCampaignGroupsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MutateCampaignGroupsResponse>,
            tonic::Status,
        >;
    }
    /// Service to manage campaign groups.
    #[derive(Debug)]
    pub struct CampaignGroupServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> CampaignGroupServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>>
    for CampaignGroupServiceServer<T>
    where
        T: CampaignGroupService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/google.ads.googleads.v16.services.CampaignGroupService/MutateCampaignGroups" => {
                    #[allow(non_camel_case_types)]
                    struct MutateCampaignGroupsSvc<T: CampaignGroupService>(pub Arc<T>);
                    impl<
                        T: CampaignGroupService,
                    > tonic::server::UnaryService<super::MutateCampaignGroupsRequest>
                    for MutateCampaignGroupsSvc<T> {
                        type Response = super::MutateCampaignGroupsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::MutateCampaignGroupsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as CampaignGroupService>::mutate_campaign_groups(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = MutateCampaignGroupsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for CampaignGroupServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "google.ads.googleads.v16.services.CampaignGroupService";
    impl<T> tonic::server::NamedService for CampaignGroupServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Request message for
/// [CampaignLabelService.MutateCampaignLabels][google.ads.googleads.v16.services.CampaignLabelService.MutateCampaignLabels].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCampaignLabelsRequest {
    /// Required. ID of the customer whose campaign-label relationships are being
    /// modified.
    #[prost(string, tag = "1")]
    pub customer_id: ::prost::alloc::string::String,
    /// Required. The list of operations to perform on campaign-label
    /// relationships.
    #[prost(message, repeated, tag = "2")]
    pub operations: ::prost::alloc::vec::Vec<CampaignLabelOperation>,
    /// If true, successful operations will be carried out and invalid
    /// operations will return errors. If false, all operations will be carried
    /// out in one transaction if and only if they are all valid.
    /// Default is false.
    #[prost(bool, tag = "3")]
    pub partial_failure: bool,
    /// If true, the request is validated but not executed. Only errors are
    /// returned, not results.
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
}
/// A single operation (create, remove) on a campaign-label relationship.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CampaignLabelOperation {
    /// The mutate operation.
    #[prost(oneof = "campaign_label_operation::Operation", tags = "1, 2")]
    pub operation: ::core::option::Option<campaign_label_operation::Operation>,
}
/// Nested message and enum types in `CampaignLabelOperation`.
pub mod campaign_label_operation {
    /// The mutate operation.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Operation {
        /// Create operation: No resource name is expected for the new campaign-label
        /// relationship.
        #[prost(message, tag = "1")]
        Create(super::super::resources::CampaignLabel),
        /// Remove operation: A resource name for the campaign-label relationship
        /// being removed, in this format:
        ///
        /// `customers/{customer_id}/campaignLabels/{campaign_id}~{label_id}`
        #[prost(string, tag = "2")]
        Remove(::prost::alloc::string::String),
    }
}
/// Response message for a campaign labels mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCampaignLabelsResponse {
    /// Errors that pertain to operation failures in the partial failure mode.
    /// Returned only when partial_failure = true and all errors occur inside the
    /// operations. If any errors occur outside the operations (for example, auth
    /// errors), we return an RPC level error.
    #[prost(message, optional, tag = "3")]
    pub partial_failure_error: ::core::option::Option<
        super::super::super::super::rpc::Status,
    >,
    /// All results for the mutate.
    #[prost(message, repeated, tag = "2")]
    pub results: ::prost::alloc::vec::Vec<MutateCampaignLabelResult>,
}
/// The result for a campaign label mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCampaignLabelResult {
    /// Returned for successful operations.
    #[prost(string, tag = "1")]
    pub resource_name: ::prost::alloc::string::String,
}
/// Generated server implementations.
pub mod campaign_label_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with CampaignLabelServiceServer.
    #[async_trait]
    pub trait CampaignLabelService: std::marker::Send + std::marker::Sync + 'static {
        /// Creates and removes campaign-label relationships.
        /// Operation statuses are returned.
        ///
        /// List of thrown errors:
        ///   [AuthenticationError]()
        ///   [AuthorizationError]()
        ///   [DatabaseError]()
        ///   [FieldError]()
        ///   [HeaderError]()
        ///   [InternalError]()
        ///   [LabelError]()
        ///   [MutateError]()
        ///   [NewResourceCreationError]()
        ///   [QuotaError]()
        ///   [RequestError]()
        async fn mutate_campaign_labels(
            &self,
            request: tonic::Request<super::MutateCampaignLabelsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MutateCampaignLabelsResponse>,
            tonic::Status,
        >;
    }
    /// Service to manage labels on campaigns.
    #[derive(Debug)]
    pub struct CampaignLabelServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> CampaignLabelServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>>
    for CampaignLabelServiceServer<T>
    where
        T: CampaignLabelService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/google.ads.googleads.v16.services.CampaignLabelService/MutateCampaignLabels" => {
                    #[allow(non_camel_case_types)]
                    struct MutateCampaignLabelsSvc<T: CampaignLabelService>(pub Arc<T>);
                    impl<
                        T: CampaignLabelService,
                    > tonic::server::UnaryService<super::MutateCampaignLabelsRequest>
                    for MutateCampaignLabelsSvc<T> {
                        type Response = super::MutateCampaignLabelsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::MutateCampaignLabelsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as CampaignLabelService>::mutate_campaign_labels(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = MutateCampaignLabelsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for CampaignLabelServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "google.ads.googleads.v16.services.CampaignLabelService";
    impl<T> tonic::server::NamedService for CampaignLabelServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Request message for
/// [CampaignService.MutateCampaigns][google.ads.googleads.v16.services.CampaignService.MutateCampaigns].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCampaignsRequest {
    /// Required. The ID of the customer whose campaigns are being modified.
    #[prost(string, tag = "1")]
    pub customer_id: ::prost::alloc::string::String,
    /// Required. The list of operations to perform on individual campaigns.
    #[prost(message, repeated, tag = "2")]
    pub operations: ::prost::alloc::vec::Vec<CampaignOperation>,
    /// If true, successful operations will be carried out and invalid
    /// operations will return errors. If false, all operations will be carried
    /// out in one transaction if and only if they are all valid.
    /// Default is false.
    #[prost(bool, tag = "3")]
    pub partial_failure: bool,
    /// If true, the request is validated but not executed. Only errors are
    /// returned, not results.
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
    /// The response content type setting. Determines whether the mutable resource
    /// or just the resource name should be returned post mutation.
    #[prost(
        enumeration = "super::enums::response_content_type_enum::ResponseContentType",
        tag = "5"
    )]
    pub response_content_type: i32,
}
/// A single operation (create, update, remove) on a campaign.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CampaignOperation {
    /// FieldMask that determines which resource fields are modified in an update.
    #[prost(message, optional, tag = "4")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// The mutate operation.
    #[prost(oneof = "campaign_operation::Operation", tags = "1, 2, 3")]
    pub operation: ::core::option::Option<campaign_operation::Operation>,
}
/// Nested message and enum types in `CampaignOperation`.
pub mod campaign_operation {
    /// The mutate operation.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Operation {
        /// Create operation: No resource name is expected for the new campaign.
        #[prost(message, tag = "1")]
        Create(super::super::resources::Campaign),
        /// Update operation: The campaign is expected to have a valid
        /// resource name.
        #[prost(message, tag = "2")]
        Update(super::super::resources::Campaign),
        /// Remove operation: A resource name for the removed campaign is
        /// expected, in this format:
        ///
        /// `customers/{customer_id}/campaigns/{campaign_id}`
        #[prost(string, tag = "3")]
        Remove(::prost::alloc::string::String),
    }
}
/// Response message for campaign mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCampaignsResponse {
    /// Errors that pertain to operation failures in the partial failure mode.
    /// Returned only when partial_failure = true and all errors occur inside the
    /// operations. If any errors occur outside the operations (for example, auth
    /// errors), we return an RPC level error.
    #[prost(message, optional, tag = "3")]
    pub partial_failure_error: ::core::option::Option<
        super::super::super::super::rpc::Status,
    >,
    /// All results for the mutate.
    #[prost(message, repeated, tag = "2")]
    pub results: ::prost::alloc::vec::Vec<MutateCampaignResult>,
}
/// The result for the campaign mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCampaignResult {
    /// Returned for successful operations.
    #[prost(string, tag = "1")]
    pub resource_name: ::prost::alloc::string::String,
    /// The mutated campaign with only mutable fields after mutate. The field will
    /// only be returned when response_content_type is set to "MUTABLE_RESOURCE".
    #[prost(message, optional, tag = "2")]
    pub campaign: ::core::option::Option<super::resources::Campaign>,
}
/// Generated server implementations.
pub mod campaign_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with CampaignServiceServer.
    #[async_trait]
    pub trait CampaignService: std::marker::Send + std::marker::Sync + 'static {
        /// Creates, updates, or removes campaigns. Operation statuses are returned.
        ///
        /// List of thrown errors:
        ///   [AdxError]()
        ///   [AuthenticationError]()
        ///   [AuthorizationError]()
        ///   [BiddingError]()
        ///   [BiddingStrategyError]()
        ///   [CampaignBudgetError]()
        ///   [CampaignError]()
        ///   [ContextError]()
        ///   [DatabaseError]()
        ///   [DateError]()
        ///   [DateRangeError]()
        ///   [DistinctError]()
        ///   [FieldError]()
        ///   [FieldMaskError]()
        ///   [HeaderError]()
        ///   [IdError]()
        ///   [InternalError]()
        ///   [ListOperationError]()
        ///   [MutateError]()
        ///   [NewResourceCreationError]()
        ///   [NotAllowlistedError]()
        ///   [NotEmptyError]()
        ///   [NullError]()
        ///   [OperationAccessDeniedError]()
        ///   [OperatorError]()
        ///   [QuotaError]()
        ///   [RangeError]()
        ///   [RegionCodeError]()
        ///   [RequestError]()
        ///   [ResourceCountLimitExceededError]()
        ///   [SettingError]()
        ///   [SizeLimitError]()
        ///   [StringFormatError]()
        ///   [StringLengthError]()
        ///   [UrlFieldError]()
        async fn mutate_campaigns(
            &self,
            request: tonic::Request<super::MutateCampaignsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MutateCampaignsResponse>,
            tonic::Status,
        >;
    }
    /// Service to manage campaigns.
    #[derive(Debug)]
    pub struct CampaignServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> CampaignServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for CampaignServiceServer<T>
    where
        T: CampaignService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/google.ads.googleads.v16.services.CampaignService/MutateCampaigns" => {
                    #[allow(non_camel_case_types)]
                    struct MutateCampaignsSvc<T: CampaignService>(pub Arc<T>);
                    impl<
                        T: CampaignService,
                    > tonic::server::UnaryService<super::MutateCampaignsRequest>
                    for MutateCampaignsSvc<T> {
                        type Response = super::MutateCampaignsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::MutateCampaignsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as CampaignService>::mutate_campaigns(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = MutateCampaignsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for CampaignServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "google.ads.googleads.v16.services.CampaignService";
    impl<T> tonic::server::NamedService for CampaignServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Request message for
/// [CampaignSharedSetService.MutateCampaignSharedSets][google.ads.googleads.v16.services.CampaignSharedSetService.MutateCampaignSharedSets].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCampaignSharedSetsRequest {
    /// Required. The ID of the customer whose campaign shared sets are being
    /// modified.
    #[prost(string, tag = "1")]
    pub customer_id: ::prost::alloc::string::String,
    /// Required. The list of operations to perform on individual campaign shared
    /// sets.
    #[prost(message, repeated, tag = "2")]
    pub operations: ::prost::alloc::vec::Vec<CampaignSharedSetOperation>,
    /// If true, successful operations will be carried out and invalid
    /// operations will return errors. If false, all operations will be carried
    /// out in one transaction if and only if they are all valid.
    /// Default is false.
    #[prost(bool, tag = "3")]
    pub partial_failure: bool,
    /// If true, the request is validated but not executed. Only errors are
    /// returned, not results.
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
    /// The response content type setting. Determines whether the mutable resource
    /// or just the resource name should be returned post mutation.
    #[prost(
        enumeration = "super::enums::response_content_type_enum::ResponseContentType",
        tag = "5"
    )]
    pub response_content_type: i32,
}
/// A single operation (create, remove) on a campaign shared set.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CampaignSharedSetOperation {
    /// The mutate operation.
    #[prost(oneof = "campaign_shared_set_operation::Operation", tags = "1, 3")]
    pub operation: ::core::option::Option<campaign_shared_set_operation::Operation>,
}
/// Nested message and enum types in `CampaignSharedSetOperation`.
pub mod campaign_shared_set_operation {
    /// The mutate operation.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Operation {
        /// Create operation: No resource name is expected for the new campaign
        /// shared set.
        #[prost(message, tag = "1")]
        Create(super::super::resources::CampaignSharedSet),
        /// Remove operation: A resource name for the removed campaign shared set is
        /// expected, in this format:
        ///
        /// `customers/{customer_id}/campaignSharedSets/{campaign_id}~{shared_set_id}`
        #[prost(string, tag = "3")]
        Remove(::prost::alloc::string::String),
    }
}
/// Response message for a campaign shared set mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCampaignSharedSetsResponse {
    /// Errors that pertain to operation failures in the partial failure mode.
    /// Returned only when partial_failure = true and all errors occur inside the
    /// operations. If any errors occur outside the operations (for example, auth
    /// errors), we return an RPC level error.
    #[prost(message, optional, tag = "3")]
    pub partial_failure_error: ::core::option::Option<
        super::super::super::super::rpc::Status,
    >,
    /// All results for the mutate.
    #[prost(message, repeated, tag = "2")]
    pub results: ::prost::alloc::vec::Vec<MutateCampaignSharedSetResult>,
}
/// The result for the campaign shared set mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCampaignSharedSetResult {
    /// Returned for successful operations.
    #[prost(string, tag = "1")]
    pub resource_name: ::prost::alloc::string::String,
    /// The mutated campaign shared set with only mutable fields after mutate. The
    /// field will only be returned when response_content_type is set to
    /// "MUTABLE_RESOURCE".
    #[prost(message, optional, tag = "2")]
    pub campaign_shared_set: ::core::option::Option<super::resources::CampaignSharedSet>,
}
/// Generated server implementations.
pub mod campaign_shared_set_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with CampaignSharedSetServiceServer.
    #[async_trait]
    pub trait CampaignSharedSetService: std::marker::Send + std::marker::Sync + 'static {
        /// Creates or removes campaign shared sets. Operation statuses are returned.
        ///
        /// List of thrown errors:
        ///   [AuthenticationError]()
        ///   [AuthorizationError]()
        ///   [CampaignSharedSetError]()
        ///   [ContextError]()
        ///   [DatabaseError]()
        ///   [DateError]()
        ///   [DistinctError]()
        ///   [FieldError]()
        ///   [HeaderError]()
        ///   [IdError]()
        ///   [InternalError]()
        ///   [MutateError]()
        ///   [NewResourceCreationError]()
        ///   [NotEmptyError]()
        ///   [NullError]()
        ///   [OperatorError]()
        ///   [QuotaError]()
        ///   [RangeError]()
        ///   [RequestError]()
        ///   [SizeLimitError]()
        ///   [StringFormatError]()
        ///   [StringLengthError]()
        async fn mutate_campaign_shared_sets(
            &self,
            request: tonic::Request<super::MutateCampaignSharedSetsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MutateCampaignSharedSetsResponse>,
            tonic::Status,
        >;
    }
    /// Service to manage campaign shared sets.
    #[derive(Debug)]
    pub struct CampaignSharedSetServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> CampaignSharedSetServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>>
    for CampaignSharedSetServiceServer<T>
    where
        T: CampaignSharedSetService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/google.ads.googleads.v16.services.CampaignSharedSetService/MutateCampaignSharedSets" => {
                    #[allow(non_camel_case_types)]
                    struct MutateCampaignSharedSetsSvc<T: CampaignSharedSetService>(
                        pub Arc<T>,
                    );
                    impl<
                        T: CampaignSharedSetService,
                    > tonic::server::UnaryService<super::MutateCampaignSharedSetsRequest>
                    for MutateCampaignSharedSetsSvc<T> {
                        type Response = super::MutateCampaignSharedSetsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::MutateCampaignSharedSetsRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as CampaignSharedSetService>::mutate_campaign_shared_sets(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = MutateCampaignSharedSetsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for CampaignSharedSetServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "google.ads.googleads.v16.services.CampaignSharedSetService";
    impl<T> tonic::server::NamedService for CampaignSharedSetServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Request message for
/// [ConversionActionService.MutateConversionActions][google.ads.googleads.v16.services.ConversionActionService.MutateConversionActions].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateConversionActionsRequest {
    /// Required. The ID of the customer whose conversion actions are being
    /// modified.
    #[prost(string, tag = "1")]
    pub customer_id: ::prost::alloc::string::String,
    /// Required. The list of operations to perform on individual conversion
    /// actions.
    #[prost(message, repeated, tag = "2")]
    pub operations: ::prost::alloc::vec::Vec<ConversionActionOperation>,
    /// If true, successful operations will be carried out and invalid
    /// operations will return errors. If false, all operations will be carried
    /// out in one transaction if and only if they are all valid.
    /// Default is false.
    #[prost(bool, tag = "3")]
    pub partial_failure: bool,
    /// If true, the request is validated but not executed. Only errors are
    /// returned, not results.
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
    /// The response content type setting. Determines whether the mutable resource
    /// or just the resource name should be returned post mutation.
    #[prost(
        enumeration = "super::enums::response_content_type_enum::ResponseContentType",
        tag = "5"
    )]
    pub response_content_type: i32,
}
/// A single operation (create, update, remove) on a conversion action.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConversionActionOperation {
    /// FieldMask that determines which resource fields are modified in an update.
    #[prost(message, optional, tag = "4")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// The mutate operation.
    #[prost(oneof = "conversion_action_operation::Operation", tags = "1, 2, 3")]
    pub operation: ::core::option::Option<conversion_action_operation::Operation>,
}
/// Nested message and enum types in `ConversionActionOperation`.
pub mod conversion_action_operation {
    /// The mutate operation.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Operation {
        /// Create operation: No resource name is expected for the new conversion
        /// action.
        #[prost(message, tag = "1")]
        Create(super::super::resources::ConversionAction),
        /// Update operation: The conversion action is expected to have a valid
        /// resource name.
        #[prost(message, tag = "2")]
        Update(super::super::resources::ConversionAction),
        /// Remove operation: A resource name for the removed conversion action is
        /// expected, in this format:
        ///
        /// `customers/{customer_id}/conversionActions/{conversion_action_id}`
        #[prost(string, tag = "3")]
        Remove(::prost::alloc::string::String),
    }
}
/// Response message for
/// [ConversionActionService.MutateConversionActions][google.ads.googleads.v16.services.ConversionActionService.MutateConversionActions].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateConversionActionsResponse {
    /// Errors that pertain to operation failures in the partial failure mode.
    /// Returned only when partial_failure = true and all errors occur inside the
    /// operations. If any errors occur outside the operations (for example, auth
    /// errors), we return an RPC level error.
    #[prost(message, optional, tag = "3")]
    pub partial_failure_error: ::core::option::Option<
        super::super::super::super::rpc::Status,
    >,
    /// All results for the mutate.
    #[prost(message, repeated, tag = "2")]
    pub results: ::prost::alloc::vec::Vec<MutateConversionActionResult>,
}
/// The result for the conversion action mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateConversionActionResult {
    /// Returned for successful operations.
    #[prost(string, tag = "1")]
    pub resource_name: ::prost::alloc::string::String,
    /// The mutated conversion action with only mutable fields after mutate. The
    /// field will only be returned when response_content_type is set to
    /// "MUTABLE_RESOURCE".
    #[prost(message, optional, tag = "2")]
    pub conversion_action: ::core::option::Option<super::resources::ConversionAction>,
}
/// Generated server implementations.
pub mod conversion_action_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with ConversionActionServiceServer.
    #[async_trait]
    pub trait ConversionActionService: std::marker::Send + std::marker::Sync + 'static {
        /// Creates, updates or removes conversion actions. Operation statuses are
        /// returned.
        ///
        /// List of thrown errors:
        ///   [AuthenticationError]()
        ///   [AuthorizationError]()
        ///   [ConversionActionError]()
        ///   [CurrencyCodeError]()
        ///   [DatabaseError]()
        ///   [FieldError]()
        ///   [FieldMaskError]()
        ///   [HeaderError]()
        ///   [InternalError]()
        ///   [MutateError]()
        ///   [NewResourceCreationError]()
        ///   [QuotaError]()
        ///   [RangeError]()
        ///   [RequestError]()
        ///   [ResourceCountLimitExceededError]()
        ///   [StringLengthError]()
        async fn mutate_conversion_actions(
            &self,
            request: tonic::Request<super::MutateConversionActionsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MutateConversionActionsResponse>,
            tonic::Status,
        >;
    }
    /// Service to manage conversion actions.
    #[derive(Debug)]
    pub struct ConversionActionServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> ConversionActionServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>>
    for ConversionActionServiceServer<T>
    where
        T: ConversionActionService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/google.ads.googleads.v16.services.ConversionActionService/MutateConversionActions" => {
                    #[allow(non_camel_case_types)]
                    struct MutateConversionActionsSvc<T: ConversionActionService>(
                        pub Arc<T>,
                    );
                    impl<
                        T: ConversionActionService,
                    > tonic::server::UnaryService<super::MutateConversionActionsRequest>
                    for MutateConversionActionsSvc<T> {
                        type Response = super::MutateConversionActionsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::MutateConversionActionsRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ConversionActionService>::mutate_conversion_actions(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = MutateConversionActionsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for ConversionActionServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "google.ads.googleads.v16.services.ConversionActionService";
    impl<T> tonic::server::NamedService for ConversionActionServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Request message for
/// [ConversionCustomVariableService.MutateConversionCustomVariables][google.ads.googleads.v16.services.ConversionCustomVariableService.MutateConversionCustomVariables].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateConversionCustomVariablesRequest {
    /// Required. The ID of the customer whose conversion custom variables are
    /// being modified.
    #[prost(string, tag = "1")]
    pub customer_id: ::prost::alloc::string::String,
    /// Required. The list of operations to perform on individual conversion custom
    /// variables.
    #[prost(message, repeated, tag = "2")]
    pub operations: ::prost::alloc::vec::Vec<ConversionCustomVariableOperation>,
    /// If true, successful operations will be carried out and invalid
    /// operations will return errors. If false, all operations will be carried
    /// out in one transaction if and only if they are all valid.
    /// Default is false.
    #[prost(bool, tag = "3")]
    pub partial_failure: bool,
    /// If true, the request is validated but not executed. Only errors are
    /// returned, not results.
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
    /// The response content type setting. Determines whether the mutable resource
    /// or just the resource name should be returned post mutation.
    #[prost(
        enumeration = "super::enums::response_content_type_enum::ResponseContentType",
        tag = "5"
    )]
    pub response_content_type: i32,
}
/// A single operation (create, update) on a conversion custom variable.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConversionCustomVariableOperation {
    /// FieldMask that determines which resource fields are modified in an update.
    #[prost(message, optional, tag = "3")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// The mutate operation.
    #[prost(oneof = "conversion_custom_variable_operation::Operation", tags = "1, 2")]
    pub operation: ::core::option::Option<
        conversion_custom_variable_operation::Operation,
    >,
}
/// Nested message and enum types in `ConversionCustomVariableOperation`.
pub mod conversion_custom_variable_operation {
    /// The mutate operation.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Operation {
        /// Create operation: No resource name is expected for the new conversion
        /// custom variable.
        #[prost(message, tag = "1")]
        Create(super::super::resources::ConversionCustomVariable),
        /// Update operation: The conversion custom variable is expected to have a
        /// valid resource name.
        #[prost(message, tag = "2")]
        Update(super::super::resources::ConversionCustomVariable),
    }
}
/// Response message for
/// [ConversionCustomVariableService.MutateConversionCustomVariables][google.ads.googleads.v16.services.ConversionCustomVariableService.MutateConversionCustomVariables].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateConversionCustomVariablesResponse {
    /// Errors that pertain to operation failures in the partial failure mode.
    /// Returned only when partial_failure = true and all errors occur inside the
    /// operations. If any errors occur outside the operations (for example, auth
    /// errors), we return an RPC level error.
    #[prost(message, optional, tag = "1")]
    pub partial_failure_error: ::core::option::Option<
        super::super::super::super::rpc::Status,
    >,
    /// All results for the mutate.
    #[prost(message, repeated, tag = "2")]
    pub results: ::prost::alloc::vec::Vec<MutateConversionCustomVariableResult>,
}
/// The result for the conversion custom variable mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateConversionCustomVariableResult {
    /// Returned for successful operations.
    #[prost(string, tag = "1")]
    pub resource_name: ::prost::alloc::string::String,
    /// The mutated conversion custom variable with only mutable fields after
    /// mutate. The field will only be returned when response_content_type is set
    /// to "MUTABLE_RESOURCE".
    #[prost(message, optional, tag = "2")]
    pub conversion_custom_variable: ::core::option::Option<
        super::resources::ConversionCustomVariable,
    >,
}
/// Generated server implementations.
pub mod conversion_custom_variable_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with ConversionCustomVariableServiceServer.
    #[async_trait]
    pub trait ConversionCustomVariableService: std::marker::Send + std::marker::Sync + 'static {
        /// Creates or updates conversion custom variables. Operation statuses are
        /// returned.
        ///
        /// List of thrown errors:
        ///   [AuthenticationError]()
        ///   [AuthorizationError]()
        ///   [ConversionCustomVariableError]()
        ///   [DatabaseError]()
        ///   [HeaderError]()
        ///   [InternalError]()
        ///   [QuotaError]()
        ///   [RequestError]()
        async fn mutate_conversion_custom_variables(
            &self,
            request: tonic::Request<super::MutateConversionCustomVariablesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MutateConversionCustomVariablesResponse>,
            tonic::Status,
        >;
    }
    /// Service to manage conversion custom variables.
    #[derive(Debug)]
    pub struct ConversionCustomVariableServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> ConversionCustomVariableServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>>
    for ConversionCustomVariableServiceServer<T>
    where
        T: ConversionCustomVariableService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/google.ads.googleads.v16.services.ConversionCustomVariableService/MutateConversionCustomVariables" => {
                    #[allow(non_camel_case_types)]
                    struct MutateConversionCustomVariablesSvc<
                        T: ConversionCustomVariableService,
                    >(
                        pub Arc<T>,
                    );
                    impl<
                        T: ConversionCustomVariableService,
                    > tonic::server::UnaryService<
                        super::MutateConversionCustomVariablesRequest,
                    > for MutateConversionCustomVariablesSvc<T> {
                        type Response = super::MutateConversionCustomVariablesResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::MutateConversionCustomVariablesRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ConversionCustomVariableService>::mutate_conversion_custom_variables(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = MutateConversionCustomVariablesSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for ConversionCustomVariableServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "google.ads.googleads.v16.services.ConversionCustomVariableService";
    impl<T> tonic::server::NamedService for ConversionCustomVariableServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Request message for
/// [ConversionGoalCampaignConfigService.MutateConversionGoalCampaignConfigs][google.ads.googleads.v16.services.ConversionGoalCampaignConfigService.MutateConversionGoalCampaignConfigs].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateConversionGoalCampaignConfigsRequest {
    /// Required. The ID of the customer whose custom conversion goals are being
    /// modified.
    #[prost(string, tag = "1")]
    pub customer_id: ::prost::alloc::string::String,
    /// Required. The list of operations to perform on individual conversion goal
    /// campaign config.
    #[prost(message, repeated, tag = "2")]
    pub operations: ::prost::alloc::vec::Vec<ConversionGoalCampaignConfigOperation>,
    /// If true, the request is validated but not executed. Only errors are
    /// returned, not results.
    #[prost(bool, tag = "3")]
    pub validate_only: bool,
    /// The response content type setting. Determines whether the mutable resource
    /// or just the resource name should be returned post mutation.
    #[prost(
        enumeration = "super::enums::response_content_type_enum::ResponseContentType",
        tag = "4"
    )]
    pub response_content_type: i32,
}
/// A single operation (update) on a conversion goal campaign config.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConversionGoalCampaignConfigOperation {
    /// FieldMask that determines which resource fields are modified in an update.
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// The mutate operation.
    #[prost(oneof = "conversion_goal_campaign_config_operation::Operation", tags = "1")]
    pub operation: ::core::option::Option<
        conversion_goal_campaign_config_operation::Operation,
    >,
}
/// Nested message and enum types in `ConversionGoalCampaignConfigOperation`.
pub mod conversion_goal_campaign_config_operation {
    /// The mutate operation.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Operation {
        /// Update operation: The conversion goal campaign config is expected to have
        /// a valid resource name.
        #[prost(message, tag = "1")]
        Update(super::super::resources::ConversionGoalCampaignConfig),
    }
}
/// Response message for a conversion goal campaign config mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateConversionGoalCampaignConfigsResponse {
    /// All results for the mutate.
    #[prost(message, repeated, tag = "1")]
    pub results: ::prost::alloc::vec::Vec<MutateConversionGoalCampaignConfigResult>,
}
/// The result for the conversion goal campaign config mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateConversionGoalCampaignConfigResult {
    /// Returned for successful operations.
    #[prost(string, tag = "1")]
    pub resource_name: ::prost::alloc::string::String,
    /// The mutated ConversionGoalCampaignConfig with only mutable fields after
    /// mutate. The field will only be returned when response_content_type is set
    /// to "MUTABLE_RESOURCE".
    #[prost(message, optional, tag = "2")]
    pub conversion_goal_campaign_config: ::core::option::Option<
        super::resources::ConversionGoalCampaignConfig,
    >,
}
/// Generated server implementations.
pub mod conversion_goal_campaign_config_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with ConversionGoalCampaignConfigServiceServer.
    #[async_trait]
    pub trait ConversionGoalCampaignConfigService: std::marker::Send + std::marker::Sync + 'static {
        /// Creates, updates or removes conversion goal campaign config. Operation
        /// statuses are returned.
        async fn mutate_conversion_goal_campaign_configs(
            &self,
            request: tonic::Request<super::MutateConversionGoalCampaignConfigsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MutateConversionGoalCampaignConfigsResponse>,
            tonic::Status,
        >;
    }
    /// Service to manage conversion goal campaign config.
    #[derive(Debug)]
    pub struct ConversionGoalCampaignConfigServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> ConversionGoalCampaignConfigServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>>
    for ConversionGoalCampaignConfigServiceServer<T>
    where
        T: ConversionGoalCampaignConfigService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/google.ads.googleads.v16.services.ConversionGoalCampaignConfigService/MutateConversionGoalCampaignConfigs" => {
                    #[allow(non_camel_case_types)]
                    struct MutateConversionGoalCampaignConfigsSvc<
                        T: ConversionGoalCampaignConfigService,
                    >(
                        pub Arc<T>,
                    );
                    impl<
                        T: ConversionGoalCampaignConfigService,
                    > tonic::server::UnaryService<
                        super::MutateConversionGoalCampaignConfigsRequest,
                    > for MutateConversionGoalCampaignConfigsSvc<T> {
                        type Response = super::MutateConversionGoalCampaignConfigsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::MutateConversionGoalCampaignConfigsRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ConversionGoalCampaignConfigService>::mutate_conversion_goal_campaign_configs(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = MutateConversionGoalCampaignConfigsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for ConversionGoalCampaignConfigServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "google.ads.googleads.v16.services.ConversionGoalCampaignConfigService";
    impl<T> tonic::server::NamedService
    for ConversionGoalCampaignConfigServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Request message for
/// [ConversionValueRuleService.MutateConversionValueRules][google.ads.googleads.v16.services.ConversionValueRuleService.MutateConversionValueRules].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateConversionValueRulesRequest {
    /// Required. The ID of the customer whose conversion value rules are being
    /// modified.
    #[prost(string, tag = "1")]
    pub customer_id: ::prost::alloc::string::String,
    /// Required. The list of operations to perform on individual conversion value
    /// rules.
    #[prost(message, repeated, tag = "2")]
    pub operations: ::prost::alloc::vec::Vec<ConversionValueRuleOperation>,
    /// If true, successful operations will be carried out and invalid
    /// operations will return errors. If false, all operations will be carried
    /// out in one transaction if and only if they are all valid.
    /// Default is false.
    #[prost(bool, tag = "5")]
    pub partial_failure: bool,
    /// If true, the request is validated but not executed. Only errors are
    /// returned, not results.
    #[prost(bool, tag = "3")]
    pub validate_only: bool,
    /// The response content type setting. Determines whether the mutable resource
    /// or just the resource name should be returned post mutation.
    #[prost(
        enumeration = "super::enums::response_content_type_enum::ResponseContentType",
        tag = "4"
    )]
    pub response_content_type: i32,
}
/// A single operation (create, update, remove) on a conversion value rule.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConversionValueRuleOperation {
    /// FieldMask that determines which resource fields are modified in an update.
    #[prost(message, optional, tag = "4")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// The mutate operation.
    #[prost(oneof = "conversion_value_rule_operation::Operation", tags = "1, 2, 3")]
    pub operation: ::core::option::Option<conversion_value_rule_operation::Operation>,
}
/// Nested message and enum types in `ConversionValueRuleOperation`.
pub mod conversion_value_rule_operation {
    /// The mutate operation.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Operation {
        /// Create operation: No resource name is expected for the new conversion
        /// value rule.
        #[prost(message, tag = "1")]
        Create(super::super::resources::ConversionValueRule),
        /// Update operation: The conversion value rule is expected to have a valid
        /// resource name.
        #[prost(message, tag = "2")]
        Update(super::super::resources::ConversionValueRule),
        /// Remove operation: A resource name for the removed conversion value rule
        /// is expected, in this format:
        ///
        /// `customers/{customer_id}/conversionValueRules/{conversion_value_rule_id}`
        #[prost(string, tag = "3")]
        Remove(::prost::alloc::string::String),
    }
}
/// Response message for
/// [ConversionValueRuleService.MutateConversionValueRules][google.ads.googleads.v16.services.ConversionValueRuleService.MutateConversionValueRules].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateConversionValueRulesResponse {
    /// All results for the mutate.
    #[prost(message, repeated, tag = "2")]
    pub results: ::prost::alloc::vec::Vec<MutateConversionValueRuleResult>,
    /// Errors that pertain to operation failures in the partial failure mode.
    /// Returned only when partial_failure = true and all errors occur inside the
    /// operations. If any errors occur outside the operations (for example, auth
    /// errors), we return an RPC level error.
    #[prost(message, optional, tag = "3")]
    pub partial_failure_error: ::core::option::Option<
        super::super::super::super::rpc::Status,
    >,
}
/// The result for the conversion value rule mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateConversionValueRuleResult {
    /// Returned for successful operations.
    #[prost(string, tag = "1")]
    pub resource_name: ::prost::alloc::string::String,
    /// The mutated conversion value rule with only mutable fields after
    /// mutate. The field will only be returned when response_content_type is set
    /// to "MUTABLE_RESOURCE".
    #[prost(message, optional, tag = "2")]
    pub conversion_value_rule: ::core::option::Option<
        super::resources::ConversionValueRule,
    >,
}
/// Generated server implementations.
pub mod conversion_value_rule_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with ConversionValueRuleServiceServer.
    #[async_trait]
    pub trait ConversionValueRuleService: std::marker::Send + std::marker::Sync + 'static {
        /// Creates, updates, or removes conversion value rules. Operation statuses are
        /// returned.
        async fn mutate_conversion_value_rules(
            &self,
            request: tonic::Request<super::MutateConversionValueRulesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MutateConversionValueRulesResponse>,
            tonic::Status,
        >;
    }
    /// Service to manage conversion value rules.
    #[derive(Debug)]
    pub struct ConversionValueRuleServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> ConversionValueRuleServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>>
    for ConversionValueRuleServiceServer<T>
    where
        T: ConversionValueRuleService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/google.ads.googleads.v16.services.ConversionValueRuleService/MutateConversionValueRules" => {
                    #[allow(non_camel_case_types)]
                    struct MutateConversionValueRulesSvc<T: ConversionValueRuleService>(
                        pub Arc<T>,
                    );
                    impl<
                        T: ConversionValueRuleService,
                    > tonic::server::UnaryService<
                        super::MutateConversionValueRulesRequest,
                    > for MutateConversionValueRulesSvc<T> {
                        type Response = super::MutateConversionValueRulesResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::MutateConversionValueRulesRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ConversionValueRuleService>::mutate_conversion_value_rules(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = MutateConversionValueRulesSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for ConversionValueRuleServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "google.ads.googleads.v16.services.ConversionValueRuleService";
    impl<T> tonic::server::NamedService for ConversionValueRuleServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Request message for
/// [ConversionValueRuleSetService.MutateConversionValueRuleSets][google.ads.googleads.v16.services.ConversionValueRuleSetService.MutateConversionValueRuleSets].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateConversionValueRuleSetsRequest {
    /// Required. The ID of the customer whose conversion value rule sets are being
    /// modified.
    #[prost(string, tag = "1")]
    pub customer_id: ::prost::alloc::string::String,
    /// Required. The list of operations to perform on individual conversion value
    /// rule sets.
    #[prost(message, repeated, tag = "2")]
    pub operations: ::prost::alloc::vec::Vec<ConversionValueRuleSetOperation>,
    /// If true, successful operations will be carried out and invalid
    /// operations will return errors. If false, all operations will be carried
    /// out in one transaction if and only if they are all valid.
    /// Default is false.
    #[prost(bool, tag = "5")]
    pub partial_failure: bool,
    /// If true, the request is validated but not executed. Only errors are
    /// returned, not results.
    #[prost(bool, tag = "3")]
    pub validate_only: bool,
    /// The response content type setting. Determines whether the mutable resource
    /// or just the resource name should be returned post mutation.
    #[prost(
        enumeration = "super::enums::response_content_type_enum::ResponseContentType",
        tag = "4"
    )]
    pub response_content_type: i32,
}
/// A single operation (create, update, remove) on a conversion value rule set.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConversionValueRuleSetOperation {
    /// FieldMask that determines which resource fields are modified in an update.
    #[prost(message, optional, tag = "4")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// The mutate operation.
    #[prost(oneof = "conversion_value_rule_set_operation::Operation", tags = "1, 2, 3")]
    pub operation: ::core::option::Option<
        conversion_value_rule_set_operation::Operation,
    >,
}
/// Nested message and enum types in `ConversionValueRuleSetOperation`.
pub mod conversion_value_rule_set_operation {
    /// The mutate operation.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Operation {
        /// Create operation: No resource name is expected for the new conversion
        /// value rule set.
        #[prost(message, tag = "1")]
        Create(super::super::resources::ConversionValueRuleSet),
        /// Update operation: The conversion value rule set is expected to have a
        /// valid resource name.
        #[prost(message, tag = "2")]
        Update(super::super::resources::ConversionValueRuleSet),
        /// Remove operation: A resource name for the removed conversion value rule
        /// set is expected, in this format:
        ///
        /// `customers/{customer_id}/conversionValueRuleSets/{conversion_value_rule_set_id}`
        #[prost(string, tag = "3")]
        Remove(::prost::alloc::string::String),
    }
}
/// Response message for
/// [ConversionValueRuleSetService.MutateConversionValueRuleSets][google.ads.googleads.v16.services.ConversionValueRuleSetService.MutateConversionValueRuleSets].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateConversionValueRuleSetsResponse {
    /// All results for the mutate.
    #[prost(message, repeated, tag = "1")]
    pub results: ::prost::alloc::vec::Vec<MutateConversionValueRuleSetResult>,
    /// Errors that pertain to operation failures in the partial failure mode.
    /// Returned only when partial_failure = true and all errors occur inside the
    /// operations. If any errors occur outside the operations (for example, auth
    /// errors), we return an RPC level error.
    #[prost(message, optional, tag = "2")]
    pub partial_failure_error: ::core::option::Option<
        super::super::super::super::rpc::Status,
    >,
}
/// The result for the conversion value rule set mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateConversionValueRuleSetResult {
    /// Returned for successful operations.
    #[prost(string, tag = "1")]
    pub resource_name: ::prost::alloc::string::String,
    /// The mutated conversion value rule set with only mutable fields after
    /// mutate. The field will only be returned when response_content_type is set
    /// to "MUTABLE_RESOURCE".
    #[prost(message, optional, tag = "2")]
    pub conversion_value_rule_set: ::core::option::Option<
        super::resources::ConversionValueRuleSet,
    >,
}
/// Generated server implementations.
pub mod conversion_value_rule_set_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with ConversionValueRuleSetServiceServer.
    #[async_trait]
    pub trait ConversionValueRuleSetService: std::marker::Send + std::marker::Sync + 'static {
        /// Creates, updates or removes conversion value rule sets. Operation statuses
        /// are returned.
        async fn mutate_conversion_value_rule_sets(
            &self,
            request: tonic::Request<super::MutateConversionValueRuleSetsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MutateConversionValueRuleSetsResponse>,
            tonic::Status,
        >;
    }
    /// Service to manage conversion value rule sets.
    #[derive(Debug)]
    pub struct ConversionValueRuleSetServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> ConversionValueRuleSetServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>>
    for ConversionValueRuleSetServiceServer<T>
    where
        T: ConversionValueRuleSetService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/google.ads.googleads.v16.services.ConversionValueRuleSetService/MutateConversionValueRuleSets" => {
                    #[allow(non_camel_case_types)]
                    struct MutateConversionValueRuleSetsSvc<
                        T: ConversionValueRuleSetService,
                    >(
                        pub Arc<T>,
                    );
                    impl<
                        T: ConversionValueRuleSetService,
                    > tonic::server::UnaryService<
                        super::MutateConversionValueRuleSetsRequest,
                    > for MutateConversionValueRuleSetsSvc<T> {
                        type Response = super::MutateConversionValueRuleSetsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::MutateConversionValueRuleSetsRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ConversionValueRuleSetService>::mutate_conversion_value_rule_sets(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = MutateConversionValueRuleSetsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for ConversionValueRuleSetServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "google.ads.googleads.v16.services.ConversionValueRuleSetService";
    impl<T> tonic::server::NamedService for ConversionValueRuleSetServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Request message for
/// [CustomConversionGoalService.MutateCustomConversionGoals][google.ads.googleads.v16.services.CustomConversionGoalService.MutateCustomConversionGoals].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCustomConversionGoalsRequest {
    /// Required. The ID of the customer whose custom conversion goals are being
    /// modified.
    #[prost(string, tag = "1")]
    pub customer_id: ::prost::alloc::string::String,
    /// Required. The list of operations to perform on individual custom conversion
    /// goal.
    #[prost(message, repeated, tag = "2")]
    pub operations: ::prost::alloc::vec::Vec<CustomConversionGoalOperation>,
    /// If true, the request is validated but not executed. Only errors are
    /// returned, not results.
    #[prost(bool, tag = "3")]
    pub validate_only: bool,
    /// The response content type setting. Determines whether the mutable resource
    /// or just the resource name should be returned post mutation.
    #[prost(
        enumeration = "super::enums::response_content_type_enum::ResponseContentType",
        tag = "4"
    )]
    pub response_content_type: i32,
}
/// A single operation (create, remove) on a custom conversion goal.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CustomConversionGoalOperation {
    /// FieldMask that determines which resource fields are modified in an update.
    #[prost(message, optional, tag = "4")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// The mutate operation.
    #[prost(oneof = "custom_conversion_goal_operation::Operation", tags = "1, 2, 3")]
    pub operation: ::core::option::Option<custom_conversion_goal_operation::Operation>,
}
/// Nested message and enum types in `CustomConversionGoalOperation`.
pub mod custom_conversion_goal_operation {
    /// The mutate operation.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Operation {
        /// Create operation: No resource name is expected for the new custom
        /// conversion goal
        #[prost(message, tag = "1")]
        Create(super::super::resources::CustomConversionGoal),
        /// Update operation: The custom conversion goal is expected to have a
        /// valid resource name.
        #[prost(message, tag = "2")]
        Update(super::super::resources::CustomConversionGoal),
        /// Remove operation: A resource name for the removed custom conversion goal
        /// is expected, in this format:
        ///
        /// 'customers/{customer_id}/conversionActions/{ConversionGoal.custom_goal_config.conversion_type_ids}'
        #[prost(string, tag = "3")]
        Remove(::prost::alloc::string::String),
    }
}
/// Response message for a custom conversion goal mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCustomConversionGoalsResponse {
    /// All results for the mutate.
    #[prost(message, repeated, tag = "1")]
    pub results: ::prost::alloc::vec::Vec<MutateCustomConversionGoalResult>,
}
/// The result for the custom conversion goal mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCustomConversionGoalResult {
    /// Returned for successful operations.
    #[prost(string, tag = "1")]
    pub resource_name: ::prost::alloc::string::String,
    /// The mutated CustomConversionGoal with only mutable fields after mutate.
    /// The field will only be returned when response_content_type is set to
    /// "MUTABLE_RESOURCE".
    #[prost(message, optional, tag = "2")]
    pub custom_conversion_goal: ::core::option::Option<
        super::resources::CustomConversionGoal,
    >,
}
/// Generated server implementations.
pub mod custom_conversion_goal_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with CustomConversionGoalServiceServer.
    #[async_trait]
    pub trait CustomConversionGoalService: std::marker::Send + std::marker::Sync + 'static {
        /// Creates, updates or removes custom conversion goals. Operation statuses
        /// are returned.
        async fn mutate_custom_conversion_goals(
            &self,
            request: tonic::Request<super::MutateCustomConversionGoalsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MutateCustomConversionGoalsResponse>,
            tonic::Status,
        >;
    }
    /// Service to manage custom conversion goal.
    #[derive(Debug)]
    pub struct CustomConversionGoalServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> CustomConversionGoalServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>>
    for CustomConversionGoalServiceServer<T>
    where
        T: CustomConversionGoalService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/google.ads.googleads.v16.services.CustomConversionGoalService/MutateCustomConversionGoals" => {
                    #[allow(non_camel_case_types)]
                    struct MutateCustomConversionGoalsSvc<
                        T: CustomConversionGoalService,
                    >(
                        pub Arc<T>,
                    );
                    impl<
                        T: CustomConversionGoalService,
                    > tonic::server::UnaryService<
                        super::MutateCustomConversionGoalsRequest,
                    > for MutateCustomConversionGoalsSvc<T> {
                        type Response = super::MutateCustomConversionGoalsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::MutateCustomConversionGoalsRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as CustomConversionGoalService>::mutate_custom_conversion_goals(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = MutateCustomConversionGoalsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for CustomConversionGoalServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "google.ads.googleads.v16.services.CustomConversionGoalService";
    impl<T> tonic::server::NamedService for CustomConversionGoalServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Request message for
/// [CustomerAssetService.MutateCustomerAssets][google.ads.googleads.v16.services.CustomerAssetService.MutateCustomerAssets].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCustomerAssetsRequest {
    /// Required. The ID of the customer whose customer assets are being modified.
    #[prost(string, tag = "1")]
    pub customer_id: ::prost::alloc::string::String,
    /// Required. The list of operations to perform on individual customer assets.
    #[prost(message, repeated, tag = "2")]
    pub operations: ::prost::alloc::vec::Vec<CustomerAssetOperation>,
    /// If true, successful operations will be carried out and invalid
    /// operations will return errors. If false, all operations will be carried
    /// out in one transaction if and only if they are all valid.
    /// Default is false.
    #[prost(bool, tag = "3")]
    pub partial_failure: bool,
    /// If true, the request is validated but not executed. Only errors are
    /// returned, not results.
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
    /// The response content type setting. Determines whether the mutable resource
    /// or just the resource name should be returned post mutation.
    #[prost(
        enumeration = "super::enums::response_content_type_enum::ResponseContentType",
        tag = "5"
    )]
    pub response_content_type: i32,
}
/// A single operation (create, update, remove) on a customer asset.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CustomerAssetOperation {
    /// FieldMask that determines which resource fields are modified in an update.
    #[prost(message, optional, tag = "4")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// The mutate operation.
    #[prost(oneof = "customer_asset_operation::Operation", tags = "1, 3, 2")]
    pub operation: ::core::option::Option<customer_asset_operation::Operation>,
}
/// Nested message and enum types in `CustomerAssetOperation`.
pub mod customer_asset_operation {
    /// The mutate operation.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Operation {
        /// Create operation: No resource name is expected for the new customer
        /// asset.
        #[prost(message, tag = "1")]
        Create(super::super::resources::CustomerAsset),
        /// Update operation: The customer asset is expected to have a valid resource
        /// name.
        #[prost(message, tag = "3")]
        Update(super::super::resources::CustomerAsset),
        /// Remove operation: A resource name for the removed customer asset is
        /// expected, in this format:
        ///
        /// `customers/{customer_id}/customerAssets/{asset_id}~{field_type}`
        #[prost(string, tag = "2")]
        Remove(::prost::alloc::string::String),
    }
}
/// Response message for a customer asset mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCustomerAssetsResponse {
    /// Errors that pertain to operation failures in the partial failure mode.
    /// Returned only when partial_failure = true and all errors occur inside the
    /// operations. If any errors occur outside the operations (for example, auth
    /// errors), we return an RPC level error.
    #[prost(message, optional, tag = "1")]
    pub partial_failure_error: ::core::option::Option<
        super::super::super::super::rpc::Status,
    >,
    /// All results for the mutate.
    #[prost(message, repeated, tag = "2")]
    pub results: ::prost::alloc::vec::Vec<MutateCustomerAssetResult>,
}
/// The result for the customer asset mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCustomerAssetResult {
    /// Returned for successful operations.
    #[prost(string, tag = "1")]
    pub resource_name: ::prost::alloc::string::String,
    /// The mutated customer asset with only mutable fields after
    /// mutate. The field will only be returned when response_content_type is set
    /// to "MUTABLE_RESOURCE".
    #[prost(message, optional, tag = "2")]
    pub customer_asset: ::core::option::Option<super::resources::CustomerAsset>,
}
/// Generated server implementations.
pub mod customer_asset_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with CustomerAssetServiceServer.
    #[async_trait]
    pub trait CustomerAssetService: std::marker::Send + std::marker::Sync + 'static {
        /// Creates, updates, or removes customer assets. Operation statuses are
        /// returned.
        ///
        /// List of thrown errors:
        ///   [AssetLinkError]()
        ///   [AuthenticationError]()
        ///   [AuthorizationError]()
        ///   [FieldError]()
        ///   [HeaderError]()
        ///   [InternalError]()
        ///   [MutateError]()
        ///   [QuotaError]()
        ///   [RequestError]()
        async fn mutate_customer_assets(
            &self,
            request: tonic::Request<super::MutateCustomerAssetsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MutateCustomerAssetsResponse>,
            tonic::Status,
        >;
    }
    /// Service to manage customer assets.
    #[derive(Debug)]
    pub struct CustomerAssetServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> CustomerAssetServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>>
    for CustomerAssetServiceServer<T>
    where
        T: CustomerAssetService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/google.ads.googleads.v16.services.CustomerAssetService/MutateCustomerAssets" => {
                    #[allow(non_camel_case_types)]
                    struct MutateCustomerAssetsSvc<T: CustomerAssetService>(pub Arc<T>);
                    impl<
                        T: CustomerAssetService,
                    > tonic::server::UnaryService<super::MutateCustomerAssetsRequest>
                    for MutateCustomerAssetsSvc<T> {
                        type Response = super::MutateCustomerAssetsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::MutateCustomerAssetsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as CustomerAssetService>::mutate_customer_assets(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = MutateCustomerAssetsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for CustomerAssetServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "google.ads.googleads.v16.services.CustomerAssetService";
    impl<T> tonic::server::NamedService for CustomerAssetServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Request message for
/// [CustomerConversionGoalService.MutateCustomerConversionGoals][google.ads.googleads.v16.services.CustomerConversionGoalService.MutateCustomerConversionGoals].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCustomerConversionGoalsRequest {
    /// Required. The ID of the customer whose customer conversion goals are being
    /// modified.
    #[prost(string, tag = "1")]
    pub customer_id: ::prost::alloc::string::String,
    /// Required. The list of operations to perform on individual customer
    /// conversion goal.
    #[prost(message, repeated, tag = "2")]
    pub operations: ::prost::alloc::vec::Vec<CustomerConversionGoalOperation>,
    /// If true, the request is validated but not executed. Only errors are
    /// returned, not results.
    #[prost(bool, tag = "3")]
    pub validate_only: bool,
}
/// A single operation (update) on a customer conversion goal.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CustomerConversionGoalOperation {
    /// FieldMask that determines which resource fields are modified in an update.
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// The mutate operation.
    #[prost(oneof = "customer_conversion_goal_operation::Operation", tags = "1")]
    pub operation: ::core::option::Option<customer_conversion_goal_operation::Operation>,
}
/// Nested message and enum types in `CustomerConversionGoalOperation`.
pub mod customer_conversion_goal_operation {
    /// The mutate operation.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Operation {
        /// Update operation: The customer conversion goal is expected to have a
        /// valid resource name.
        #[prost(message, tag = "1")]
        Update(super::super::resources::CustomerConversionGoal),
    }
}
/// Response message for a customer conversion goal mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCustomerConversionGoalsResponse {
    /// All results for the mutate.
    #[prost(message, repeated, tag = "1")]
    pub results: ::prost::alloc::vec::Vec<MutateCustomerConversionGoalResult>,
}
/// The result for the customer conversion goal mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCustomerConversionGoalResult {
    /// Returned for successful operations.
    #[prost(string, tag = "1")]
    pub resource_name: ::prost::alloc::string::String,
}
/// Generated server implementations.
pub mod customer_conversion_goal_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with CustomerConversionGoalServiceServer.
    #[async_trait]
    pub trait CustomerConversionGoalService: std::marker::Send + std::marker::Sync + 'static {
        /// Creates, updates or removes customer conversion goals. Operation statuses
        /// are returned.
        async fn mutate_customer_conversion_goals(
            &self,
            request: tonic::Request<super::MutateCustomerConversionGoalsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MutateCustomerConversionGoalsResponse>,
            tonic::Status,
        >;
    }
    /// Service to manage customer conversion goal.
    #[derive(Debug)]
    pub struct CustomerConversionGoalServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> CustomerConversionGoalServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>>
    for CustomerConversionGoalServiceServer<T>
    where
        T: CustomerConversionGoalService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/google.ads.googleads.v16.services.CustomerConversionGoalService/MutateCustomerConversionGoals" => {
                    #[allow(non_camel_case_types)]
                    struct MutateCustomerConversionGoalsSvc<
                        T: CustomerConversionGoalService,
                    >(
                        pub Arc<T>,
                    );
                    impl<
                        T: CustomerConversionGoalService,
                    > tonic::server::UnaryService<
                        super::MutateCustomerConversionGoalsRequest,
                    > for MutateCustomerConversionGoalsSvc<T> {
                        type Response = super::MutateCustomerConversionGoalsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::MutateCustomerConversionGoalsRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as CustomerConversionGoalService>::mutate_customer_conversion_goals(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = MutateCustomerConversionGoalsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for CustomerConversionGoalServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "google.ads.googleads.v16.services.CustomerConversionGoalService";
    impl<T> tonic::server::NamedService for CustomerConversionGoalServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Request message for
/// [CustomerCustomizerService.MutateCustomerCustomizers][google.ads.googleads.v16.services.CustomerCustomizerService.MutateCustomerCustomizers].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCustomerCustomizersRequest {
    /// Required. The ID of the customer whose customer customizers are being
    /// modified.
    #[prost(string, tag = "1")]
    pub customer_id: ::prost::alloc::string::String,
    /// Required. The list of operations to perform on individual customer
    /// customizers.
    #[prost(message, repeated, tag = "2")]
    pub operations: ::prost::alloc::vec::Vec<CustomerCustomizerOperation>,
    /// If true, successful operations will be carried out and invalid
    /// operations will return errors. If false, all operations will be carried
    /// out in one transaction if and only if they are all valid.
    /// Default is false.
    #[prost(bool, tag = "3")]
    pub partial_failure: bool,
    /// If true, the request is validated but not executed. Only errors are
    /// returned, not results.
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
    /// The response content type setting. Determines whether the mutable resource
    /// or just the resource name should be returned post mutation.
    #[prost(
        enumeration = "super::enums::response_content_type_enum::ResponseContentType",
        tag = "5"
    )]
    pub response_content_type: i32,
}
/// A single operation (create, remove) on a customizer attribute.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CustomerCustomizerOperation {
    /// The mutate operation.
    #[prost(oneof = "customer_customizer_operation::Operation", tags = "1, 2")]
    pub operation: ::core::option::Option<customer_customizer_operation::Operation>,
}
/// Nested message and enum types in `CustomerCustomizerOperation`.
pub mod customer_customizer_operation {
    /// The mutate operation.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Operation {
        /// Create operation: No resource name is expected for the new customer
        /// customizer
        #[prost(message, tag = "1")]
        Create(super::super::resources::CustomerCustomizer),
        /// Remove operation: A resource name for the removed customer customizer is
        /// expected, in this format:
        /// `customers/{customer_id}/customerCustomizers/{customizer_attribute_id}`
        #[prost(string, tag = "2")]
        Remove(::prost::alloc::string::String),
    }
}
/// Response message for a customizer attribute mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCustomerCustomizersResponse {
    /// All results for the mutate.
    #[prost(message, repeated, tag = "1")]
    pub results: ::prost::alloc::vec::Vec<MutateCustomerCustomizerResult>,
    /// Errors that pertain to operation failures in the partial failure mode.
    /// Returned only when partial_failure = true and all errors occur inside the
    /// operations. If any errors occur outside the operations (for example, auth
    /// errors), we return an RPC level error.
    #[prost(message, optional, tag = "2")]
    pub partial_failure_error: ::core::option::Option<
        super::super::super::super::rpc::Status,
    >,
}
/// The result for the customizer attribute mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCustomerCustomizerResult {
    /// Returned for successful operations.
    #[prost(string, tag = "1")]
    pub resource_name: ::prost::alloc::string::String,
    /// The mutated CustomerCustomizer with only mutable fields after mutate.
    /// The field will only be returned when response_content_type is set to
    /// "MUTABLE_RESOURCE".
    #[prost(message, optional, tag = "2")]
    pub customer_customizer: ::core::option::Option<
        super::resources::CustomerCustomizer,
    >,
}
/// Generated server implementations.
pub mod customer_customizer_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with CustomerCustomizerServiceServer.
    #[async_trait]
    pub trait CustomerCustomizerService: std::marker::Send + std::marker::Sync + 'static {
        /// Creates, updates or removes customer customizers. Operation statuses are
        /// returned.
        async fn mutate_customer_customizers(
            &self,
            request: tonic::Request<super::MutateCustomerCustomizersRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MutateCustomerCustomizersResponse>,
            tonic::Status,
        >;
    }
    /// Service to manage customer customizer
    #[derive(Debug)]
    pub struct CustomerCustomizerServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> CustomerCustomizerServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>>
    for CustomerCustomizerServiceServer<T>
    where
        T: CustomerCustomizerService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/google.ads.googleads.v16.services.CustomerCustomizerService/MutateCustomerCustomizers" => {
                    #[allow(non_camel_case_types)]
                    struct MutateCustomerCustomizersSvc<T: CustomerCustomizerService>(
                        pub Arc<T>,
                    );
                    impl<
                        T: CustomerCustomizerService,
                    > tonic::server::UnaryService<
                        super::MutateCustomerCustomizersRequest,
                    > for MutateCustomerCustomizersSvc<T> {
                        type Response = super::MutateCustomerCustomizersResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::MutateCustomerCustomizersRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as CustomerCustomizerService>::mutate_customer_customizers(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = MutateCustomerCustomizersSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for CustomerCustomizerServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "google.ads.googleads.v16.services.CustomerCustomizerService";
    impl<T> tonic::server::NamedService for CustomerCustomizerServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Request message for
/// [CustomerExtensionSettingService.MutateCustomerExtensionSettings][google.ads.googleads.v16.services.CustomerExtensionSettingService.MutateCustomerExtensionSettings].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCustomerExtensionSettingsRequest {
    /// Required. The ID of the customer whose customer extension settings are
    /// being modified.
    #[prost(string, tag = "1")]
    pub customer_id: ::prost::alloc::string::String,
    /// Required. The list of operations to perform on individual customer
    /// extension settings.
    #[prost(message, repeated, tag = "2")]
    pub operations: ::prost::alloc::vec::Vec<CustomerExtensionSettingOperation>,
    /// If true, successful operations will be carried out and invalid
    /// operations will return errors. If false, all operations will be carried
    /// out in one transaction if and only if they are all valid.
    /// Default is false.
    #[prost(bool, tag = "3")]
    pub partial_failure: bool,
    /// If true, the request is validated but not executed. Only errors are
    /// returned, not results.
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
    /// The response content type setting. Determines whether the mutable resource
    /// or just the resource name should be returned post mutation.
    #[prost(
        enumeration = "super::enums::response_content_type_enum::ResponseContentType",
        tag = "5"
    )]
    pub response_content_type: i32,
}
/// A single operation (create, update, remove) on a customer extension setting.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CustomerExtensionSettingOperation {
    /// FieldMask that determines which resource fields are modified in an update.
    #[prost(message, optional, tag = "4")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// The mutate operation.
    #[prost(oneof = "customer_extension_setting_operation::Operation", tags = "1, 2, 3")]
    pub operation: ::core::option::Option<
        customer_extension_setting_operation::Operation,
    >,
}
/// Nested message and enum types in `CustomerExtensionSettingOperation`.
pub mod customer_extension_setting_operation {
    /// The mutate operation.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Operation {
        /// Create operation: No resource name is expected for the new customer
        /// extension setting.
        #[prost(message, tag = "1")]
        Create(super::super::resources::CustomerExtensionSetting),
        /// Update operation: The customer extension setting is expected to have a
        /// valid resource name.
        #[prost(message, tag = "2")]
        Update(super::super::resources::CustomerExtensionSetting),
        /// Remove operation: A resource name for the removed customer extension
        /// setting is expected, in this format:
        ///
        /// `customers/{customer_id}/customerExtensionSettings/{extension_type}`
        #[prost(string, tag = "3")]
        Remove(::prost::alloc::string::String),
    }
}
/// Response message for a customer extension setting mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCustomerExtensionSettingsResponse {
    /// Errors that pertain to operation failures in the partial failure mode.
    /// Returned only when partial_failure = true and all errors occur inside the
    /// operations. If any errors occur outside the operations (for example, auth
    /// errors), we return an RPC level error.
    #[prost(message, optional, tag = "3")]
    pub partial_failure_error: ::core::option::Option<
        super::super::super::super::rpc::Status,
    >,
    /// All results for the mutate.
    #[prost(message, repeated, tag = "2")]
    pub results: ::prost::alloc::vec::Vec<MutateCustomerExtensionSettingResult>,
}
/// The result for the customer extension setting mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCustomerExtensionSettingResult {
    /// Returned for successful operations.
    #[prost(string, tag = "1")]
    pub resource_name: ::prost::alloc::string::String,
    /// The mutated CustomerExtensionSetting with only mutable fields after mutate.
    /// The field will only be returned when response_content_type is set to
    /// "MUTABLE_RESOURCE".
    #[prost(message, optional, tag = "2")]
    pub customer_extension_setting: ::core::option::Option<
        super::resources::CustomerExtensionSetting,
    >,
}
/// Generated server implementations.
pub mod customer_extension_setting_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with CustomerExtensionSettingServiceServer.
    #[async_trait]
    pub trait CustomerExtensionSettingService: std::marker::Send + std::marker::Sync + 'static {
        /// Creates, updates, or removes customer extension settings. Operation
        /// statuses are returned.
        ///
        /// List of thrown errors:
        ///   [AuthenticationError]()
        ///   [AuthorizationError]()
        ///   [CollectionSizeError]()
        ///   [CriterionError]()
        ///   [DatabaseError]()
        ///   [DateError]()
        ///   [DistinctError]()
        ///   [ExtensionSettingError]()
        ///   [FieldError]()
        ///   [HeaderError]()
        ///   [IdError]()
        ///   [InternalError]()
        ///   [ListOperationError]()
        ///   [MutateError]()
        ///   [NewResourceCreationError]()
        ///   [NotEmptyError]()
        ///   [NullError]()
        ///   [OperatorError]()
        ///   [QuotaError]()
        ///   [RangeError]()
        ///   [RequestError]()
        ///   [SizeLimitError]()
        ///   [StringFormatError]()
        ///   [StringLengthError]()
        ///   [UrlFieldError]()
        async fn mutate_customer_extension_settings(
            &self,
            request: tonic::Request<super::MutateCustomerExtensionSettingsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MutateCustomerExtensionSettingsResponse>,
            tonic::Status,
        >;
    }
    /// Service to manage customer extension settings.
    #[derive(Debug)]
    pub struct CustomerExtensionSettingServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> CustomerExtensionSettingServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>>
    for CustomerExtensionSettingServiceServer<T>
    where
        T: CustomerExtensionSettingService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/google.ads.googleads.v16.services.CustomerExtensionSettingService/MutateCustomerExtensionSettings" => {
                    #[allow(non_camel_case_types)]
                    struct MutateCustomerExtensionSettingsSvc<
                        T: CustomerExtensionSettingService,
                    >(
                        pub Arc<T>,
                    );
                    impl<
                        T: CustomerExtensionSettingService,
                    > tonic::server::UnaryService<
                        super::MutateCustomerExtensionSettingsRequest,
                    > for MutateCustomerExtensionSettingsSvc<T> {
                        type Response = super::MutateCustomerExtensionSettingsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::MutateCustomerExtensionSettingsRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as CustomerExtensionSettingService>::mutate_customer_extension_settings(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = MutateCustomerExtensionSettingsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for CustomerExtensionSettingServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "google.ads.googleads.v16.services.CustomerExtensionSettingService";
    impl<T> tonic::server::NamedService for CustomerExtensionSettingServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Request message for
/// [CustomerFeedService.MutateCustomerFeeds][google.ads.googleads.v16.services.CustomerFeedService.MutateCustomerFeeds].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCustomerFeedsRequest {
    /// Required. The ID of the customer whose customer feeds are being modified.
    #[prost(string, tag = "1")]
    pub customer_id: ::prost::alloc::string::String,
    /// Required. The list of operations to perform on individual customer feeds.
    #[prost(message, repeated, tag = "2")]
    pub operations: ::prost::alloc::vec::Vec<CustomerFeedOperation>,
    /// If true, successful operations will be carried out and invalid
    /// operations will return errors. If false, all operations will be carried
    /// out in one transaction if and only if they are all valid.
    /// Default is false.
    #[prost(bool, tag = "3")]
    pub partial_failure: bool,
    /// If true, the request is validated but not executed. Only errors are
    /// returned, not results.
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
    /// The response content type setting. Determines whether the mutable resource
    /// or just the resource name should be returned post mutation.
    #[prost(
        enumeration = "super::enums::response_content_type_enum::ResponseContentType",
        tag = "5"
    )]
    pub response_content_type: i32,
}
/// A single operation (create, update, remove) on a customer feed.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CustomerFeedOperation {
    /// FieldMask that determines which resource fields are modified in an update.
    #[prost(message, optional, tag = "4")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// The mutate operation.
    #[prost(oneof = "customer_feed_operation::Operation", tags = "1, 2, 3")]
    pub operation: ::core::option::Option<customer_feed_operation::Operation>,
}
/// Nested message and enum types in `CustomerFeedOperation`.
pub mod customer_feed_operation {
    /// The mutate operation.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Operation {
        /// Create operation: No resource name is expected for the new customer feed.
        #[prost(message, tag = "1")]
        Create(super::super::resources::CustomerFeed),
        /// Update operation: The customer feed is expected to have a valid resource
        /// name.
        #[prost(message, tag = "2")]
        Update(super::super::resources::CustomerFeed),
        /// Remove operation: A resource name for the removed customer feed is
        /// expected, in this format:
        ///
        /// `customers/{customer_id}/customerFeeds/{feed_id}`
        #[prost(string, tag = "3")]
        Remove(::prost::alloc::string::String),
    }
}
/// Response message for a customer feed mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCustomerFeedsResponse {
    /// Errors that pertain to operation failures in the partial failure mode.
    /// Returned only when partial_failure = true and all errors occur inside the
    /// operations. If any errors occur outside the operations (for example, auth
    /// errors), we return an RPC level error.
    #[prost(message, optional, tag = "3")]
    pub partial_failure_error: ::core::option::Option<
        super::super::super::super::rpc::Status,
    >,
    /// All results for the mutate.
    #[prost(message, repeated, tag = "2")]
    pub results: ::prost::alloc::vec::Vec<MutateCustomerFeedResult>,
}
/// The result for the customer feed mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCustomerFeedResult {
    /// Returned for successful operations.
    #[prost(string, tag = "1")]
    pub resource_name: ::prost::alloc::string::String,
    /// The mutated customer feed with only mutable fields after mutate. The field
    /// will only be returned when response_content_type is set to
    /// "MUTABLE_RESOURCE".
    #[prost(message, optional, tag = "2")]
    pub customer_feed: ::core::option::Option<super::resources::CustomerFeed>,
}
/// Generated server implementations.
pub mod customer_feed_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with CustomerFeedServiceServer.
    #[async_trait]
    pub trait CustomerFeedService: std::marker::Send + std::marker::Sync + 'static {
        /// Creates, updates, or removes customer feeds. Operation statuses are
        /// returned.
        ///
        /// List of thrown errors:
        ///   [AuthenticationError]()
        ///   [AuthorizationError]()
        ///   [CollectionSizeError]()
        ///   [CustomerFeedError]()
        ///   [DatabaseError]()
        ///   [DistinctError]()
        ///   [FieldError]()
        ///   [FieldMaskError]()
        ///   [FunctionError]()
        ///   [FunctionParsingError]()
        ///   [HeaderError]()
        ///   [IdError]()
        ///   [InternalError]()
        ///   [MutateError]()
        ///   [NotEmptyError]()
        ///   [OperatorError]()
        ///   [QuotaError]()
        ///   [RangeError]()
        ///   [RequestError]()
        ///   [SizeLimitError]()
        ///   [StringFormatError]()
        ///   [StringLengthError]()
        async fn mutate_customer_feeds(
            &self,
            request: tonic::Request<super::MutateCustomerFeedsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MutateCustomerFeedsResponse>,
            tonic::Status,
        >;
    }
    /// Service to manage customer feeds.
    #[derive(Debug)]
    pub struct CustomerFeedServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> CustomerFeedServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for CustomerFeedServiceServer<T>
    where
        T: CustomerFeedService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/google.ads.googleads.v16.services.CustomerFeedService/MutateCustomerFeeds" => {
                    #[allow(non_camel_case_types)]
                    struct MutateCustomerFeedsSvc<T: CustomerFeedService>(pub Arc<T>);
                    impl<
                        T: CustomerFeedService,
                    > tonic::server::UnaryService<super::MutateCustomerFeedsRequest>
                    for MutateCustomerFeedsSvc<T> {
                        type Response = super::MutateCustomerFeedsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::MutateCustomerFeedsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as CustomerFeedService>::mutate_customer_feeds(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = MutateCustomerFeedsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for CustomerFeedServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "google.ads.googleads.v16.services.CustomerFeedService";
    impl<T> tonic::server::NamedService for CustomerFeedServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Request message for
/// [CustomerLabelService.MutateCustomerLabels][google.ads.googleads.v16.services.CustomerLabelService.MutateCustomerLabels].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCustomerLabelsRequest {
    /// Required. ID of the customer whose customer-label relationships are being
    /// modified.
    #[prost(string, tag = "1")]
    pub customer_id: ::prost::alloc::string::String,
    /// Required. The list of operations to perform on customer-label
    /// relationships.
    #[prost(message, repeated, tag = "2")]
    pub operations: ::prost::alloc::vec::Vec<CustomerLabelOperation>,
    /// If true, successful operations will be carried out and invalid
    /// operations will return errors. If false, all operations will be carried
    /// out in one transaction if and only if they are all valid.
    /// Default is false.
    #[prost(bool, tag = "3")]
    pub partial_failure: bool,
    /// If true, the request is validated but not executed. Only errors are
    /// returned, not results.
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
}
/// A single operation (create, remove) on a customer-label relationship.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CustomerLabelOperation {
    /// The mutate operation.
    #[prost(oneof = "customer_label_operation::Operation", tags = "1, 2")]
    pub operation: ::core::option::Option<customer_label_operation::Operation>,
}
/// Nested message and enum types in `CustomerLabelOperation`.
pub mod customer_label_operation {
    /// The mutate operation.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Operation {
        /// Create operation: No resource name is expected for the new customer-label
        /// relationship.
        #[prost(message, tag = "1")]
        Create(super::super::resources::CustomerLabel),
        /// Remove operation: A resource name for the customer-label relationship
        /// being removed, in this format:
        ///
        /// `customers/{customer_id}/customerLabels/{label_id}`
        #[prost(string, tag = "2")]
        Remove(::prost::alloc::string::String),
    }
}
/// Response message for a customer labels mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCustomerLabelsResponse {
    /// Errors that pertain to operation failures in the partial failure mode.
    /// Returned only when partial_failure = true and all errors occur inside the
    /// operations. If any errors occur outside the operations (for example, auth
    /// errors), we return an RPC level error.
    #[prost(message, optional, tag = "3")]
    pub partial_failure_error: ::core::option::Option<
        super::super::super::super::rpc::Status,
    >,
    /// All results for the mutate.
    #[prost(message, repeated, tag = "2")]
    pub results: ::prost::alloc::vec::Vec<MutateCustomerLabelResult>,
}
/// The result for a customer label mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCustomerLabelResult {
    /// Returned for successful operations.
    #[prost(string, tag = "1")]
    pub resource_name: ::prost::alloc::string::String,
}
/// Generated server implementations.
pub mod customer_label_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with CustomerLabelServiceServer.
    #[async_trait]
    pub trait CustomerLabelService: std::marker::Send + std::marker::Sync + 'static {
        /// Creates and removes customer-label relationships.
        /// Operation statuses are returned.
        ///
        /// List of thrown errors:
        ///   [AuthenticationError]()
        ///   [AuthorizationError]()
        ///   [DatabaseError]()
        ///   [HeaderError]()
        ///   [InternalError]()
        ///   [LabelError]()
        ///   [MutateError]()
        ///   [QuotaError]()
        ///   [RequestError]()
        async fn mutate_customer_labels(
            &self,
            request: tonic::Request<super::MutateCustomerLabelsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MutateCustomerLabelsResponse>,
            tonic::Status,
        >;
    }
    /// Service to manage labels on customers.
    #[derive(Debug)]
    pub struct CustomerLabelServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> CustomerLabelServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>>
    for CustomerLabelServiceServer<T>
    where
        T: CustomerLabelService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/google.ads.googleads.v16.services.CustomerLabelService/MutateCustomerLabels" => {
                    #[allow(non_camel_case_types)]
                    struct MutateCustomerLabelsSvc<T: CustomerLabelService>(pub Arc<T>);
                    impl<
                        T: CustomerLabelService,
                    > tonic::server::UnaryService<super::MutateCustomerLabelsRequest>
                    for MutateCustomerLabelsSvc<T> {
                        type Response = super::MutateCustomerLabelsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::MutateCustomerLabelsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as CustomerLabelService>::mutate_customer_labels(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = MutateCustomerLabelsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for CustomerLabelServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "google.ads.googleads.v16.services.CustomerLabelService";
    impl<T> tonic::server::NamedService for CustomerLabelServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Request message for
/// [CustomerNegativeCriterionService.MutateCustomerNegativeCriteria][google.ads.googleads.v16.services.CustomerNegativeCriterionService.MutateCustomerNegativeCriteria].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCustomerNegativeCriteriaRequest {
    /// Required. The ID of the customer whose criteria are being modified.
    #[prost(string, tag = "1")]
    pub customer_id: ::prost::alloc::string::String,
    /// Required. The list of operations to perform on individual criteria.
    #[prost(message, repeated, tag = "2")]
    pub operations: ::prost::alloc::vec::Vec<CustomerNegativeCriterionOperation>,
    /// If true, successful operations will be carried out and invalid
    /// operations will return errors. If false, all operations will be carried
    /// out in one transaction if and only if they are all valid.
    /// Default is false.
    #[prost(bool, tag = "3")]
    pub partial_failure: bool,
    /// If true, the request is validated but not executed. Only errors are
    /// returned, not results.
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
    /// The response content type setting. Determines whether the mutable resource
    /// or just the resource name should be returned post mutation.
    #[prost(
        enumeration = "super::enums::response_content_type_enum::ResponseContentType",
        tag = "5"
    )]
    pub response_content_type: i32,
}
/// A single operation (create or remove) on a customer level negative criterion.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CustomerNegativeCriterionOperation {
    /// The mutate operation.
    #[prost(oneof = "customer_negative_criterion_operation::Operation", tags = "1, 2")]
    pub operation: ::core::option::Option<
        customer_negative_criterion_operation::Operation,
    >,
}
/// Nested message and enum types in `CustomerNegativeCriterionOperation`.
pub mod customer_negative_criterion_operation {
    /// The mutate operation.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Operation {
        /// Create operation: No resource name is expected for the new criterion.
        #[prost(message, tag = "1")]
        Create(super::super::resources::CustomerNegativeCriterion),
        /// Remove operation: A resource name for the removed criterion is expected,
        /// in this format:
        ///
        /// `customers/{customer_id}/customerNegativeCriteria/{criterion_id}`
        #[prost(string, tag = "2")]
        Remove(::prost::alloc::string::String),
    }
}
/// Response message for customer negative criterion mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCustomerNegativeCriteriaResponse {
    /// Errors that pertain to operation failures in the partial failure mode.
    /// Returned only when partial_failure = true and all errors occur inside the
    /// operations. If any errors occur outside the operations (for example, auth
    /// errors), we return an RPC level error.
    #[prost(message, optional, tag = "3")]
    pub partial_failure_error: ::core::option::Option<
        super::super::super::super::rpc::Status,
    >,
    /// All results for the mutate.
    #[prost(message, repeated, tag = "2")]
    pub results: ::prost::alloc::vec::Vec<MutateCustomerNegativeCriteriaResult>,
}
/// The result for the criterion mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCustomerNegativeCriteriaResult {
    /// Returned for successful operations.
    #[prost(string, tag = "1")]
    pub resource_name: ::prost::alloc::string::String,
    /// The mutated criterion with only mutable fields after mutate. The field will
    /// only be returned when response_content_type is set to "MUTABLE_RESOURCE".
    #[prost(message, optional, tag = "2")]
    pub customer_negative_criterion: ::core::option::Option<
        super::resources::CustomerNegativeCriterion,
    >,
}
/// Generated server implementations.
pub mod customer_negative_criterion_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with CustomerNegativeCriterionServiceServer.
    #[async_trait]
    pub trait CustomerNegativeCriterionService: std::marker::Send + std::marker::Sync + 'static {
        /// Creates or removes criteria. Operation statuses are returned.
        ///
        /// List of thrown errors:
        ///   [AuthenticationError]()
        ///   [AuthorizationError]()
        ///   [CriterionError]()
        ///   [DatabaseError]()
        ///   [FieldError]()
        ///   [HeaderError]()
        ///   [InternalError]()
        ///   [MutateError]()
        ///   [QuotaError]()
        ///   [RequestError]()
        async fn mutate_customer_negative_criteria(
            &self,
            request: tonic::Request<super::MutateCustomerNegativeCriteriaRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MutateCustomerNegativeCriteriaResponse>,
            tonic::Status,
        >;
    }
    /// Service to manage customer negative criteria.
    #[derive(Debug)]
    pub struct CustomerNegativeCriterionServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> CustomerNegativeCriterionServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>>
    for CustomerNegativeCriterionServiceServer<T>
    where
        T: CustomerNegativeCriterionService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/google.ads.googleads.v16.services.CustomerNegativeCriterionService/MutateCustomerNegativeCriteria" => {
                    #[allow(non_camel_case_types)]
                    struct MutateCustomerNegativeCriteriaSvc<
                        T: CustomerNegativeCriterionService,
                    >(
                        pub Arc<T>,
                    );
                    impl<
                        T: CustomerNegativeCriterionService,
                    > tonic::server::UnaryService<
                        super::MutateCustomerNegativeCriteriaRequest,
                    > for MutateCustomerNegativeCriteriaSvc<T> {
                        type Response = super::MutateCustomerNegativeCriteriaResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::MutateCustomerNegativeCriteriaRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as CustomerNegativeCriterionService>::mutate_customer_negative_criteria(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = MutateCustomerNegativeCriteriaSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for CustomerNegativeCriterionServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "google.ads.googleads.v16.services.CustomerNegativeCriterionService";
    impl<T> tonic::server::NamedService for CustomerNegativeCriterionServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Request message for
/// [CustomerService.MutateCustomer][google.ads.googleads.v16.services.CustomerService.MutateCustomer].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCustomerRequest {
    /// Required. The ID of the customer being modified.
    #[prost(string, tag = "1")]
    pub customer_id: ::prost::alloc::string::String,
    /// Required. The operation to perform on the customer
    #[prost(message, optional, tag = "4")]
    pub operation: ::core::option::Option<CustomerOperation>,
    /// If true, the request is validated but not executed. Only errors are
    /// returned, not results.
    #[prost(bool, tag = "5")]
    pub validate_only: bool,
    /// The response content type setting. Determines whether the mutable resource
    /// or just the resource name should be returned post mutation.
    #[prost(
        enumeration = "super::enums::response_content_type_enum::ResponseContentType",
        tag = "6"
    )]
    pub response_content_type: i32,
}
/// Request message for
/// [CustomerService.CreateCustomerClient][google.ads.googleads.v16.services.CustomerService.CreateCustomerClient].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateCustomerClientRequest {
    /// Required. The ID of the Manager under whom client customer is being
    /// created.
    #[prost(string, tag = "1")]
    pub customer_id: ::prost::alloc::string::String,
    /// Required. The new client customer to create. The resource name on this
    /// customer will be ignored.
    #[prost(message, optional, tag = "2")]
    pub customer_client: ::core::option::Option<super::resources::Customer>,
    /// Email address of the user who should be invited on the created client
    /// customer. Accessible only to customers on the allow-list.
    #[prost(string, optional, tag = "5")]
    pub email_address: ::core::option::Option<::prost::alloc::string::String>,
    /// The proposed role of user on the created client customer.
    /// Accessible only to customers on the allow-list.
    #[prost(enumeration = "super::enums::access_role_enum::AccessRole", tag = "4")]
    pub access_role: i32,
    /// If true, the request is validated but not executed. Only errors are
    /// returned, not results.
    #[prost(bool, tag = "6")]
    pub validate_only: bool,
}
/// A single update on a customer.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CustomerOperation {
    /// Mutate operation. Only updates are supported for customer.
    #[prost(message, optional, tag = "1")]
    pub update: ::core::option::Option<super::resources::Customer>,
    /// FieldMask that determines which resource fields are modified in an update.
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
/// Response message for CreateCustomerClient mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateCustomerClientResponse {
    /// The resource name of the newly created customer. Customer resource names
    /// have the form: `customers/{customer_id}`.
    #[prost(string, tag = "2")]
    pub resource_name: ::prost::alloc::string::String,
    /// Link for inviting user to access the created customer. Accessible to
    /// allowlisted customers only.
    #[prost(string, tag = "3")]
    pub invitation_link: ::prost::alloc::string::String,
}
/// Response message for customer mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCustomerResponse {
    /// Result for the mutate.
    #[prost(message, optional, tag = "2")]
    pub result: ::core::option::Option<MutateCustomerResult>,
}
/// The result for the customer mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCustomerResult {
    /// Returned for successful operations.
    #[prost(string, tag = "1")]
    pub resource_name: ::prost::alloc::string::String,
    /// The mutated customer with only mutable fields after mutate. The fields will
    /// only be returned when response_content_type is set to "MUTABLE_RESOURCE".
    #[prost(message, optional, tag = "2")]
    pub customer: ::core::option::Option<super::resources::Customer>,
}
/// Request message for
/// [CustomerService.ListAccessibleCustomers][google.ads.googleads.v16.services.CustomerService.ListAccessibleCustomers].
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ListAccessibleCustomersRequest {}
/// Response message for
/// [CustomerService.ListAccessibleCustomers][google.ads.googleads.v16.services.CustomerService.ListAccessibleCustomers].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListAccessibleCustomersResponse {
    /// Resource name of customers directly accessible by the
    /// user authenticating the call.
    #[prost(string, repeated, tag = "1")]
    pub resource_names: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Generated server implementations.
pub mod customer_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with CustomerServiceServer.
    #[async_trait]
    pub trait CustomerService: std::marker::Send + std::marker::Sync + 'static {
        /// Updates a customer. Operation statuses are returned.
        ///
        /// List of thrown errors:
        ///   [AuthenticationError]()
        ///   [AuthorizationError]()
        ///   [DatabaseError]()
        ///   [FieldMaskError]()
        ///   [HeaderError]()
        ///   [InternalError]()
        ///   [QuotaError]()
        ///   [RequestError]()
        ///   [UrlFieldError]()
        async fn mutate_customer(
            &self,
            request: tonic::Request<super::MutateCustomerRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MutateCustomerResponse>,
            tonic::Status,
        >;
        /// Returns resource names of customers directly accessible by the
        /// user authenticating the call.
        ///
        /// List of thrown errors:
        ///   [AuthenticationError]()
        ///   [AuthorizationError]()
        ///   [HeaderError]()
        ///   [InternalError]()
        ///   [QuotaError]()
        ///   [RequestError]()
        async fn list_accessible_customers(
            &self,
            request: tonic::Request<super::ListAccessibleCustomersRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListAccessibleCustomersResponse>,
            tonic::Status,
        >;
        /// Creates a new client under manager. The new client customer is returned.
        ///
        /// List of thrown errors:
        ///   [AccessInvitationError]()
        ///   [AuthenticationError]()
        ///   [AuthorizationError]()
        ///   [CurrencyCodeError]()
        ///   [HeaderError]()
        ///   [InternalError]()
        ///   [ManagerLinkError]()
        ///   [QuotaError]()
        ///   [RequestError]()
        ///   [StringLengthError]()
        ///   [TimeZoneError]()
        async fn create_customer_client(
            &self,
            request: tonic::Request<super::CreateCustomerClientRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CreateCustomerClientResponse>,
            tonic::Status,
        >;
    }
    /// Service to manage customers.
    #[derive(Debug)]
    pub struct CustomerServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> CustomerServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for CustomerServiceServer<T>
    where
        T: CustomerService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/google.ads.googleads.v16.services.CustomerService/MutateCustomer" => {
                    #[allow(non_camel_case_types)]
                    struct MutateCustomerSvc<T: CustomerService>(pub Arc<T>);
                    impl<
                        T: CustomerService,
                    > tonic::server::UnaryService<super::MutateCustomerRequest>
                    for MutateCustomerSvc<T> {
                        type Response = super::MutateCustomerResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::MutateCustomerRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as CustomerService>::mutate_customer(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = MutateCustomerSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.ads.googleads.v16.services.CustomerService/ListAccessibleCustomers" => {
                    #[allow(non_camel_case_types)]
                    struct ListAccessibleCustomersSvc<T: CustomerService>(pub Arc<T>);
                    impl<
                        T: CustomerService,
                    > tonic::server::UnaryService<super::ListAccessibleCustomersRequest>
                    for ListAccessibleCustomersSvc<T> {
                        type Response = super::ListAccessibleCustomersResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::ListAccessibleCustomersRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as CustomerService>::list_accessible_customers(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ListAccessibleCustomersSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.ads.googleads.v16.services.CustomerService/CreateCustomerClient" => {
                    #[allow(non_camel_case_types)]
                    struct CreateCustomerClientSvc<T: CustomerService>(pub Arc<T>);
                    impl<
                        T: CustomerService,
                    > tonic::server::UnaryService<super::CreateCustomerClientRequest>
                    for CreateCustomerClientSvc<T> {
                        type Response = super::CreateCustomerClientResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::CreateCustomerClientRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as CustomerService>::create_customer_client(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = CreateCustomerClientSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for CustomerServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "google.ads.googleads.v16.services.CustomerService";
    impl<T> tonic::server::NamedService for CustomerServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Request message for
/// [CustomizerAttributeService.MutateCustomizerAttributes][google.ads.googleads.v16.services.CustomizerAttributeService.MutateCustomizerAttributes].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCustomizerAttributesRequest {
    /// Required. The ID of the customer whose customizer attributes are being
    /// modified.
    #[prost(string, tag = "1")]
    pub customer_id: ::prost::alloc::string::String,
    /// Required. The list of operations to perform on individual customizer
    /// attributes.
    #[prost(message, repeated, tag = "2")]
    pub operations: ::prost::alloc::vec::Vec<CustomizerAttributeOperation>,
    /// If true, successful operations will be carried out and invalid
    /// operations will return errors. If false, all operations will be carried
    /// out in one transaction if and only if they are all valid.
    /// Default is false.
    #[prost(bool, tag = "3")]
    pub partial_failure: bool,
    /// If true, the request is validated but not executed. Only errors are
    /// returned, not results.
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
    /// The response content type setting. Determines whether the mutable resource
    /// or just the resource name should be returned post mutation.
    #[prost(
        enumeration = "super::enums::response_content_type_enum::ResponseContentType",
        tag = "5"
    )]
    pub response_content_type: i32,
}
/// A single operation (create, remove) on a customizer attribute.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CustomizerAttributeOperation {
    /// FieldMask that determines which resource fields are modified in an update.
    #[prost(message, optional, tag = "4")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// The mutate operation.
    #[prost(oneof = "customizer_attribute_operation::Operation", tags = "1, 2")]
    pub operation: ::core::option::Option<customizer_attribute_operation::Operation>,
}
/// Nested message and enum types in `CustomizerAttributeOperation`.
pub mod customizer_attribute_operation {
    /// The mutate operation.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Operation {
        /// Create operation: No resource name is expected for the new customizer
        /// attribute
        #[prost(message, tag = "1")]
        Create(super::super::resources::CustomizerAttribute),
        /// Remove operation: A resource name for the removed customizer attribute is
        /// expected, in this format:
        /// `customers/{customer_id}/customizerAttributes/{customizer_attribute_id}`
        #[prost(string, tag = "2")]
        Remove(::prost::alloc::string::String),
    }
}
/// Response message for a customizer attribute mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCustomizerAttributesResponse {
    /// All results for the mutate.
    #[prost(message, repeated, tag = "1")]
    pub results: ::prost::alloc::vec::Vec<MutateCustomizerAttributeResult>,
    /// Errors that pertain to operation failures in the partial failure mode.
    /// Returned only when partial_failure = true and all errors occur inside the
    /// operations. If any errors occur outside the operations (for example, auth
    /// errors), we return an RPC level error.
    #[prost(message, optional, tag = "2")]
    pub partial_failure_error: ::core::option::Option<
        super::super::super::super::rpc::Status,
    >,
}
/// The result for the customizer attribute mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCustomizerAttributeResult {
    /// Returned for successful operations.
    #[prost(string, tag = "1")]
    pub resource_name: ::prost::alloc::string::String,
    /// The mutated CustomizerAttribute with only mutable fields after mutate.
    /// The field will only be returned when response_content_type is set to
    /// "MUTABLE_RESOURCE".
    #[prost(message, optional, tag = "2")]
    pub customizer_attribute: ::core::option::Option<
        super::resources::CustomizerAttribute,
    >,
}
/// Generated server implementations.
pub mod customizer_attribute_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with CustomizerAttributeServiceServer.
    #[async_trait]
    pub trait CustomizerAttributeService: std::marker::Send + std::marker::Sync + 'static {
        /// Creates, updates or removes customizer attributes. Operation statuses are
        /// returned.
        async fn mutate_customizer_attributes(
            &self,
            request: tonic::Request<super::MutateCustomizerAttributesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MutateCustomizerAttributesResponse>,
            tonic::Status,
        >;
    }
    /// Service to manage customizer attribute
    #[derive(Debug)]
    pub struct CustomizerAttributeServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> CustomizerAttributeServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>>
    for CustomizerAttributeServiceServer<T>
    where
        T: CustomizerAttributeService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/google.ads.googleads.v16.services.CustomizerAttributeService/MutateCustomizerAttributes" => {
                    #[allow(non_camel_case_types)]
                    struct MutateCustomizerAttributesSvc<T: CustomizerAttributeService>(
                        pub Arc<T>,
                    );
                    impl<
                        T: CustomizerAttributeService,
                    > tonic::server::UnaryService<
                        super::MutateCustomizerAttributesRequest,
                    > for MutateCustomizerAttributesSvc<T> {
                        type Response = super::MutateCustomizerAttributesResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::MutateCustomizerAttributesRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as CustomizerAttributeService>::mutate_customizer_attributes(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = MutateCustomizerAttributesSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for CustomizerAttributeServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "google.ads.googleads.v16.services.CustomizerAttributeService";
    impl<T> tonic::server::NamedService for CustomizerAttributeServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Request message for
/// [ExperimentArmService.MutateExperimentArms][google.ads.googleads.v16.services.ExperimentArmService.MutateExperimentArms].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateExperimentArmsRequest {
    /// Required. The ID of the customer whose experiments are being modified.
    #[prost(string, tag = "1")]
    pub customer_id: ::prost::alloc::string::String,
    /// Required. The list of operations to perform on individual experiment arm.
    #[prost(message, repeated, tag = "2")]
    pub operations: ::prost::alloc::vec::Vec<ExperimentArmOperation>,
    /// If true, successful operations will be carried out and invalid
    /// operations will return errors. If false, all operations will be carried
    /// out in one transaction if and only if they are all valid.
    /// Default is false.
    #[prost(bool, tag = "3")]
    pub partial_failure: bool,
    /// If true, the request is validated but not executed. Only errors are
    /// returned, not results.
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
    /// The response content type setting. Determines whether the mutable resource
    /// or just the resource name should be returned post mutation.
    #[prost(
        enumeration = "super::enums::response_content_type_enum::ResponseContentType",
        tag = "5"
    )]
    pub response_content_type: i32,
}
/// A single operation on an experiment arm.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExperimentArmOperation {
    /// FieldMask that determines which resource fields are modified in an update.
    #[prost(message, optional, tag = "4")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// The mutate operation.
    #[prost(oneof = "experiment_arm_operation::Operation", tags = "1, 2, 3")]
    pub operation: ::core::option::Option<experiment_arm_operation::Operation>,
}
/// Nested message and enum types in `ExperimentArmOperation`.
pub mod experiment_arm_operation {
    /// The mutate operation.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Operation {
        /// Create operation
        #[prost(message, tag = "1")]
        Create(super::super::resources::ExperimentArm),
        /// Update operation: The experiment arm is expected to have a valid
        /// resource name.
        #[prost(message, tag = "2")]
        Update(super::super::resources::ExperimentArm),
        /// Remove operation: The experiment arm is expected to have a valid
        /// resource name, in this format:
        ///
        /// `customers/{customer_id}/experiments/{campaign_experiment_id}`
        #[prost(string, tag = "3")]
        Remove(::prost::alloc::string::String),
    }
}
/// Response message for experiment arm mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateExperimentArmsResponse {
    /// Errors that pertain to operation failures in the partial failure mode.
    /// Returned only when partial_failure = true and all errors occur inside the
    /// operations. If any errors occur outside the operations (for example, auth
    /// errors), we return an RPC level error.
    #[prost(message, optional, tag = "1")]
    pub partial_failure_error: ::core::option::Option<
        super::super::super::super::rpc::Status,
    >,
    /// All results for the mutate.
    #[prost(message, repeated, tag = "2")]
    pub results: ::prost::alloc::vec::Vec<MutateExperimentArmResult>,
}
/// The result for the experiment arm mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateExperimentArmResult {
    /// Returned for successful operations.
    #[prost(string, tag = "1")]
    pub resource_name: ::prost::alloc::string::String,
    /// The mutated experiment arm with only mutable fields after mutate. The
    /// field will only be returned when response_content_type is set to
    /// "MUTABLE_RESOURCE".
    #[prost(message, optional, tag = "2")]
    pub experiment_arm: ::core::option::Option<super::resources::ExperimentArm>,
}
/// Generated server implementations.
pub mod experiment_arm_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with ExperimentArmServiceServer.
    #[async_trait]
    pub trait ExperimentArmService: std::marker::Send + std::marker::Sync + 'static {
        /// Creates, updates, or removes experiment arms. Operation statuses are
        /// returned.
        ///
        /// List of thrown errors:
        ///   [AuthenticationError]()
        ///   [AuthorizationError]()
        ///   [ExperimentArmError]()
        ///   [HeaderError]()
        ///   [InternalError]()
        ///   [QuotaError]()
        ///   [RequestError]()
        async fn mutate_experiment_arms(
            &self,
            request: tonic::Request<super::MutateExperimentArmsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MutateExperimentArmsResponse>,
            tonic::Status,
        >;
    }
    /// Service to manage experiment arms.
    #[derive(Debug)]
    pub struct ExperimentArmServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> ExperimentArmServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>>
    for ExperimentArmServiceServer<T>
    where
        T: ExperimentArmService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/google.ads.googleads.v16.services.ExperimentArmService/MutateExperimentArms" => {
                    #[allow(non_camel_case_types)]
                    struct MutateExperimentArmsSvc<T: ExperimentArmService>(pub Arc<T>);
                    impl<
                        T: ExperimentArmService,
                    > tonic::server::UnaryService<super::MutateExperimentArmsRequest>
                    for MutateExperimentArmsSvc<T> {
                        type Response = super::MutateExperimentArmsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::MutateExperimentArmsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ExperimentArmService>::mutate_experiment_arms(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = MutateExperimentArmsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for ExperimentArmServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "google.ads.googleads.v16.services.ExperimentArmService";
    impl<T> tonic::server::NamedService for ExperimentArmServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Request message for
/// [ExperimentService.MutateExperiments][google.ads.googleads.v16.services.ExperimentService.MutateExperiments].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateExperimentsRequest {
    /// Required. The ID of the customer whose experiments are being modified.
    #[prost(string, tag = "1")]
    pub customer_id: ::prost::alloc::string::String,
    /// Required. The list of operations to perform on individual experiments.
    #[prost(message, repeated, tag = "2")]
    pub operations: ::prost::alloc::vec::Vec<ExperimentOperation>,
    /// If true, successful operations will be carried out and invalid
    /// operations will return errors. If false, all operations will be carried
    /// out in one transaction if and only if they are all valid.
    /// Default is false.
    #[prost(bool, tag = "3")]
    pub partial_failure: bool,
    /// If true, the request is validated but not executed. Only errors are
    /// returned, not results.
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
}
/// A single operation on an experiment.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExperimentOperation {
    /// FieldMask that determines which resource fields are modified in an update.
    #[prost(message, optional, tag = "4")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// The mutate operation.
    #[prost(oneof = "experiment_operation::Operation", tags = "1, 2, 3")]
    pub operation: ::core::option::Option<experiment_operation::Operation>,
}
/// Nested message and enum types in `ExperimentOperation`.
pub mod experiment_operation {
    /// The mutate operation.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Operation {
        /// Create operation
        #[prost(message, tag = "1")]
        Create(super::super::resources::Experiment),
        /// Update operation: The experiment is expected to have a valid
        /// resource name.
        #[prost(message, tag = "2")]
        Update(super::super::resources::Experiment),
        /// Remove operation: The experiment is expected to have a valid
        /// resource name, in this format:
        ///
        /// `customers/{customer_id}/experiments/{campaign_experiment_id}`
        #[prost(string, tag = "3")]
        Remove(::prost::alloc::string::String),
    }
}
/// Response message for experiment mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateExperimentsResponse {
    /// Errors that pertain to operation failures in the partial failure mode.
    /// Returned only when partial_failure = true and all errors occur inside the
    /// operations. If any errors occur outside the operations (for example, auth
    /// errors), we return an RPC level error.
    #[prost(message, optional, tag = "1")]
    pub partial_failure_error: ::core::option::Option<
        super::super::super::super::rpc::Status,
    >,
    /// All results for the mutate.
    #[prost(message, repeated, tag = "2")]
    pub results: ::prost::alloc::vec::Vec<MutateExperimentResult>,
}
/// The result for the campaign experiment mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateExperimentResult {
    /// Returned for successful operations.
    #[prost(string, tag = "1")]
    pub resource_name: ::prost::alloc::string::String,
}
/// Request message for
/// [ExperimentService.EndExperiment][google.ads.googleads.v16.services.ExperimentService.EndExperiment].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EndExperimentRequest {
    /// Required. The resource name of the campaign experiment to end.
    #[prost(string, tag = "1")]
    pub experiment: ::prost::alloc::string::String,
    /// If true, the request is validated but not executed. Only errors are
    /// returned, not results.
    #[prost(bool, tag = "2")]
    pub validate_only: bool,
}
/// Request message for
/// [ExperimentService.ListExperimentAsyncErrors][google.ads.googleads.v16.services.ExperimentService.ListExperimentAsyncErrors].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListExperimentAsyncErrorsRequest {
    /// Required. The name of the experiment from which to retrieve the async
    /// errors.
    #[prost(string, tag = "1")]
    pub resource_name: ::prost::alloc::string::String,
    /// Token of the page to retrieve. If not specified, the first
    /// page of results will be returned. Use the value obtained from
    /// `next_page_token` in the previous response in order to request
    /// the next page of results.
    #[prost(string, tag = "2")]
    pub page_token: ::prost::alloc::string::String,
    /// Number of elements to retrieve in a single page.
    /// When a page request is too large, the server may decide to
    /// further limit the number of returned resources.
    /// The maximum page size is 1000.
    #[prost(int32, tag = "3")]
    pub page_size: i32,
}
/// Response message for
/// [ExperimentService.ListExperimentAsyncErrors][google.ads.googleads.v16.services.ExperimentService.ListExperimentAsyncErrors].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListExperimentAsyncErrorsResponse {
    /// details of the errors when performing the asynchronous operation.
    #[prost(message, repeated, tag = "1")]
    pub errors: ::prost::alloc::vec::Vec<super::super::super::super::rpc::Status>,
    /// Pagination token used to retrieve the next page of results.
    /// Pass the content of this string as the `page_token` attribute of
    /// the next request. `next_page_token` is not returned for the last
    /// page.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// Request message for
/// [ExperimentService.GraduateExperiment][google.ads.googleads.v16.services.ExperimentService.GraduateExperiment].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GraduateExperimentRequest {
    /// Required. The experiment to be graduated.
    #[prost(string, tag = "1")]
    pub experiment: ::prost::alloc::string::String,
    /// Required. List of campaign budget mappings for graduation. Each campaign
    /// that appears here will graduate, and will be assigned a new budget that is
    /// paired with it in the mapping. The maximum size is one.
    #[prost(message, repeated, tag = "2")]
    pub campaign_budget_mappings: ::prost::alloc::vec::Vec<CampaignBudgetMapping>,
    /// If true, the request is validated but not executed. Only errors are
    /// returned, not results.
    #[prost(bool, tag = "3")]
    pub validate_only: bool,
}
/// The mapping of experiment campaign and budget to be graduated.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CampaignBudgetMapping {
    /// Required. The experiment campaign to graduate.
    #[prost(string, tag = "1")]
    pub experiment_campaign: ::prost::alloc::string::String,
    /// Required. The budget that should be attached to the graduating experiment
    /// campaign.
    #[prost(string, tag = "2")]
    pub campaign_budget: ::prost::alloc::string::String,
}
/// Request message for
/// [ExperimentService.ScheduleExperiment][google.ads.googleads.v16.services.ExperimentService.ScheduleExperiment].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ScheduleExperimentRequest {
    /// Required. The scheduled experiment.
    #[prost(string, tag = "1")]
    pub resource_name: ::prost::alloc::string::String,
    /// If true, the request is validated but not executed. Only errors are
    /// returned, not results.
    #[prost(bool, tag = "2")]
    pub validate_only: bool,
}
/// The metadata of the scheduled experiment.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ScheduleExperimentMetadata {
    /// Required. The scheduled experiment.
    #[prost(string, tag = "1")]
    pub experiment: ::prost::alloc::string::String,
}
/// Request message for
/// [ExperimentService.PromoteExperiment][google.ads.googleads.v16.services.ExperimentService.PromoteExperiment].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PromoteExperimentRequest {
    /// Required. The resource name of the experiment to promote.
    #[prost(string, tag = "1")]
    pub resource_name: ::prost::alloc::string::String,
    /// If true, the request is validated but not executed. Only errors are
    /// returned, not results.
    #[prost(bool, tag = "2")]
    pub validate_only: bool,
}
/// The metadata of the promoted experiment.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PromoteExperimentMetadata {
    /// Required. The promoted experiment.
    #[prost(string, tag = "1")]
    pub experiment: ::prost::alloc::string::String,
}
/// Generated server implementations.
pub mod experiment_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with ExperimentServiceServer.
    #[async_trait]
    pub trait ExperimentService: std::marker::Send + std::marker::Sync + 'static {
        /// Creates, updates, or removes experiments. Operation statuses are returned.
        ///
        /// List of thrown errors:
        ///   [AuthenticationError]()
        ///   [AuthorizationError]()
        ///   [ExperimentError]()
        ///   [HeaderError]()
        ///   [InternalError]()
        ///   [QuotaError]()
        ///   [RequestError]()
        async fn mutate_experiments(
            &self,
            request: tonic::Request<super::MutateExperimentsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MutateExperimentsResponse>,
            tonic::Status,
        >;
        /// Immediately ends an experiment, changing the experiment's scheduled
        /// end date and without waiting for end of day. End date is updated to be the
        /// time of the request.
        ///
        /// List of thrown errors:
        ///   [AuthenticationError]()
        ///   [AuthorizationError]()
        ///   [ExperimentError]()
        ///   [HeaderError]()
        ///   [InternalError]()
        ///   [QuotaError]()
        ///   [RequestError]()
        async fn end_experiment(
            &self,
            request: tonic::Request<super::EndExperimentRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status>;
        /// Returns all errors that occurred during the last Experiment update (either
        /// scheduling or promotion).
        /// Supports standard list paging.
        ///
        /// List of thrown errors:
        ///   [AuthenticationError]()
        ///   [AuthorizationError]()
        ///   [HeaderError]()
        ///   [InternalError]()
        ///   [QuotaError]()
        ///   [RequestError]()
        async fn list_experiment_async_errors(
            &self,
            request: tonic::Request<super::ListExperimentAsyncErrorsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListExperimentAsyncErrorsResponse>,
            tonic::Status,
        >;
        /// Graduates an experiment to a full campaign.
        ///
        /// List of thrown errors:
        ///   [AuthenticationError]()
        ///   [AuthorizationError]()
        ///   [ExperimentError]()
        ///   [HeaderError]()
        ///   [InternalError]()
        ///   [MutateError]()
        ///   [QuotaError]()
        ///   [RequestError]()
        async fn graduate_experiment(
            &self,
            request: tonic::Request<super::GraduateExperimentRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status>;
        /// Schedule an experiment. The in design campaign
        /// will be converted into a real campaign (called the experiment campaign)
        /// that will begin serving ads if successfully created.
        ///
        /// The experiment is scheduled immediately with status INITIALIZING.
        /// This method returns a long running operation that tracks the forking of the
        /// in design campaign. If the forking fails, a list of errors can be retrieved
        /// using the ListExperimentAsyncErrors method. The operation's
        /// metadata will be a string containing the resource name of the created
        /// experiment.
        ///
        /// List of thrown errors:
        ///   [AuthenticationError]()
        ///   [AuthorizationError]()
        ///   [ExperimentError]()
        ///   [DatabaseError]()
        ///   [DateError]()
        ///   [DateRangeError]()
        ///   [FieldError]()
        ///   [HeaderError]()
        ///   [InternalError]()
        ///   [QuotaError]()
        ///   [RangeError]()
        ///   [RequestError]()
        async fn schedule_experiment(
            &self,
            request: tonic::Request<super::ScheduleExperimentRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::super::longrunning::Operation>,
            tonic::Status,
        >;
        /// Promotes the trial campaign thus applying changes in the trial campaign
        /// to the base campaign.
        /// This method returns a long running operation that tracks the promotion of
        /// the experiment campaign. If it fails, a list of errors can be retrieved
        /// using the ListExperimentAsyncErrors method. The operation's
        /// metadata will be a string containing the resource name of the created
        /// experiment.
        ///
        /// List of thrown errors:
        ///   [AuthenticationError]()
        ///   [AuthorizationError]()
        ///   [ExperimentError]()
        ///   [HeaderError]()
        ///   [InternalError]()
        ///   [QuotaError]()
        ///   [RequestError]()
        async fn promote_experiment(
            &self,
            request: tonic::Request<super::PromoteExperimentRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::super::longrunning::Operation>,
            tonic::Status,
        >;
    }
    /// Service to manage experiments.
    #[derive(Debug)]
    pub struct ExperimentServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> ExperimentServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for ExperimentServiceServer<T>
    where
        T: ExperimentService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/google.ads.googleads.v16.services.ExperimentService/MutateExperiments" => {
                    #[allow(non_camel_case_types)]
                    struct MutateExperimentsSvc<T: ExperimentService>(pub Arc<T>);
                    impl<
                        T: ExperimentService,
                    > tonic::server::UnaryService<super::MutateExperimentsRequest>
                    for MutateExperimentsSvc<T> {
                        type Response = super::MutateExperimentsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::MutateExperimentsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ExperimentService>::mutate_experiments(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = MutateExperimentsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.ads.googleads.v16.services.ExperimentService/EndExperiment" => {
                    #[allow(non_camel_case_types)]
                    struct EndExperimentSvc<T: ExperimentService>(pub Arc<T>);
                    impl<
                        T: ExperimentService,
                    > tonic::server::UnaryService<super::EndExperimentRequest>
                    for EndExperimentSvc<T> {
                        type Response = ();
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::EndExperimentRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ExperimentService>::end_experiment(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = EndExperimentSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.ads.googleads.v16.services.ExperimentService/ListExperimentAsyncErrors" => {
                    #[allow(non_camel_case_types)]
                    struct ListExperimentAsyncErrorsSvc<T: ExperimentService>(
                        pub Arc<T>,
                    );
                    impl<
                        T: ExperimentService,
                    > tonic::server::UnaryService<
                        super::ListExperimentAsyncErrorsRequest,
                    > for ListExperimentAsyncErrorsSvc<T> {
                        type Response = super::ListExperimentAsyncErrorsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::ListExperimentAsyncErrorsRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ExperimentService>::list_experiment_async_errors(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ListExperimentAsyncErrorsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.ads.googleads.v16.services.ExperimentService/GraduateExperiment" => {
                    #[allow(non_camel_case_types)]
                    struct GraduateExperimentSvc<T: ExperimentService>(pub Arc<T>);
                    impl<
                        T: ExperimentService,
                    > tonic::server::UnaryService<super::GraduateExperimentRequest>
                    for GraduateExperimentSvc<T> {
                        type Response = ();
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GraduateExperimentRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ExperimentService>::graduate_experiment(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GraduateExperimentSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.ads.googleads.v16.services.ExperimentService/ScheduleExperiment" => {
                    #[allow(non_camel_case_types)]
                    struct ScheduleExperimentSvc<T: ExperimentService>(pub Arc<T>);
                    impl<
                        T: ExperimentService,
                    > tonic::server::UnaryService<super::ScheduleExperimentRequest>
                    for ScheduleExperimentSvc<T> {
                        type Response = super::super::super::super::super::longrunning::Operation;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ScheduleExperimentRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ExperimentService>::schedule_experiment(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ScheduleExperimentSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.ads.googleads.v16.services.ExperimentService/PromoteExperiment" => {
                    #[allow(non_camel_case_types)]
                    struct PromoteExperimentSvc<T: ExperimentService>(pub Arc<T>);
                    impl<
                        T: ExperimentService,
                    > tonic::server::UnaryService<super::PromoteExperimentRequest>
                    for PromoteExperimentSvc<T> {
                        type Response = super::super::super::super::super::longrunning::Operation;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::PromoteExperimentRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ExperimentService>::promote_experiment(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = PromoteExperimentSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for ExperimentServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "google.ads.googleads.v16.services.ExperimentService";
    impl<T> tonic::server::NamedService for ExperimentServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Request message for
/// [ExtensionFeedItemService.MutateExtensionFeedItems][google.ads.googleads.v16.services.ExtensionFeedItemService.MutateExtensionFeedItems].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateExtensionFeedItemsRequest {
    /// Required. The ID of the customer whose extension feed items are being
    /// modified.
    #[prost(string, tag = "1")]
    pub customer_id: ::prost::alloc::string::String,
    /// Required. The list of operations to perform on individual extension feed
    /// items.
    #[prost(message, repeated, tag = "2")]
    pub operations: ::prost::alloc::vec::Vec<ExtensionFeedItemOperation>,
    /// If true, successful operations will be carried out and invalid
    /// operations will return errors. If false, all operations will be carried
    /// out in one transaction if and only if they are all valid.
    /// Default is false.
    #[prost(bool, tag = "3")]
    pub partial_failure: bool,
    /// If true, the request is validated but not executed. Only errors are
    /// returned, not results.
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
    /// The response content type setting. Determines whether the mutable resource
    /// or just the resource name should be returned post mutation.
    #[prost(
        enumeration = "super::enums::response_content_type_enum::ResponseContentType",
        tag = "5"
    )]
    pub response_content_type: i32,
}
/// A single operation (create, update, remove) on an extension feed item.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExtensionFeedItemOperation {
    /// FieldMask that determines which resource fields are modified in an update.
    #[prost(message, optional, tag = "4")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// The mutate operation.
    #[prost(oneof = "extension_feed_item_operation::Operation", tags = "1, 2, 3")]
    pub operation: ::core::option::Option<extension_feed_item_operation::Operation>,
}
/// Nested message and enum types in `ExtensionFeedItemOperation`.
pub mod extension_feed_item_operation {
    /// The mutate operation.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Operation {
        /// Create operation: No resource name is expected for the new extension
        /// feed item.
        #[prost(message, tag = "1")]
        Create(super::super::resources::ExtensionFeedItem),
        /// Update operation: The extension feed item is expected to have a
        /// valid resource name.
        #[prost(message, tag = "2")]
        Update(super::super::resources::ExtensionFeedItem),
        /// Remove operation: A resource name for the removed extension feed item
        /// is expected, in this format:
        ///
        /// `customers/{customer_id}/extensionFeedItems/{feed_item_id}`
        #[prost(string, tag = "3")]
        Remove(::prost::alloc::string::String),
    }
}
/// Response message for an extension feed item mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateExtensionFeedItemsResponse {
    /// Errors that pertain to operation failures in the partial failure mode.
    /// Returned only when partial_failure = true and all errors occur inside the
    /// operations. If any errors occur outside the operations (for example, auth
    /// errors), we return an RPC level error.
    #[prost(message, optional, tag = "3")]
    pub partial_failure_error: ::core::option::Option<
        super::super::super::super::rpc::Status,
    >,
    /// All results for the mutate.
    #[prost(message, repeated, tag = "2")]
    pub results: ::prost::alloc::vec::Vec<MutateExtensionFeedItemResult>,
}
/// The result for the extension feed item mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateExtensionFeedItemResult {
    /// Returned for successful operations.
    #[prost(string, tag = "1")]
    pub resource_name: ::prost::alloc::string::String,
    /// The mutated extension feed item with only mutable fields after mutate. The
    /// field will only be returned when response_content_type is set to
    /// "MUTABLE_RESOURCE".
    #[prost(message, optional, tag = "2")]
    pub extension_feed_item: ::core::option::Option<super::resources::ExtensionFeedItem>,
}
/// Generated server implementations.
pub mod extension_feed_item_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with ExtensionFeedItemServiceServer.
    #[async_trait]
    pub trait ExtensionFeedItemService: std::marker::Send + std::marker::Sync + 'static {
        /// Creates, updates, or removes extension feed items. Operation
        /// statuses are returned.
        ///
        /// List of thrown errors:
        ///   [AuthenticationError]()
        ///   [AuthorizationError]()
        ///   [CollectionSizeError]()
        ///   [CountryCodeError]()
        ///   [DatabaseError]()
        ///   [DateError]()
        ///   [DistinctError]()
        ///   [ExtensionFeedItemError]()
        ///   [FieldError]()
        ///   [FieldMaskError]()
        ///   [HeaderError]()
        ///   [ImageError]()
        ///   [InternalError]()
        ///   [LanguageCodeError]()
        ///   [MutateError]()
        ///   [NewResourceCreationError]()
        ///   [OperationAccessDeniedError]()
        ///   [QuotaError]()
        ///   [RangeError]()
        ///   [RequestError]()
        ///   [SizeLimitError]()
        ///   [StringLengthError]()
        ///   [UrlFieldError]()
        async fn mutate_extension_feed_items(
            &self,
            request: tonic::Request<super::MutateExtensionFeedItemsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MutateExtensionFeedItemsResponse>,
            tonic::Status,
        >;
    }
    /// Service to manage extension feed items.
    #[derive(Debug)]
    pub struct ExtensionFeedItemServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> ExtensionFeedItemServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>>
    for ExtensionFeedItemServiceServer<T>
    where
        T: ExtensionFeedItemService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/google.ads.googleads.v16.services.ExtensionFeedItemService/MutateExtensionFeedItems" => {
                    #[allow(non_camel_case_types)]
                    struct MutateExtensionFeedItemsSvc<T: ExtensionFeedItemService>(
                        pub Arc<T>,
                    );
                    impl<
                        T: ExtensionFeedItemService,
                    > tonic::server::UnaryService<super::MutateExtensionFeedItemsRequest>
                    for MutateExtensionFeedItemsSvc<T> {
                        type Response = super::MutateExtensionFeedItemsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::MutateExtensionFeedItemsRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ExtensionFeedItemService>::mutate_extension_feed_items(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = MutateExtensionFeedItemsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for ExtensionFeedItemServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "google.ads.googleads.v16.services.ExtensionFeedItemService";
    impl<T> tonic::server::NamedService for ExtensionFeedItemServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Request message for
/// [FeedItemService.MutateFeedItems][google.ads.googleads.v16.services.FeedItemService.MutateFeedItems].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateFeedItemsRequest {
    /// Required. The ID of the customer whose feed items are being modified.
    #[prost(string, tag = "1")]
    pub customer_id: ::prost::alloc::string::String,
    /// Required. The list of operations to perform on individual feed items.
    #[prost(message, repeated, tag = "2")]
    pub operations: ::prost::alloc::vec::Vec<FeedItemOperation>,
    /// If true, successful operations will be carried out and invalid
    /// operations will return errors. If false, all operations will be carried
    /// out in one transaction if and only if they are all valid.
    /// Default is false.
    #[prost(bool, tag = "3")]
    pub partial_failure: bool,
    /// If true, the request is validated but not executed. Only errors are
    /// returned, not results.
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
    /// The response content type setting. Determines whether the mutable resource
    /// or just the resource name should be returned post mutation.
    #[prost(
        enumeration = "super::enums::response_content_type_enum::ResponseContentType",
        tag = "5"
    )]
    pub response_content_type: i32,
}
/// A single operation (create, update, remove) on an feed item.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FeedItemOperation {
    /// FieldMask that determines which resource fields are modified in an update.
    #[prost(message, optional, tag = "4")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// The mutate operation.
    #[prost(oneof = "feed_item_operation::Operation", tags = "1, 2, 3")]
    pub operation: ::core::option::Option<feed_item_operation::Operation>,
}
/// Nested message and enum types in `FeedItemOperation`.
pub mod feed_item_operation {
    /// The mutate operation.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Operation {
        /// Create operation: No resource name is expected for the new feed item.
        #[prost(message, tag = "1")]
        Create(super::super::resources::FeedItem),
        /// Update operation: The feed item is expected to have a valid resource
        /// name.
        #[prost(message, tag = "2")]
        Update(super::super::resources::FeedItem),
        /// Remove operation: A resource name for the removed feed item is
        /// expected, in this format:
        ///
        /// `customers/{customer_id}/feedItems/{feed_id}~{feed_item_id}`
        #[prost(string, tag = "3")]
        Remove(::prost::alloc::string::String),
    }
}
/// Response message for an feed item mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateFeedItemsResponse {
    /// Errors that pertain to operation failures in the partial failure mode.
    /// Returned only when partial_failure = true and all errors occur inside the
    /// operations. If any errors occur outside the operations (for example, auth
    /// errors), we return an RPC level error.
    #[prost(message, optional, tag = "3")]
    pub partial_failure_error: ::core::option::Option<
        super::super::super::super::rpc::Status,
    >,
    /// All results for the mutate.
    #[prost(message, repeated, tag = "2")]
    pub results: ::prost::alloc::vec::Vec<MutateFeedItemResult>,
}
/// The result for the feed item mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateFeedItemResult {
    /// Returned for successful operations.
    #[prost(string, tag = "1")]
    pub resource_name: ::prost::alloc::string::String,
    /// The mutated feed item with only mutable fields after mutate. The field will
    /// only be returned when response_content_type is set to "MUTABLE_RESOURCE".
    #[prost(message, optional, tag = "2")]
    pub feed_item: ::core::option::Option<super::resources::FeedItem>,
}
/// Generated server implementations.
pub mod feed_item_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with FeedItemServiceServer.
    #[async_trait]
    pub trait FeedItemService: std::marker::Send + std::marker::Sync + 'static {
        /// Creates, updates, or removes feed items. Operation statuses are
        /// returned.
        ///
        /// List of thrown errors:
        ///   [AuthenticationError]()
        ///   [AuthorizationError]()
        ///   [CollectionSizeError]()
        ///   [CriterionError]()
        ///   [DatabaseError]()
        ///   [DateError]()
        ///   [DistinctError]()
        ///   [FeedItemError]()
        ///   [FieldError]()
        ///   [FieldMaskError]()
        ///   [HeaderError]()
        ///   [IdError]()
        ///   [InternalError]()
        ///   [ListOperationError]()
        ///   [MutateError]()
        ///   [NotEmptyError]()
        ///   [NullError]()
        ///   [OperatorError]()
        ///   [QuotaError]()
        ///   [RangeError]()
        ///   [RequestError]()
        ///   [SizeLimitError]()
        ///   [StringFormatError]()
        ///   [StringLengthError]()
        ///   [UrlFieldError]()
        async fn mutate_feed_items(
            &self,
            request: tonic::Request<super::MutateFeedItemsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MutateFeedItemsResponse>,
            tonic::Status,
        >;
    }
    /// Service to manage feed items.
    #[derive(Debug)]
    pub struct FeedItemServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> FeedItemServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for FeedItemServiceServer<T>
    where
        T: FeedItemService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/google.ads.googleads.v16.services.FeedItemService/MutateFeedItems" => {
                    #[allow(non_camel_case_types)]
                    struct MutateFeedItemsSvc<T: FeedItemService>(pub Arc<T>);
                    impl<
                        T: FeedItemService,
                    > tonic::server::UnaryService<super::MutateFeedItemsRequest>
                    for MutateFeedItemsSvc<T> {
                        type Response = super::MutateFeedItemsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::MutateFeedItemsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as FeedItemService>::mutate_feed_items(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = MutateFeedItemsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for FeedItemServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "google.ads.googleads.v16.services.FeedItemService";
    impl<T> tonic::server::NamedService for FeedItemServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Request message for
/// [FeedItemSetLinkService.MutateFeedItemSetLinks][google.ads.googleads.v16.services.FeedItemSetLinkService.MutateFeedItemSetLinks].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateFeedItemSetLinksRequest {
    /// Required. The ID of the customer whose feed item set links are being
    /// modified.
    #[prost(string, tag = "1")]
    pub customer_id: ::prost::alloc::string::String,
    /// Required. The list of operations to perform on individual feed item set
    /// links.
    #[prost(message, repeated, tag = "2")]
    pub operations: ::prost::alloc::vec::Vec<FeedItemSetLinkOperation>,
    /// If true, successful operations will be carried out and invalid
    /// operations will return errors. If false, all operations will be carried
    /// out in one transaction if and only if they are all valid.
    /// Default is false.
    #[prost(bool, tag = "3")]
    pub partial_failure: bool,
    /// If true, the request is validated but not executed. Only errors are
    /// returned, not results.
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
}
/// A single operation (create, update, remove) on a feed item set link.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FeedItemSetLinkOperation {
    /// The mutate operation.
    #[prost(oneof = "feed_item_set_link_operation::Operation", tags = "1, 2")]
    pub operation: ::core::option::Option<feed_item_set_link_operation::Operation>,
}
/// Nested message and enum types in `FeedItemSetLinkOperation`.
pub mod feed_item_set_link_operation {
    /// The mutate operation.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Operation {
        /// Create operation: No resource name is expected for the
        /// new feed item set link.
        #[prost(message, tag = "1")]
        Create(super::super::resources::FeedItemSetLink),
        /// Remove operation: A resource name for the removed feed item set link is
        /// expected, in this format:
        ///
        /// `customers/{customer_id}/feedItemSetLinks/{feed_id}_{feed_item_set_id}_{feed_item_id}`
        #[prost(string, tag = "2")]
        Remove(::prost::alloc::string::String),
    }
}
/// Response message for a feed item set link mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateFeedItemSetLinksResponse {
    /// All results for the mutate.
    #[prost(message, repeated, tag = "1")]
    pub results: ::prost::alloc::vec::Vec<MutateFeedItemSetLinkResult>,
    /// Errors that pertain to operation failures in the partial failure mode.
    /// Returned only when partial_failure = true and all errors occur inside the
    /// operations. If any errors occur outside the operations (for example, auth
    /// errors), we return an RPC level error.
    #[prost(message, optional, tag = "2")]
    pub partial_failure_error: ::core::option::Option<
        super::super::super::super::rpc::Status,
    >,
}
/// The result for the feed item set link mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateFeedItemSetLinkResult {
    /// Returned for successful operations.
    #[prost(string, tag = "1")]
    pub resource_name: ::prost::alloc::string::String,
}
/// Generated server implementations.
pub mod feed_item_set_link_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with FeedItemSetLinkServiceServer.
    #[async_trait]
    pub trait FeedItemSetLinkService: std::marker::Send + std::marker::Sync + 'static {
        /// Creates, updates, or removes feed item set links.
        ///
        /// List of thrown errors:
        ///   [AuthenticationError]()
        ///   [AuthorizationError]()
        ///   [HeaderError]()
        ///   [InternalError]()
        ///   [QuotaError]()
        ///   [RequestError]()
        async fn mutate_feed_item_set_links(
            &self,
            request: tonic::Request<super::MutateFeedItemSetLinksRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MutateFeedItemSetLinksResponse>,
            tonic::Status,
        >;
    }
    /// Service to manage feed item set links.
    #[derive(Debug)]
    pub struct FeedItemSetLinkServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> FeedItemSetLinkServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>>
    for FeedItemSetLinkServiceServer<T>
    where
        T: FeedItemSetLinkService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/google.ads.googleads.v16.services.FeedItemSetLinkService/MutateFeedItemSetLinks" => {
                    #[allow(non_camel_case_types)]
                    struct MutateFeedItemSetLinksSvc<T: FeedItemSetLinkService>(
                        pub Arc<T>,
                    );
                    impl<
                        T: FeedItemSetLinkService,
                    > tonic::server::UnaryService<super::MutateFeedItemSetLinksRequest>
                    for MutateFeedItemSetLinksSvc<T> {
                        type Response = super::MutateFeedItemSetLinksResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::MutateFeedItemSetLinksRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as FeedItemSetLinkService>::mutate_feed_item_set_links(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = MutateFeedItemSetLinksSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for FeedItemSetLinkServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "google.ads.googleads.v16.services.FeedItemSetLinkService";
    impl<T> tonic::server::NamedService for FeedItemSetLinkServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Request message for
/// [FeedItemSetService.MutateFeedItemSets][google.ads.googleads.v16.services.FeedItemSetService.MutateFeedItemSets].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateFeedItemSetsRequest {
    /// Required. The ID of the customer whose feed item sets are being modified.
    #[prost(string, tag = "1")]
    pub customer_id: ::prost::alloc::string::String,
    /// Required. The list of operations to perform on individual feed item sets.
    #[prost(message, repeated, tag = "2")]
    pub operations: ::prost::alloc::vec::Vec<FeedItemSetOperation>,
    /// If true, successful operations will be carried out and invalid
    /// operations will return errors. If false, all operations will be carried
    /// out in one transaction if and only if they are all valid.
    /// Default is false.
    #[prost(bool, tag = "3")]
    pub partial_failure: bool,
    /// If true, the request is validated but not executed. Only errors are
    /// returned, not results.
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
}
/// A single operation (create, remove) on an feed item set.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FeedItemSetOperation {
    /// FieldMask that determines which resource fields are modified in an update.
    #[prost(message, optional, tag = "4")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// The mutate operation.
    #[prost(oneof = "feed_item_set_operation::Operation", tags = "1, 2, 3")]
    pub operation: ::core::option::Option<feed_item_set_operation::Operation>,
}
/// Nested message and enum types in `FeedItemSetOperation`.
pub mod feed_item_set_operation {
    /// The mutate operation.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Operation {
        /// Create operation: No resource name is expected for the new feed item set
        #[prost(message, tag = "1")]
        Create(super::super::resources::FeedItemSet),
        /// Update operation: The feed item set is expected to have a valid resource
        /// name.
        #[prost(message, tag = "2")]
        Update(super::super::resources::FeedItemSet),
        /// Remove operation: A resource name for the removed feed item is
        /// expected, in this format:
        /// `customers/{customer_id}/feedItems/{feed_id}~{feed_item_set_id}`
        #[prost(string, tag = "3")]
        Remove(::prost::alloc::string::String),
    }
}
/// Response message for an feed item set mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateFeedItemSetsResponse {
    /// All results for the mutate.
    #[prost(message, repeated, tag = "1")]
    pub results: ::prost::alloc::vec::Vec<MutateFeedItemSetResult>,
    /// Errors that pertain to operation failures in the partial failure mode.
    /// Returned only when partial_failure = true and all errors occur inside the
    /// operations. If any errors occur outside the operations (for example, auth
    /// errors), we return an RPC level error.
    #[prost(message, optional, tag = "2")]
    pub partial_failure_error: ::core::option::Option<
        super::super::super::super::rpc::Status,
    >,
}
/// The result for the feed item set mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateFeedItemSetResult {
    /// Returned for successful operations.
    #[prost(string, tag = "1")]
    pub resource_name: ::prost::alloc::string::String,
}
/// Generated server implementations.
pub mod feed_item_set_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with FeedItemSetServiceServer.
    #[async_trait]
    pub trait FeedItemSetService: std::marker::Send + std::marker::Sync + 'static {
        /// Creates, updates or removes feed item sets. Operation statuses are
        /// returned.
        ///
        /// List of thrown errors:
        ///   [AuthenticationError]()
        ///   [AuthorizationError]()
        ///   [HeaderError]()
        ///   [InternalError]()
        ///   [MutateError]()
        ///   [QuotaError]()
        ///   [RequestError]()
        async fn mutate_feed_item_sets(
            &self,
            request: tonic::Request<super::MutateFeedItemSetsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MutateFeedItemSetsResponse>,
            tonic::Status,
        >;
    }
    /// Service to manage feed Item Set
    #[derive(Debug)]
    pub struct FeedItemSetServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> FeedItemSetServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for FeedItemSetServiceServer<T>
    where
        T: FeedItemSetService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/google.ads.googleads.v16.services.FeedItemSetService/MutateFeedItemSets" => {
                    #[allow(non_camel_case_types)]
                    struct MutateFeedItemSetsSvc<T: FeedItemSetService>(pub Arc<T>);
                    impl<
                        T: FeedItemSetService,
                    > tonic::server::UnaryService<super::MutateFeedItemSetsRequest>
                    for MutateFeedItemSetsSvc<T> {
                        type Response = super::MutateFeedItemSetsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::MutateFeedItemSetsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as FeedItemSetService>::mutate_feed_item_sets(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = MutateFeedItemSetsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for FeedItemSetServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "google.ads.googleads.v16.services.FeedItemSetService";
    impl<T> tonic::server::NamedService for FeedItemSetServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Request message for
/// [FeedItemTargetService.MutateFeedItemTargets][google.ads.googleads.v16.services.FeedItemTargetService.MutateFeedItemTargets].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateFeedItemTargetsRequest {
    /// Required. The ID of the customer whose feed item targets are being
    /// modified.
    #[prost(string, tag = "1")]
    pub customer_id: ::prost::alloc::string::String,
    /// Required. The list of operations to perform on individual feed item
    /// targets.
    #[prost(message, repeated, tag = "2")]
    pub operations: ::prost::alloc::vec::Vec<FeedItemTargetOperation>,
    /// If true, successful operations will be carried out and invalid
    /// operations will return errors. If false, all operations will be carried
    /// out in one transaction if and only if they are all valid.
    /// Default is false.
    #[prost(bool, tag = "4")]
    pub partial_failure: bool,
    /// The response content type setting. Determines whether the mutable resource
    /// or just the resource name should be returned post mutation.
    #[prost(
        enumeration = "super::enums::response_content_type_enum::ResponseContentType",
        tag = "5"
    )]
    pub response_content_type: i32,
    /// If true, the request is validated but not executed. Only errors are
    /// returned, not results.
    #[prost(bool, tag = "3")]
    pub validate_only: bool,
}
/// A single operation (create, remove) on an feed item target.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FeedItemTargetOperation {
    /// The mutate operation.
    #[prost(oneof = "feed_item_target_operation::Operation", tags = "1, 2")]
    pub operation: ::core::option::Option<feed_item_target_operation::Operation>,
}
/// Nested message and enum types in `FeedItemTargetOperation`.
pub mod feed_item_target_operation {
    /// The mutate operation.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Operation {
        /// Create operation: No resource name is expected for the new feed item
        /// target.
        #[prost(message, tag = "1")]
        Create(super::super::resources::FeedItemTarget),
        /// Remove operation: A resource name for the removed feed item target is
        /// expected, in this format:
        ///
        /// `customers/{customer_id}/feedItemTargets/{feed_id}~{feed_item_id}~{feed_item_target_type}~{feed_item_target_id}`
        #[prost(string, tag = "2")]
        Remove(::prost::alloc::string::String),
    }
}
/// Response message for an feed item target mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateFeedItemTargetsResponse {
    /// Errors that pertain to operation failures in the partial failure mode.
    /// Returned only when partial_failure = true and all errors occur inside the
    /// operations. If any errors occur outside the operations (for example, auth
    /// errors), we return an RPC level error.
    #[prost(message, optional, tag = "3")]
    pub partial_failure_error: ::core::option::Option<
        super::super::super::super::rpc::Status,
    >,
    /// All results for the mutate.
    #[prost(message, repeated, tag = "2")]
    pub results: ::prost::alloc::vec::Vec<MutateFeedItemTargetResult>,
}
/// The result for the feed item target mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateFeedItemTargetResult {
    /// Returned for successful operations.
    #[prost(string, tag = "1")]
    pub resource_name: ::prost::alloc::string::String,
    /// The mutated feed item target with only mutable fields after mutate. The
    /// field will only be returned when response_content_type is set to
    /// "MUTABLE_RESOURCE".
    #[prost(message, optional, tag = "2")]
    pub feed_item_target: ::core::option::Option<super::resources::FeedItemTarget>,
}
/// Generated server implementations.
pub mod feed_item_target_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with FeedItemTargetServiceServer.
    #[async_trait]
    pub trait FeedItemTargetService: std::marker::Send + std::marker::Sync + 'static {
        /// Creates or removes feed item targets. Operation statuses are returned.
        ///
        /// List of thrown errors:
        ///   [AuthenticationError]()
        ///   [AuthorizationError]()
        ///   [CriterionError]()
        ///   [DatabaseError]()
        ///   [DistinctError]()
        ///   [FeedItemTargetError]()
        ///   [FieldError]()
        ///   [HeaderError]()
        ///   [IdError]()
        ///   [InternalError]()
        ///   [MutateError]()
        ///   [NotEmptyError]()
        ///   [OperatorError]()
        ///   [QuotaError]()
        ///   [RangeError]()
        ///   [RequestError]()
        ///   [SizeLimitError]()
        ///   [StringFormatError]()
        ///   [StringLengthError]()
        async fn mutate_feed_item_targets(
            &self,
            request: tonic::Request<super::MutateFeedItemTargetsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MutateFeedItemTargetsResponse>,
            tonic::Status,
        >;
    }
    /// Service to manage feed item targets.
    #[derive(Debug)]
    pub struct FeedItemTargetServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> FeedItemTargetServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>>
    for FeedItemTargetServiceServer<T>
    where
        T: FeedItemTargetService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/google.ads.googleads.v16.services.FeedItemTargetService/MutateFeedItemTargets" => {
                    #[allow(non_camel_case_types)]
                    struct MutateFeedItemTargetsSvc<T: FeedItemTargetService>(
                        pub Arc<T>,
                    );
                    impl<
                        T: FeedItemTargetService,
                    > tonic::server::UnaryService<super::MutateFeedItemTargetsRequest>
                    for MutateFeedItemTargetsSvc<T> {
                        type Response = super::MutateFeedItemTargetsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::MutateFeedItemTargetsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as FeedItemTargetService>::mutate_feed_item_targets(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = MutateFeedItemTargetsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for FeedItemTargetServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "google.ads.googleads.v16.services.FeedItemTargetService";
    impl<T> tonic::server::NamedService for FeedItemTargetServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Request message for
/// [FeedMappingService.MutateFeedMappings][google.ads.googleads.v16.services.FeedMappingService.MutateFeedMappings].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateFeedMappingsRequest {
    /// Required. The ID of the customer whose feed mappings are being modified.
    #[prost(string, tag = "1")]
    pub customer_id: ::prost::alloc::string::String,
    /// Required. The list of operations to perform on individual feed mappings.
    #[prost(message, repeated, tag = "2")]
    pub operations: ::prost::alloc::vec::Vec<FeedMappingOperation>,
    /// If true, successful operations will be carried out and invalid
    /// operations will return errors. If false, all operations will be carried
    /// out in one transaction if and only if they are all valid.
    /// Default is false.
    #[prost(bool, tag = "3")]
    pub partial_failure: bool,
    /// If true, the request is validated but not executed. Only errors are
    /// returned, not results.
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
    /// The response content type setting. Determines whether the mutable resource
    /// or just the resource name should be returned post mutation.
    #[prost(
        enumeration = "super::enums::response_content_type_enum::ResponseContentType",
        tag = "5"
    )]
    pub response_content_type: i32,
}
/// A single operation (create, remove) on a feed mapping.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FeedMappingOperation {
    /// The mutate operation.
    #[prost(oneof = "feed_mapping_operation::Operation", tags = "1, 3")]
    pub operation: ::core::option::Option<feed_mapping_operation::Operation>,
}
/// Nested message and enum types in `FeedMappingOperation`.
pub mod feed_mapping_operation {
    /// The mutate operation.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Operation {
        /// Create operation: No resource name is expected for the new feed mapping.
        #[prost(message, tag = "1")]
        Create(super::super::resources::FeedMapping),
        /// Remove operation: A resource name for the removed feed mapping is
        /// expected, in this format:
        ///
        /// `customers/{customer_id}/feedMappings/{feed_id}~{feed_mapping_id}`
        #[prost(string, tag = "3")]
        Remove(::prost::alloc::string::String),
    }
}
/// Response message for a feed mapping mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateFeedMappingsResponse {
    /// Errors that pertain to operation failures in the partial failure mode.
    /// Returned only when partial_failure = true and all errors occur inside the
    /// operations. If any errors occur outside the operations (for example, auth
    /// errors), we return an RPC level error.
    #[prost(message, optional, tag = "3")]
    pub partial_failure_error: ::core::option::Option<
        super::super::super::super::rpc::Status,
    >,
    /// All results for the mutate.
    #[prost(message, repeated, tag = "2")]
    pub results: ::prost::alloc::vec::Vec<MutateFeedMappingResult>,
}
/// The result for the feed mapping mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateFeedMappingResult {
    /// Returned for successful operations.
    #[prost(string, tag = "1")]
    pub resource_name: ::prost::alloc::string::String,
    /// The mutated feed mapping with only mutable fields after mutate. The field
    /// will only be returned when response_content_type is set to
    /// "MUTABLE_RESOURCE".
    #[prost(message, optional, tag = "2")]
    pub feed_mapping: ::core::option::Option<super::resources::FeedMapping>,
}
/// Generated server implementations.
pub mod feed_mapping_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with FeedMappingServiceServer.
    #[async_trait]
    pub trait FeedMappingService: std::marker::Send + std::marker::Sync + 'static {
        /// Creates or removes feed mappings. Operation statuses are
        /// returned.
        ///
        /// List of thrown errors:
        ///   [AuthenticationError]()
        ///   [AuthorizationError]()
        ///   [DatabaseError]()
        ///   [DistinctError]()
        ///   [FeedMappingError]()
        ///   [FieldError]()
        ///   [HeaderError]()
        ///   [IdError]()
        ///   [InternalError]()
        ///   [MutateError]()
        ///   [NotEmptyError]()
        ///   [OperationAccessDeniedError]()
        ///   [OperatorError]()
        ///   [QuotaError]()
        ///   [RangeError]()
        ///   [RequestError]()
        ///   [SizeLimitError]()
        ///   [StringFormatError]()
        ///   [StringLengthError]()
        async fn mutate_feed_mappings(
            &self,
            request: tonic::Request<super::MutateFeedMappingsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MutateFeedMappingsResponse>,
            tonic::Status,
        >;
    }
    /// Service to manage feed mappings.
    #[derive(Debug)]
    pub struct FeedMappingServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> FeedMappingServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for FeedMappingServiceServer<T>
    where
        T: FeedMappingService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/google.ads.googleads.v16.services.FeedMappingService/MutateFeedMappings" => {
                    #[allow(non_camel_case_types)]
                    struct MutateFeedMappingsSvc<T: FeedMappingService>(pub Arc<T>);
                    impl<
                        T: FeedMappingService,
                    > tonic::server::UnaryService<super::MutateFeedMappingsRequest>
                    for MutateFeedMappingsSvc<T> {
                        type Response = super::MutateFeedMappingsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::MutateFeedMappingsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as FeedMappingService>::mutate_feed_mappings(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = MutateFeedMappingsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for FeedMappingServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "google.ads.googleads.v16.services.FeedMappingService";
    impl<T> tonic::server::NamedService for FeedMappingServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Request message for
/// [FeedService.MutateFeeds][google.ads.googleads.v16.services.FeedService.MutateFeeds].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateFeedsRequest {
    /// Required. The ID of the customer whose feeds are being modified.
    #[prost(string, tag = "1")]
    pub customer_id: ::prost::alloc::string::String,
    /// Required. The list of operations to perform on individual feeds.
    #[prost(message, repeated, tag = "2")]
    pub operations: ::prost::alloc::vec::Vec<FeedOperation>,
    /// If true, successful operations will be carried out and invalid
    /// operations will return errors. If false, all operations will be carried
    /// out in one transaction if and only if they are all valid.
    /// Default is false.
    #[prost(bool, tag = "3")]
    pub partial_failure: bool,
    /// If true, the request is validated but not executed. Only errors are
    /// returned, not results.
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
    /// The response content type setting. Determines whether the mutable resource
    /// or just the resource name should be returned post mutation.
    #[prost(
        enumeration = "super::enums::response_content_type_enum::ResponseContentType",
        tag = "5"
    )]
    pub response_content_type: i32,
}
/// A single operation (create, update, remove) on an feed.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FeedOperation {
    /// FieldMask that determines which resource fields are modified in an update.
    #[prost(message, optional, tag = "4")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// The mutate operation.
    #[prost(oneof = "feed_operation::Operation", tags = "1, 2, 3")]
    pub operation: ::core::option::Option<feed_operation::Operation>,
}
/// Nested message and enum types in `FeedOperation`.
pub mod feed_operation {
    /// The mutate operation.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Operation {
        /// Create operation: No resource name is expected for the new feed.
        #[prost(message, tag = "1")]
        Create(super::super::resources::Feed),
        /// Update operation: The feed is expected to have a valid resource
        /// name.
        #[prost(message, tag = "2")]
        Update(super::super::resources::Feed),
        /// Remove operation: A resource name for the removed feed is
        /// expected, in this format:
        ///
        /// `customers/{customer_id}/feeds/{feed_id}`
        #[prost(string, tag = "3")]
        Remove(::prost::alloc::string::String),
    }
}
/// Response message for an feed mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateFeedsResponse {
    /// Errors that pertain to operation failures in the partial failure mode.
    /// Returned only when partial_failure = true and all errors occur inside the
    /// operations. If any errors occur outside the operations (for example, auth
    /// errors), we return an RPC level error.
    #[prost(message, optional, tag = "3")]
    pub partial_failure_error: ::core::option::Option<
        super::super::super::super::rpc::Status,
    >,
    /// All results for the mutate.
    #[prost(message, repeated, tag = "2")]
    pub results: ::prost::alloc::vec::Vec<MutateFeedResult>,
}
/// The result for the feed mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateFeedResult {
    /// Returned for successful operations.
    #[prost(string, tag = "1")]
    pub resource_name: ::prost::alloc::string::String,
    /// The mutated feed with only mutable fields after mutate. The field will only
    /// be returned when response_content_type is set to "MUTABLE_RESOURCE".
    #[prost(message, optional, tag = "2")]
    pub feed: ::core::option::Option<super::resources::Feed>,
}
/// Generated server implementations.
pub mod feed_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with FeedServiceServer.
    #[async_trait]
    pub trait FeedService: std::marker::Send + std::marker::Sync + 'static {
        /// Creates, updates, or removes feeds. Operation statuses are
        /// returned.
        ///
        /// List of thrown errors:
        ///   [AuthenticationError]()
        ///   [AuthorizationError]()
        ///   [CollectionSizeError]()
        ///   [DatabaseError]()
        ///   [DistinctError]()
        ///   [FeedError]()
        ///   [FieldError]()
        ///   [FieldMaskError]()
        ///   [HeaderError]()
        ///   [IdError]()
        ///   [InternalError]()
        ///   [ListOperationError]()
        ///   [MutateError]()
        ///   [NewResourceCreationError]()
        ///   [NotEmptyError]()
        ///   [NullError]()
        ///   [OperatorError]()
        ///   [QuotaError]()
        ///   [RangeError]()
        ///   [RequestError]()
        ///   [ResourceCountLimitExceededError]()
        ///   [SizeLimitError]()
        ///   [StringFormatError]()
        ///   [StringLengthError]()
        async fn mutate_feeds(
            &self,
            request: tonic::Request<super::MutateFeedsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MutateFeedsResponse>,
            tonic::Status,
        >;
    }
    /// Service to manage feeds.
    #[derive(Debug)]
    pub struct FeedServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> FeedServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for FeedServiceServer<T>
    where
        T: FeedService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/google.ads.googleads.v16.services.FeedService/MutateFeeds" => {
                    #[allow(non_camel_case_types)]
                    struct MutateFeedsSvc<T: FeedService>(pub Arc<T>);
                    impl<
                        T: FeedService,
                    > tonic::server::UnaryService<super::MutateFeedsRequest>
                    for MutateFeedsSvc<T> {
                        type Response = super::MutateFeedsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::MutateFeedsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as FeedService>::mutate_feeds(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = MutateFeedsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for FeedServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "google.ads.googleads.v16.services.FeedService";
    impl<T> tonic::server::NamedService for FeedServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Request message for
/// [KeywordPlanAdGroupKeywordService.MutateKeywordPlanAdGroupKeywords][google.ads.googleads.v16.services.KeywordPlanAdGroupKeywordService.MutateKeywordPlanAdGroupKeywords].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateKeywordPlanAdGroupKeywordsRequest {
    /// Required. The ID of the customer whose Keyword Plan ad group keywords are
    /// being modified.
    #[prost(string, tag = "1")]
    pub customer_id: ::prost::alloc::string::String,
    /// Required. The list of operations to perform on individual Keyword Plan ad
    /// group keywords.
    #[prost(message, repeated, tag = "2")]
    pub operations: ::prost::alloc::vec::Vec<KeywordPlanAdGroupKeywordOperation>,
    /// If true, successful operations will be carried out and invalid
    /// operations will return errors. If false, all operations will be carried
    /// out in one transaction if and only if they are all valid.
    /// Default is false.
    #[prost(bool, tag = "3")]
    pub partial_failure: bool,
    /// If true, the request is validated but not executed. Only errors are
    /// returned, not results.
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
}
/// A single operation (create, update, remove) on a Keyword Plan ad group
/// keyword.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KeywordPlanAdGroupKeywordOperation {
    /// The FieldMask that determines which resource fields are modified in an
    /// update.
    #[prost(message, optional, tag = "4")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// The mutate operation.
    #[prost(
        oneof = "keyword_plan_ad_group_keyword_operation::Operation",
        tags = "1, 2, 3"
    )]
    pub operation: ::core::option::Option<
        keyword_plan_ad_group_keyword_operation::Operation,
    >,
}
/// Nested message and enum types in `KeywordPlanAdGroupKeywordOperation`.
pub mod keyword_plan_ad_group_keyword_operation {
    /// The mutate operation.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Operation {
        /// Create operation: No resource name is expected for the new Keyword Plan
        /// ad group keyword.
        #[prost(message, tag = "1")]
        Create(super::super::resources::KeywordPlanAdGroupKeyword),
        /// Update operation: The Keyword Plan ad group keyword is expected to have a
        /// valid resource name.
        #[prost(message, tag = "2")]
        Update(super::super::resources::KeywordPlanAdGroupKeyword),
        /// Remove operation: A resource name for the removed Keyword Plan ad group
        /// keyword is expected, in this format:
        ///
        /// `customers/{customer_id}/keywordPlanAdGroupKeywords/{kp_ad_group_keyword_id}`
        #[prost(string, tag = "3")]
        Remove(::prost::alloc::string::String),
    }
}
/// Response message for a Keyword Plan ad group keyword mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateKeywordPlanAdGroupKeywordsResponse {
    /// Errors that pertain to operation failures in the partial failure mode.
    /// Returned only when partial_failure = true and all errors occur inside the
    /// operations. If any errors occur outside the operations (for example, auth
    /// errors), we return an RPC level error.
    #[prost(message, optional, tag = "3")]
    pub partial_failure_error: ::core::option::Option<
        super::super::super::super::rpc::Status,
    >,
    /// All results for the mutate.
    #[prost(message, repeated, tag = "2")]
    pub results: ::prost::alloc::vec::Vec<MutateKeywordPlanAdGroupKeywordResult>,
}
/// The result for the Keyword Plan ad group keyword mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateKeywordPlanAdGroupKeywordResult {
    /// Returned for successful operations.
    #[prost(string, tag = "1")]
    pub resource_name: ::prost::alloc::string::String,
}
/// Generated server implementations.
pub mod keyword_plan_ad_group_keyword_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with KeywordPlanAdGroupKeywordServiceServer.
    #[async_trait]
    pub trait KeywordPlanAdGroupKeywordService: std::marker::Send + std::marker::Sync + 'static {
        /// Creates, updates, or removes Keyword Plan ad group keywords. Operation
        /// statuses are returned.
        ///
        /// List of thrown errors:
        ///   [AuthenticationError]()
        ///   [AuthorizationError]()
        ///   [DatabaseError]()
        ///   [FieldError]()
        ///   [HeaderError]()
        ///   [InternalError]()
        ///   [KeywordPlanAdGroupKeywordError]()
        ///   [KeywordPlanError]()
        ///   [MutateError]()
        ///   [QuotaError]()
        ///   [RequestError]()
        ///   [ResourceCountLimitExceededError]()
        async fn mutate_keyword_plan_ad_group_keywords(
            &self,
            request: tonic::Request<super::MutateKeywordPlanAdGroupKeywordsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MutateKeywordPlanAdGroupKeywordsResponse>,
            tonic::Status,
        >;
    }
    /// Service to manage Keyword Plan ad group keywords. KeywordPlanAdGroup is
    /// required to add ad group keywords. Positive and negative keywords are
    /// supported. A maximum of 10,000 positive keywords are allowed per keyword
    /// plan. A maximum of 1,000 negative keywords are allower per keyword plan. This
    /// includes campaign negative keywords and ad group negative keywords.
    #[derive(Debug)]
    pub struct KeywordPlanAdGroupKeywordServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> KeywordPlanAdGroupKeywordServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>>
    for KeywordPlanAdGroupKeywordServiceServer<T>
    where
        T: KeywordPlanAdGroupKeywordService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/google.ads.googleads.v16.services.KeywordPlanAdGroupKeywordService/MutateKeywordPlanAdGroupKeywords" => {
                    #[allow(non_camel_case_types)]
                    struct MutateKeywordPlanAdGroupKeywordsSvc<
                        T: KeywordPlanAdGroupKeywordService,
                    >(
                        pub Arc<T>,
                    );
                    impl<
                        T: KeywordPlanAdGroupKeywordService,
                    > tonic::server::UnaryService<
                        super::MutateKeywordPlanAdGroupKeywordsRequest,
                    > for MutateKeywordPlanAdGroupKeywordsSvc<T> {
                        type Response = super::MutateKeywordPlanAdGroupKeywordsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::MutateKeywordPlanAdGroupKeywordsRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as KeywordPlanAdGroupKeywordService>::mutate_keyword_plan_ad_group_keywords(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = MutateKeywordPlanAdGroupKeywordsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for KeywordPlanAdGroupKeywordServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "google.ads.googleads.v16.services.KeywordPlanAdGroupKeywordService";
    impl<T> tonic::server::NamedService for KeywordPlanAdGroupKeywordServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Request message for
/// [KeywordPlanAdGroupService.MutateKeywordPlanAdGroups][google.ads.googleads.v16.services.KeywordPlanAdGroupService.MutateKeywordPlanAdGroups].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateKeywordPlanAdGroupsRequest {
    /// Required. The ID of the customer whose Keyword Plan ad groups are being
    /// modified.
    #[prost(string, tag = "1")]
    pub customer_id: ::prost::alloc::string::String,
    /// Required. The list of operations to perform on individual Keyword Plan ad
    /// groups.
    #[prost(message, repeated, tag = "2")]
    pub operations: ::prost::alloc::vec::Vec<KeywordPlanAdGroupOperation>,
    /// If true, successful operations will be carried out and invalid
    /// operations will return errors. If false, all operations will be carried
    /// out in one transaction if and only if they are all valid.
    /// Default is false.
    #[prost(bool, tag = "3")]
    pub partial_failure: bool,
    /// If true, the request is validated but not executed. Only errors are
    /// returned, not results.
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
}
/// A single operation (create, update, remove) on a Keyword Plan ad group.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KeywordPlanAdGroupOperation {
    /// The FieldMask that determines which resource fields are modified in an
    /// update.
    #[prost(message, optional, tag = "4")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// The mutate operation.
    #[prost(oneof = "keyword_plan_ad_group_operation::Operation", tags = "1, 2, 3")]
    pub operation: ::core::option::Option<keyword_plan_ad_group_operation::Operation>,
}
/// Nested message and enum types in `KeywordPlanAdGroupOperation`.
pub mod keyword_plan_ad_group_operation {
    /// The mutate operation.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Operation {
        /// Create operation: No resource name is expected for the new Keyword Plan
        /// ad group.
        #[prost(message, tag = "1")]
        Create(super::super::resources::KeywordPlanAdGroup),
        /// Update operation: The Keyword Plan ad group is expected to have a valid
        /// resource name.
        #[prost(message, tag = "2")]
        Update(super::super::resources::KeywordPlanAdGroup),
        /// Remove operation: A resource name for the removed Keyword Plan ad group
        /// is expected, in this format:
        ///
        /// `customers/{customer_id}/keywordPlanAdGroups/{kp_ad_group_id}`
        #[prost(string, tag = "3")]
        Remove(::prost::alloc::string::String),
    }
}
/// Response message for a Keyword Plan ad group mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateKeywordPlanAdGroupsResponse {
    /// Errors that pertain to operation failures in the partial failure mode.
    /// Returned only when partial_failure = true and all errors occur inside the
    /// operations. If any errors occur outside the operations (for example, auth
    /// errors), we return an RPC level error.
    #[prost(message, optional, tag = "3")]
    pub partial_failure_error: ::core::option::Option<
        super::super::super::super::rpc::Status,
    >,
    /// All results for the mutate. The order of the results is determined by the
    /// order of the keywords in the original request.
    #[prost(message, repeated, tag = "2")]
    pub results: ::prost::alloc::vec::Vec<MutateKeywordPlanAdGroupResult>,
}
/// The result for the Keyword Plan ad group mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateKeywordPlanAdGroupResult {
    /// Returned for successful operations.
    #[prost(string, tag = "1")]
    pub resource_name: ::prost::alloc::string::String,
}
/// Generated server implementations.
pub mod keyword_plan_ad_group_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with KeywordPlanAdGroupServiceServer.
    #[async_trait]
    pub trait KeywordPlanAdGroupService: std::marker::Send + std::marker::Sync + 'static {
        /// Creates, updates, or removes Keyword Plan ad groups. Operation statuses are
        /// returned.
        ///
        /// List of thrown errors:
        ///   [AuthenticationError]()
        ///   [AuthorizationError]()
        ///   [DatabaseError]()
        ///   [FieldError]()
        ///   [FieldMaskError]()
        ///   [HeaderError]()
        ///   [InternalError]()
        ///   [KeywordPlanAdGroupError]()
        ///   [KeywordPlanError]()
        ///   [MutateError]()
        ///   [NewResourceCreationError]()
        ///   [QuotaError]()
        ///   [RequestError]()
        ///   [ResourceCountLimitExceededError]()
        async fn mutate_keyword_plan_ad_groups(
            &self,
            request: tonic::Request<super::MutateKeywordPlanAdGroupsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MutateKeywordPlanAdGroupsResponse>,
            tonic::Status,
        >;
    }
    /// Service to manage Keyword Plan ad groups.
    #[derive(Debug)]
    pub struct KeywordPlanAdGroupServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> KeywordPlanAdGroupServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>>
    for KeywordPlanAdGroupServiceServer<T>
    where
        T: KeywordPlanAdGroupService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/google.ads.googleads.v16.services.KeywordPlanAdGroupService/MutateKeywordPlanAdGroups" => {
                    #[allow(non_camel_case_types)]
                    struct MutateKeywordPlanAdGroupsSvc<T: KeywordPlanAdGroupService>(
                        pub Arc<T>,
                    );
                    impl<
                        T: KeywordPlanAdGroupService,
                    > tonic::server::UnaryService<
                        super::MutateKeywordPlanAdGroupsRequest,
                    > for MutateKeywordPlanAdGroupsSvc<T> {
                        type Response = super::MutateKeywordPlanAdGroupsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::MutateKeywordPlanAdGroupsRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as KeywordPlanAdGroupService>::mutate_keyword_plan_ad_groups(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = MutateKeywordPlanAdGroupsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for KeywordPlanAdGroupServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "google.ads.googleads.v16.services.KeywordPlanAdGroupService";
    impl<T> tonic::server::NamedService for KeywordPlanAdGroupServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Request message for
/// [KeywordPlanCampaignKeywordService.MutateKeywordPlanCampaignKeywords][google.ads.googleads.v16.services.KeywordPlanCampaignKeywordService.MutateKeywordPlanCampaignKeywords].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateKeywordPlanCampaignKeywordsRequest {
    /// Required. The ID of the customer whose campaign keywords are being
    /// modified.
    #[prost(string, tag = "1")]
    pub customer_id: ::prost::alloc::string::String,
    /// Required. The list of operations to perform on individual Keyword Plan
    /// campaign keywords.
    #[prost(message, repeated, tag = "2")]
    pub operations: ::prost::alloc::vec::Vec<KeywordPlanCampaignKeywordOperation>,
    /// If true, successful operations will be carried out and invalid
    /// operations will return errors. If false, all operations will be carried
    /// out in one transaction if and only if they are all valid.
    /// Default is false.
    #[prost(bool, tag = "3")]
    pub partial_failure: bool,
    /// If true, the request is validated but not executed. Only errors are
    /// returned, not results.
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
}
/// A single operation (create, update, remove) on a Keyword Plan campaign
/// keyword.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KeywordPlanCampaignKeywordOperation {
    /// The FieldMask that determines which resource fields are modified in an
    /// update.
    #[prost(message, optional, tag = "4")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// The mutate operation.
    #[prost(
        oneof = "keyword_plan_campaign_keyword_operation::Operation",
        tags = "1, 2, 3"
    )]
    pub operation: ::core::option::Option<
        keyword_plan_campaign_keyword_operation::Operation,
    >,
}
/// Nested message and enum types in `KeywordPlanCampaignKeywordOperation`.
pub mod keyword_plan_campaign_keyword_operation {
    /// The mutate operation.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Operation {
        /// Create operation: No resource name is expected for the new Keyword Plan
        /// campaign keyword.
        #[prost(message, tag = "1")]
        Create(super::super::resources::KeywordPlanCampaignKeyword),
        /// Update operation: The Keyword Plan campaign keyword expected to have a
        /// valid resource name.
        #[prost(message, tag = "2")]
        Update(super::super::resources::KeywordPlanCampaignKeyword),
        /// Remove operation: A resource name for the removed Keyword Plan campaign
        /// keywords expected in this format:
        ///
        /// `customers/{customer_id}/keywordPlanCampaignKeywords/{kp_campaign_keyword_id}`
        #[prost(string, tag = "3")]
        Remove(::prost::alloc::string::String),
    }
}
/// Response message for a Keyword Plan campaign keyword mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateKeywordPlanCampaignKeywordsResponse {
    /// Errors that pertain to operation failures in the partial failure mode.
    /// Returned only when partial_failure = true and all errors occur inside the
    /// operations. If any errors occur outside the operations (for example, auth
    /// errors), we return an RPC level error.
    #[prost(message, optional, tag = "3")]
    pub partial_failure_error: ::core::option::Option<
        super::super::super::super::rpc::Status,
    >,
    /// All results for the mutate.
    #[prost(message, repeated, tag = "2")]
    pub results: ::prost::alloc::vec::Vec<MutateKeywordPlanCampaignKeywordResult>,
}
/// The result for the Keyword Plan campaign keyword mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateKeywordPlanCampaignKeywordResult {
    /// Returned for successful operations.
    #[prost(string, tag = "1")]
    pub resource_name: ::prost::alloc::string::String,
}
/// Generated server implementations.
pub mod keyword_plan_campaign_keyword_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with KeywordPlanCampaignKeywordServiceServer.
    #[async_trait]
    pub trait KeywordPlanCampaignKeywordService: std::marker::Send + std::marker::Sync + 'static {
        /// Creates, updates, or removes Keyword Plan campaign keywords. Operation
        /// statuses are returned.
        ///
        /// List of thrown errors:
        ///   [AuthenticationError]()
        ///   [AuthorizationError]()
        ///   [DatabaseError]()
        ///   [FieldError]()
        ///   [HeaderError]()
        ///   [InternalError]()
        ///   [KeywordPlanAdGroupKeywordError]()
        ///   [KeywordPlanCampaignKeywordError]()
        ///   [QuotaError]()
        ///   [RequestError]()
        ///   [ResourceCountLimitExceededError]()
        async fn mutate_keyword_plan_campaign_keywords(
            &self,
            request: tonic::Request<super::MutateKeywordPlanCampaignKeywordsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MutateKeywordPlanCampaignKeywordsResponse>,
            tonic::Status,
        >;
    }
    /// Service to manage Keyword Plan campaign keywords. KeywordPlanCampaign is
    /// required to add the campaign keywords. Only negative keywords are supported.
    /// A maximum of 1000 negative keywords are allowed per plan. This includes both
    /// campaign negative keywords and ad group negative keywords.
    #[derive(Debug)]
    pub struct KeywordPlanCampaignKeywordServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> KeywordPlanCampaignKeywordServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>>
    for KeywordPlanCampaignKeywordServiceServer<T>
    where
        T: KeywordPlanCampaignKeywordService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/google.ads.googleads.v16.services.KeywordPlanCampaignKeywordService/MutateKeywordPlanCampaignKeywords" => {
                    #[allow(non_camel_case_types)]
                    struct MutateKeywordPlanCampaignKeywordsSvc<
                        T: KeywordPlanCampaignKeywordService,
                    >(
                        pub Arc<T>,
                    );
                    impl<
                        T: KeywordPlanCampaignKeywordService,
                    > tonic::server::UnaryService<
                        super::MutateKeywordPlanCampaignKeywordsRequest,
                    > for MutateKeywordPlanCampaignKeywordsSvc<T> {
                        type Response = super::MutateKeywordPlanCampaignKeywordsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::MutateKeywordPlanCampaignKeywordsRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as KeywordPlanCampaignKeywordService>::mutate_keyword_plan_campaign_keywords(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = MutateKeywordPlanCampaignKeywordsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for KeywordPlanCampaignKeywordServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "google.ads.googleads.v16.services.KeywordPlanCampaignKeywordService";
    impl<T> tonic::server::NamedService for KeywordPlanCampaignKeywordServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Request message for
/// [KeywordPlanCampaignService.MutateKeywordPlanCampaigns][google.ads.googleads.v16.services.KeywordPlanCampaignService.MutateKeywordPlanCampaigns].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateKeywordPlanCampaignsRequest {
    /// Required. The ID of the customer whose Keyword Plan campaigns are being
    /// modified.
    #[prost(string, tag = "1")]
    pub customer_id: ::prost::alloc::string::String,
    /// Required. The list of operations to perform on individual Keyword Plan
    /// campaigns.
    #[prost(message, repeated, tag = "2")]
    pub operations: ::prost::alloc::vec::Vec<KeywordPlanCampaignOperation>,
    /// If true, successful operations will be carried out and invalid
    /// operations will return errors. If false, all operations will be carried
    /// out in one transaction if and only if they are all valid.
    /// Default is false.
    #[prost(bool, tag = "3")]
    pub partial_failure: bool,
    /// If true, the request is validated but not executed. Only errors are
    /// returned, not results.
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
}
/// A single operation (create, update, remove) on a Keyword Plan campaign.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KeywordPlanCampaignOperation {
    /// The FieldMask that determines which resource fields are modified in an
    /// update.
    #[prost(message, optional, tag = "4")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// The mutate operation.
    #[prost(oneof = "keyword_plan_campaign_operation::Operation", tags = "1, 2, 3")]
    pub operation: ::core::option::Option<keyword_plan_campaign_operation::Operation>,
}
/// Nested message and enum types in `KeywordPlanCampaignOperation`.
pub mod keyword_plan_campaign_operation {
    /// The mutate operation.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Operation {
        /// Create operation: No resource name is expected for the new Keyword Plan
        /// campaign.
        #[prost(message, tag = "1")]
        Create(super::super::resources::KeywordPlanCampaign),
        /// Update operation: The Keyword Plan campaign is expected to have a valid
        /// resource name.
        #[prost(message, tag = "2")]
        Update(super::super::resources::KeywordPlanCampaign),
        /// Remove operation: A resource name for the removed Keyword Plan campaign
        /// is expected, in this format:
        ///
        /// `customers/{customer_id}/keywordPlanCampaigns/{keywordPlan_campaign_id}`
        #[prost(string, tag = "3")]
        Remove(::prost::alloc::string::String),
    }
}
/// Response message for a Keyword Plan campaign mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateKeywordPlanCampaignsResponse {
    /// Errors that pertain to operation failures in the partial failure mode.
    /// Returned only when partial_failure = true and all errors occur inside the
    /// operations. If any errors occur outside the operations (for example, auth
    /// errors), we return an RPC level error.
    #[prost(message, optional, tag = "3")]
    pub partial_failure_error: ::core::option::Option<
        super::super::super::super::rpc::Status,
    >,
    /// All results for the mutate.
    #[prost(message, repeated, tag = "2")]
    pub results: ::prost::alloc::vec::Vec<MutateKeywordPlanCampaignResult>,
}
/// The result for the Keyword Plan campaign mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateKeywordPlanCampaignResult {
    /// Returned for successful operations.
    #[prost(string, tag = "1")]
    pub resource_name: ::prost::alloc::string::String,
}
/// Generated server implementations.
pub mod keyword_plan_campaign_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with KeywordPlanCampaignServiceServer.
    #[async_trait]
    pub trait KeywordPlanCampaignService: std::marker::Send + std::marker::Sync + 'static {
        /// Creates, updates, or removes Keyword Plan campaigns. Operation statuses are
        /// returned.
        ///
        /// List of thrown errors:
        ///   [AuthenticationError]()
        ///   [AuthorizationError]()
        ///   [DatabaseError]()
        ///   [FieldError]()
        ///   [FieldMaskError]()
        ///   [HeaderError]()
        ///   [InternalError]()
        ///   [KeywordPlanCampaignError]()
        ///   [KeywordPlanError]()
        ///   [ListOperationError]()
        ///   [MutateError]()
        ///   [QuotaError]()
        ///   [RangeError]()
        ///   [RequestError]()
        ///   [ResourceCountLimitExceededError]()
        async fn mutate_keyword_plan_campaigns(
            &self,
            request: tonic::Request<super::MutateKeywordPlanCampaignsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MutateKeywordPlanCampaignsResponse>,
            tonic::Status,
        >;
    }
    /// Service to manage Keyword Plan campaigns.
    #[derive(Debug)]
    pub struct KeywordPlanCampaignServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> KeywordPlanCampaignServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>>
    for KeywordPlanCampaignServiceServer<T>
    where
        T: KeywordPlanCampaignService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/google.ads.googleads.v16.services.KeywordPlanCampaignService/MutateKeywordPlanCampaigns" => {
                    #[allow(non_camel_case_types)]
                    struct MutateKeywordPlanCampaignsSvc<T: KeywordPlanCampaignService>(
                        pub Arc<T>,
                    );
                    impl<
                        T: KeywordPlanCampaignService,
                    > tonic::server::UnaryService<
                        super::MutateKeywordPlanCampaignsRequest,
                    > for MutateKeywordPlanCampaignsSvc<T> {
                        type Response = super::MutateKeywordPlanCampaignsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::MutateKeywordPlanCampaignsRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as KeywordPlanCampaignService>::mutate_keyword_plan_campaigns(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = MutateKeywordPlanCampaignsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for KeywordPlanCampaignServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "google.ads.googleads.v16.services.KeywordPlanCampaignService";
    impl<T> tonic::server::NamedService for KeywordPlanCampaignServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Request message for
/// [KeywordPlanService.MutateKeywordPlans][google.ads.googleads.v16.services.KeywordPlanService.MutateKeywordPlans].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateKeywordPlansRequest {
    /// Required. The ID of the customer whose keyword plans are being modified.
    #[prost(string, tag = "1")]
    pub customer_id: ::prost::alloc::string::String,
    /// Required. The list of operations to perform on individual keyword plans.
    #[prost(message, repeated, tag = "2")]
    pub operations: ::prost::alloc::vec::Vec<KeywordPlanOperation>,
    /// If true, successful operations will be carried out and invalid
    /// operations will return errors. If false, all operations will be carried
    /// out in one transaction if and only if they are all valid.
    /// Default is false.
    #[prost(bool, tag = "3")]
    pub partial_failure: bool,
    /// If true, the request is validated but not executed. Only errors are
    /// returned, not results.
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
}
/// A single operation (create, update, remove) on a keyword plan.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KeywordPlanOperation {
    /// The FieldMask that determines which resource fields are modified in an
    /// update.
    #[prost(message, optional, tag = "4")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// The mutate operation.
    #[prost(oneof = "keyword_plan_operation::Operation", tags = "1, 2, 3")]
    pub operation: ::core::option::Option<keyword_plan_operation::Operation>,
}
/// Nested message and enum types in `KeywordPlanOperation`.
pub mod keyword_plan_operation {
    /// The mutate operation.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Operation {
        /// Create operation: No resource name is expected for the new keyword plan.
        #[prost(message, tag = "1")]
        Create(super::super::resources::KeywordPlan),
        /// Update operation: The keyword plan is expected to have a valid resource
        /// name.
        #[prost(message, tag = "2")]
        Update(super::super::resources::KeywordPlan),
        /// Remove operation: A resource name for the removed keyword plan is
        /// expected in this format:
        ///
        /// `customers/{customer_id}/keywordPlans/{keyword_plan_id}`
        #[prost(string, tag = "3")]
        Remove(::prost::alloc::string::String),
    }
}
/// Response message for a keyword plan mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateKeywordPlansResponse {
    /// Errors that pertain to operation failures in the partial failure mode.
    /// Returned only when partial_failure = true and all errors occur inside the
    /// operations. If any errors occur outside the operations (for example, auth
    /// errors), we return an RPC level error.
    #[prost(message, optional, tag = "3")]
    pub partial_failure_error: ::core::option::Option<
        super::super::super::super::rpc::Status,
    >,
    /// All results for the mutate.
    #[prost(message, repeated, tag = "2")]
    pub results: ::prost::alloc::vec::Vec<MutateKeywordPlansResult>,
}
/// The result for the keyword plan mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateKeywordPlansResult {
    /// Returned for successful operations.
    #[prost(string, tag = "1")]
    pub resource_name: ::prost::alloc::string::String,
}
/// Generated server implementations.
pub mod keyword_plan_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with KeywordPlanServiceServer.
    #[async_trait]
    pub trait KeywordPlanService: std::marker::Send + std::marker::Sync + 'static {
        /// Creates, updates, or removes keyword plans. Operation statuses are
        /// returned.
        ///
        /// List of thrown errors:
        ///   [AuthenticationError]()
        ///   [AuthorizationError]()
        ///   [DatabaseError]()
        ///   [FieldError]()
        ///   [HeaderError]()
        ///   [InternalError]()
        ///   [KeywordPlanError]()
        ///   [MutateError]()
        ///   [NewResourceCreationError]()
        ///   [QuotaError]()
        ///   [RequestError]()
        ///   [ResourceCountLimitExceededError]()
        ///   [StringLengthError]()
        async fn mutate_keyword_plans(
            &self,
            request: tonic::Request<super::MutateKeywordPlansRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MutateKeywordPlansResponse>,
            tonic::Status,
        >;
    }
    /// Service to manage keyword plans.
    #[derive(Debug)]
    pub struct KeywordPlanServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> KeywordPlanServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for KeywordPlanServiceServer<T>
    where
        T: KeywordPlanService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/google.ads.googleads.v16.services.KeywordPlanService/MutateKeywordPlans" => {
                    #[allow(non_camel_case_types)]
                    struct MutateKeywordPlansSvc<T: KeywordPlanService>(pub Arc<T>);
                    impl<
                        T: KeywordPlanService,
                    > tonic::server::UnaryService<super::MutateKeywordPlansRequest>
                    for MutateKeywordPlansSvc<T> {
                        type Response = super::MutateKeywordPlansResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::MutateKeywordPlansRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as KeywordPlanService>::mutate_keyword_plans(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = MutateKeywordPlansSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for KeywordPlanServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "google.ads.googleads.v16.services.KeywordPlanService";
    impl<T> tonic::server::NamedService for KeywordPlanServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Request message for
/// [LabelService.MutateLabels][google.ads.googleads.v16.services.LabelService.MutateLabels].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateLabelsRequest {
    /// Required. ID of the customer whose labels are being modified.
    #[prost(string, tag = "1")]
    pub customer_id: ::prost::alloc::string::String,
    /// Required. The list of operations to perform on labels.
    #[prost(message, repeated, tag = "2")]
    pub operations: ::prost::alloc::vec::Vec<LabelOperation>,
    /// If true, successful operations will be carried out and invalid
    /// operations will return errors. If false, all operations will be carried
    /// out in one transaction if and only if they are all valid.
    /// Default is false.
    #[prost(bool, tag = "3")]
    pub partial_failure: bool,
    /// If true, the request is validated but not executed. Only errors are
    /// returned, not results.
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
    /// The response content type setting. Determines whether the mutable resource
    /// or just the resource name should be returned post mutation.
    #[prost(
        enumeration = "super::enums::response_content_type_enum::ResponseContentType",
        tag = "5"
    )]
    pub response_content_type: i32,
}
/// A single operation (create, remove, update) on a label.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LabelOperation {
    /// FieldMask that determines which resource fields are modified in an update.
    #[prost(message, optional, tag = "4")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// The mutate operation.
    #[prost(oneof = "label_operation::Operation", tags = "1, 2, 3")]
    pub operation: ::core::option::Option<label_operation::Operation>,
}
/// Nested message and enum types in `LabelOperation`.
pub mod label_operation {
    /// The mutate operation.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Operation {
        /// Create operation: No resource name is expected for the new label.
        #[prost(message, tag = "1")]
        Create(super::super::resources::Label),
        /// Update operation: The label is expected to have a valid resource name.
        #[prost(message, tag = "2")]
        Update(super::super::resources::Label),
        /// Remove operation: A resource name for the label being removed, in
        /// this format:
        ///
        /// `customers/{customer_id}/labels/{label_id}`
        #[prost(string, tag = "3")]
        Remove(::prost::alloc::string::String),
    }
}
/// Response message for a labels mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateLabelsResponse {
    /// Errors that pertain to operation failures in the partial failure mode.
    /// Returned only when partial_failure = true and all errors occur inside the
    /// operations. If any errors occur outside the operations (for example, auth
    /// errors), we return an RPC level error.
    #[prost(message, optional, tag = "3")]
    pub partial_failure_error: ::core::option::Option<
        super::super::super::super::rpc::Status,
    >,
    /// All results for the mutate.
    #[prost(message, repeated, tag = "2")]
    pub results: ::prost::alloc::vec::Vec<MutateLabelResult>,
}
/// The result for a label mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateLabelResult {
    /// Returned for successful operations.
    #[prost(string, tag = "1")]
    pub resource_name: ::prost::alloc::string::String,
    /// The mutated label with only mutable fields after mutate. The field will
    /// only be returned when response_content_type is set to "MUTABLE_RESOURCE".
    #[prost(message, optional, tag = "2")]
    pub label: ::core::option::Option<super::resources::Label>,
}
/// Generated server implementations.
pub mod label_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with LabelServiceServer.
    #[async_trait]
    pub trait LabelService: std::marker::Send + std::marker::Sync + 'static {
        /// Creates, updates, or removes labels. Operation statuses are returned.
        ///
        /// List of thrown errors:
        ///   [AuthenticationError]()
        ///   [AuthorizationError]()
        ///   [DatabaseError]()
        ///   [DateError]()
        ///   [DistinctError]()
        ///   [FieldError]()
        ///   [FieldMaskError]()
        ///   [HeaderError]()
        ///   [IdError]()
        ///   [InternalError]()
        ///   [LabelError]()
        ///   [MutateError]()
        ///   [NewResourceCreationError]()
        ///   [NotEmptyError]()
        ///   [NullError]()
        ///   [OperatorError]()
        ///   [QuotaError]()
        ///   [RangeError]()
        ///   [RequestError]()
        ///   [ResourceCountLimitExceededError]()
        ///   [SizeLimitError]()
        ///   [StringFormatError]()
        ///   [StringLengthError]()
        async fn mutate_labels(
            &self,
            request: tonic::Request<super::MutateLabelsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MutateLabelsResponse>,
            tonic::Status,
        >;
    }
    /// Service to manage labels.
    #[derive(Debug)]
    pub struct LabelServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> LabelServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for LabelServiceServer<T>
    where
        T: LabelService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/google.ads.googleads.v16.services.LabelService/MutateLabels" => {
                    #[allow(non_camel_case_types)]
                    struct MutateLabelsSvc<T: LabelService>(pub Arc<T>);
                    impl<
                        T: LabelService,
                    > tonic::server::UnaryService<super::MutateLabelsRequest>
                    for MutateLabelsSvc<T> {
                        type Response = super::MutateLabelsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::MutateLabelsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as LabelService>::mutate_labels(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = MutateLabelsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for LabelServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "google.ads.googleads.v16.services.LabelService";
    impl<T> tonic::server::NamedService for LabelServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Request message for
/// \[RecommendationSubscriptionService.MutateRecommendationSubscription\]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateRecommendationSubscriptionRequest {
    /// Required. The ID of the subscribing customer.
    #[prost(string, tag = "1")]
    pub customer_id: ::prost::alloc::string::String,
    /// Required. The list of create or update operations.
    #[prost(message, repeated, tag = "2")]
    pub operations: ::prost::alloc::vec::Vec<RecommendationSubscriptionOperation>,
    /// If true, successful operations will be carried out and invalid
    /// operations will return errors. If false, all operations will be carried
    /// out in one transaction if and only if they are all valid.
    /// Default is false.
    #[prost(bool, tag = "3")]
    pub partial_failure: bool,
    /// If true, the request is validated but not executed. Only errors are
    /// returned, not results.
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
    /// The response content type setting. Determines whether the mutable resource
    /// or just the resource name should be returned post mutation. The mutable
    /// resource will only be returned if the resource has the appropriate response
    /// field. For example, MutateCampaignResult.campaign.
    #[prost(
        enumeration = "super::enums::response_content_type_enum::ResponseContentType",
        tag = "5"
    )]
    pub response_content_type: i32,
}
/// A single operation (create, update) on a recommendation subscription.
/// \[RecommendationSubscriptionService.MutateRecommendationSubscription\]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RecommendationSubscriptionOperation {
    /// Optional. FieldMask that determines which resource fields are modified in
    /// an update.
    #[prost(message, optional, tag = "3")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// Required. Create or update operation.
    #[prost(oneof = "recommendation_subscription_operation::Operation", tags = "1, 2")]
    pub operation: ::core::option::Option<
        recommendation_subscription_operation::Operation,
    >,
}
/// Nested message and enum types in `RecommendationSubscriptionOperation`.
pub mod recommendation_subscription_operation {
    /// Required. Create or update operation.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Operation {
        /// Create operation: No resource name is expected for the new subscription.
        #[prost(message, tag = "1")]
        Create(super::super::resources::RecommendationSubscription),
        /// Update operation: The subscription is expected to have a valid
        /// resource name.
        #[prost(message, tag = "2")]
        Update(super::super::resources::RecommendationSubscription),
    }
}
/// Response message for
/// \[RecommendationSubscriptionService.MutateRecommendationSubscription\]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateRecommendationSubscriptionResponse {
    /// Results, one per operation.
    #[prost(message, repeated, tag = "1")]
    pub results: ::prost::alloc::vec::Vec<MutateRecommendationSubscriptionResult>,
    /// Errors that pertain to operation failures in the partial failure mode.
    /// Returned only when partial_failure = true and all errors occur inside the
    /// operations. If any errors occur outside the operations (for example, auth
    /// errors) we return the RPC level error.
    #[prost(message, optional, tag = "2")]
    pub partial_failure_error: ::core::option::Option<
        super::super::super::super::rpc::Status,
    >,
}
/// Result message for
/// \[RecommendationSubscriptionService.MutateRecommendationSubscription\]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateRecommendationSubscriptionResult {
    /// Resource name of the subscription that was modified.
    #[prost(string, tag = "1")]
    pub resource_name: ::prost::alloc::string::String,
    /// The mutated recommendation subscription with only mutable fields after
    /// mutate. The field will only be returned when response_content_type is set
    /// to "MUTABLE_RESOURCE".
    #[prost(message, optional, tag = "2")]
    pub recommendation_subscription: ::core::option::Option<
        super::resources::RecommendationSubscription,
    >,
}
/// Generated server implementations.
pub mod recommendation_subscription_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with RecommendationSubscriptionServiceServer.
    #[async_trait]
    pub trait RecommendationSubscriptionService: std::marker::Send + std::marker::Sync + 'static {
        /// Mutates given subscription with corresponding apply parameters.
        ///
        /// List of thrown errors:
        ///   [AuthenticationError]()
        ///   [AuthorizationError]()
        ///   [DatabaseError]()
        ///   [FieldError]()
        ///   [HeaderError]()
        ///   [InternalError]()
        ///   [MutateError]()
        ///   [QuotaError]()
        ///   [RecommendationError]()
        ///   [RequestError]()
        ///   [UrlFieldError]()
        async fn mutate_recommendation_subscription(
            &self,
            request: tonic::Request<super::MutateRecommendationSubscriptionRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MutateRecommendationSubscriptionResponse>,
            tonic::Status,
        >;
    }
    /// Service to manage recommendation subscriptions.
    #[derive(Debug)]
    pub struct RecommendationSubscriptionServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> RecommendationSubscriptionServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>>
    for RecommendationSubscriptionServiceServer<T>
    where
        T: RecommendationSubscriptionService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/google.ads.googleads.v16.services.RecommendationSubscriptionService/MutateRecommendationSubscription" => {
                    #[allow(non_camel_case_types)]
                    struct MutateRecommendationSubscriptionSvc<
                        T: RecommendationSubscriptionService,
                    >(
                        pub Arc<T>,
                    );
                    impl<
                        T: RecommendationSubscriptionService,
                    > tonic::server::UnaryService<
                        super::MutateRecommendationSubscriptionRequest,
                    > for MutateRecommendationSubscriptionSvc<T> {
                        type Response = super::MutateRecommendationSubscriptionResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::MutateRecommendationSubscriptionRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RecommendationSubscriptionService>::mutate_recommendation_subscription(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = MutateRecommendationSubscriptionSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for RecommendationSubscriptionServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "google.ads.googleads.v16.services.RecommendationSubscriptionService";
    impl<T> tonic::server::NamedService for RecommendationSubscriptionServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Request message for
/// [RemarketingActionService.MutateRemarketingActions][google.ads.googleads.v16.services.RemarketingActionService.MutateRemarketingActions].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateRemarketingActionsRequest {
    /// Required. The ID of the customer whose remarketing actions are being
    /// modified.
    #[prost(string, tag = "1")]
    pub customer_id: ::prost::alloc::string::String,
    /// Required. The list of operations to perform on individual remarketing
    /// actions.
    #[prost(message, repeated, tag = "2")]
    pub operations: ::prost::alloc::vec::Vec<RemarketingActionOperation>,
    /// If true, successful operations will be carried out and invalid
    /// operations will return errors. If false, all operations will be carried
    /// out in one transaction if and only if they are all valid.
    /// Default is false.
    #[prost(bool, tag = "3")]
    pub partial_failure: bool,
    /// If true, the request is validated but not executed. Only errors are
    /// returned, not results.
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
}
/// A single operation (create, update) on a remarketing action.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RemarketingActionOperation {
    /// FieldMask that determines which resource fields are modified in an update.
    #[prost(message, optional, tag = "4")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// The mutate operation.
    #[prost(oneof = "remarketing_action_operation::Operation", tags = "1, 2")]
    pub operation: ::core::option::Option<remarketing_action_operation::Operation>,
}
/// Nested message and enum types in `RemarketingActionOperation`.
pub mod remarketing_action_operation {
    /// The mutate operation.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Operation {
        /// Create operation: No resource name is expected for the new remarketing
        /// action.
        #[prost(message, tag = "1")]
        Create(super::super::resources::RemarketingAction),
        /// Update operation: The remarketing action is expected to have a valid
        /// resource name.
        #[prost(message, tag = "2")]
        Update(super::super::resources::RemarketingAction),
    }
}
/// Response message for remarketing action mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateRemarketingActionsResponse {
    /// Errors that pertain to operation failures in the partial failure mode.
    /// Returned only when partial_failure = true and all errors occur inside the
    /// operations. If any errors occur outside the operations (for example, auth
    /// errors), we return an RPC level error.
    #[prost(message, optional, tag = "3")]
    pub partial_failure_error: ::core::option::Option<
        super::super::super::super::rpc::Status,
    >,
    /// All results for the mutate.
    #[prost(message, repeated, tag = "2")]
    pub results: ::prost::alloc::vec::Vec<MutateRemarketingActionResult>,
}
/// The result for the remarketing action mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateRemarketingActionResult {
    /// Returned for successful operations.
    #[prost(string, tag = "1")]
    pub resource_name: ::prost::alloc::string::String,
}
/// Generated server implementations.
pub mod remarketing_action_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with RemarketingActionServiceServer.
    #[async_trait]
    pub trait RemarketingActionService: std::marker::Send + std::marker::Sync + 'static {
        /// Creates or updates remarketing actions. Operation statuses are returned.
        ///
        /// List of thrown errors:
        ///   [AuthenticationError]()
        ///   [AuthorizationError]()
        ///   [ConversionActionError]()
        ///   [HeaderError]()
        ///   [InternalError]()
        ///   [QuotaError]()
        ///   [RequestError]()
        async fn mutate_remarketing_actions(
            &self,
            request: tonic::Request<super::MutateRemarketingActionsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MutateRemarketingActionsResponse>,
            tonic::Status,
        >;
    }
    /// Service to manage remarketing actions.
    #[derive(Debug)]
    pub struct RemarketingActionServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> RemarketingActionServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>>
    for RemarketingActionServiceServer<T>
    where
        T: RemarketingActionService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/google.ads.googleads.v16.services.RemarketingActionService/MutateRemarketingActions" => {
                    #[allow(non_camel_case_types)]
                    struct MutateRemarketingActionsSvc<T: RemarketingActionService>(
                        pub Arc<T>,
                    );
                    impl<
                        T: RemarketingActionService,
                    > tonic::server::UnaryService<super::MutateRemarketingActionsRequest>
                    for MutateRemarketingActionsSvc<T> {
                        type Response = super::MutateRemarketingActionsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::MutateRemarketingActionsRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RemarketingActionService>::mutate_remarketing_actions(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = MutateRemarketingActionsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for RemarketingActionServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "google.ads.googleads.v16.services.RemarketingActionService";
    impl<T> tonic::server::NamedService for RemarketingActionServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Request message for
/// [SharedCriterionService.MutateSharedCriteria][google.ads.googleads.v16.services.SharedCriterionService.MutateSharedCriteria].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateSharedCriteriaRequest {
    /// Required. The ID of the customer whose shared criteria are being modified.
    #[prost(string, tag = "1")]
    pub customer_id: ::prost::alloc::string::String,
    /// Required. The list of operations to perform on individual shared criteria.
    #[prost(message, repeated, tag = "2")]
    pub operations: ::prost::alloc::vec::Vec<SharedCriterionOperation>,
    /// If true, successful operations will be carried out and invalid
    /// operations will return errors. If false, all operations will be carried
    /// out in one transaction if and only if they are all valid.
    /// Default is false.
    #[prost(bool, tag = "3")]
    pub partial_failure: bool,
    /// If true, the request is validated but not executed. Only errors are
    /// returned, not results.
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
    /// The response content type setting. Determines whether the mutable resource
    /// or just the resource name should be returned post mutation.
    #[prost(
        enumeration = "super::enums::response_content_type_enum::ResponseContentType",
        tag = "5"
    )]
    pub response_content_type: i32,
}
/// A single operation (create, remove) on an shared criterion.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SharedCriterionOperation {
    /// The mutate operation.
    #[prost(oneof = "shared_criterion_operation::Operation", tags = "1, 3")]
    pub operation: ::core::option::Option<shared_criterion_operation::Operation>,
}
/// Nested message and enum types in `SharedCriterionOperation`.
pub mod shared_criterion_operation {
    /// The mutate operation.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Operation {
        /// Create operation: No resource name is expected for the new shared
        /// criterion.
        #[prost(message, tag = "1")]
        Create(super::super::resources::SharedCriterion),
        /// Remove operation: A resource name for the removed shared criterion is
        /// expected, in this format:
        ///
        /// `customers/{customer_id}/sharedCriteria/{shared_set_id}~{criterion_id}`
        #[prost(string, tag = "3")]
        Remove(::prost::alloc::string::String),
    }
}
/// Response message for a shared criterion mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateSharedCriteriaResponse {
    /// Errors that pertain to operation failures in the partial failure mode.
    /// Returned only when partial_failure = true and all errors occur inside the
    /// operations. If any errors occur outside the operations (for example, auth
    /// errors), we return an RPC level error.
    #[prost(message, optional, tag = "3")]
    pub partial_failure_error: ::core::option::Option<
        super::super::super::super::rpc::Status,
    >,
    /// All results for the mutate.
    #[prost(message, repeated, tag = "2")]
    pub results: ::prost::alloc::vec::Vec<MutateSharedCriterionResult>,
}
/// The result for the shared criterion mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateSharedCriterionResult {
    /// Returned for successful operations.
    #[prost(string, tag = "1")]
    pub resource_name: ::prost::alloc::string::String,
    /// The mutated shared criterion with only mutable fields after mutate. The
    /// field will only be returned when response_content_type is set to
    /// "MUTABLE_RESOURCE".
    #[prost(message, optional, tag = "2")]
    pub shared_criterion: ::core::option::Option<super::resources::SharedCriterion>,
}
/// Generated server implementations.
pub mod shared_criterion_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with SharedCriterionServiceServer.
    #[async_trait]
    pub trait SharedCriterionService: std::marker::Send + std::marker::Sync + 'static {
        /// Creates or removes shared criteria. Operation statuses are returned.
        ///
        /// List of thrown errors:
        ///   [AuthenticationError]()
        ///   [AuthorizationError]()
        ///   [CriterionError]()
        ///   [DatabaseError]()
        ///   [DistinctError]()
        ///   [FieldError]()
        ///   [HeaderError]()
        ///   [IdError]()
        ///   [InternalError]()
        ///   [MutateError]()
        ///   [NotEmptyError]()
        ///   [NullError]()
        ///   [OperatorError]()
        ///   [QuotaError]()
        ///   [RangeError]()
        ///   [RequestError]()
        ///   [ResourceCountLimitExceededError]()
        ///   [SizeLimitError]()
        ///   [StringFormatError]()
        ///   [StringLengthError]()
        async fn mutate_shared_criteria(
            &self,
            request: tonic::Request<super::MutateSharedCriteriaRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MutateSharedCriteriaResponse>,
            tonic::Status,
        >;
    }
    /// Service to manage shared criteria.
    #[derive(Debug)]
    pub struct SharedCriterionServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> SharedCriterionServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>>
    for SharedCriterionServiceServer<T>
    where
        T: SharedCriterionService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/google.ads.googleads.v16.services.SharedCriterionService/MutateSharedCriteria" => {
                    #[allow(non_camel_case_types)]
                    struct MutateSharedCriteriaSvc<T: SharedCriterionService>(
                        pub Arc<T>,
                    );
                    impl<
                        T: SharedCriterionService,
                    > tonic::server::UnaryService<super::MutateSharedCriteriaRequest>
                    for MutateSharedCriteriaSvc<T> {
                        type Response = super::MutateSharedCriteriaResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::MutateSharedCriteriaRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as SharedCriterionService>::mutate_shared_criteria(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = MutateSharedCriteriaSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for SharedCriterionServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "google.ads.googleads.v16.services.SharedCriterionService";
    impl<T> tonic::server::NamedService for SharedCriterionServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Request message for
/// [SharedSetService.MutateSharedSets][google.ads.googleads.v16.services.SharedSetService.MutateSharedSets].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateSharedSetsRequest {
    /// Required. The ID of the customer whose shared sets are being modified.
    #[prost(string, tag = "1")]
    pub customer_id: ::prost::alloc::string::String,
    /// Required. The list of operations to perform on individual shared sets.
    #[prost(message, repeated, tag = "2")]
    pub operations: ::prost::alloc::vec::Vec<SharedSetOperation>,
    /// If true, successful operations will be carried out and invalid
    /// operations will return errors. If false, all operations will be carried
    /// out in one transaction if and only if they are all valid.
    /// Default is false.
    #[prost(bool, tag = "3")]
    pub partial_failure: bool,
    /// If true, the request is validated but not executed. Only errors are
    /// returned, not results.
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
    /// The response content type setting. Determines whether the mutable resource
    /// or just the resource name should be returned post mutation.
    #[prost(
        enumeration = "super::enums::response_content_type_enum::ResponseContentType",
        tag = "5"
    )]
    pub response_content_type: i32,
}
/// A single operation (create, update, remove) on an shared set.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SharedSetOperation {
    /// FieldMask that determines which resource fields are modified in an update.
    #[prost(message, optional, tag = "4")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// The mutate operation.
    #[prost(oneof = "shared_set_operation::Operation", tags = "1, 2, 3")]
    pub operation: ::core::option::Option<shared_set_operation::Operation>,
}
/// Nested message and enum types in `SharedSetOperation`.
pub mod shared_set_operation {
    /// The mutate operation.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Operation {
        /// Create operation: No resource name is expected for the new shared set.
        #[prost(message, tag = "1")]
        Create(super::super::resources::SharedSet),
        /// Update operation: The shared set is expected to have a valid resource
        /// name.
        #[prost(message, tag = "2")]
        Update(super::super::resources::SharedSet),
        /// Remove operation: A resource name for the removed shared set is expected,
        /// in this format:
        ///
        /// `customers/{customer_id}/sharedSets/{shared_set_id}`
        #[prost(string, tag = "3")]
        Remove(::prost::alloc::string::String),
    }
}
/// Response message for a shared set mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateSharedSetsResponse {
    /// Errors that pertain to operation failures in the partial failure mode.
    /// Returned only when partial_failure = true and all errors occur inside the
    /// operations. If any errors occur outside the operations (for example, auth
    /// errors), we return an RPC level error.
    #[prost(message, optional, tag = "3")]
    pub partial_failure_error: ::core::option::Option<
        super::super::super::super::rpc::Status,
    >,
    /// All results for the mutate.
    #[prost(message, repeated, tag = "2")]
    pub results: ::prost::alloc::vec::Vec<MutateSharedSetResult>,
}
/// The result for the shared set mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateSharedSetResult {
    /// Returned for successful operations.
    #[prost(string, tag = "1")]
    pub resource_name: ::prost::alloc::string::String,
    /// The mutated shared set with only mutable fields after mutate. The field
    /// will only be returned when response_content_type is set to
    /// "MUTABLE_RESOURCE".
    #[prost(message, optional, tag = "2")]
    pub shared_set: ::core::option::Option<super::resources::SharedSet>,
}
/// Generated server implementations.
pub mod shared_set_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with SharedSetServiceServer.
    #[async_trait]
    pub trait SharedSetService: std::marker::Send + std::marker::Sync + 'static {
        /// Creates, updates, or removes shared sets. Operation statuses are returned.
        ///
        /// List of thrown errors:
        ///   [AuthenticationError]()
        ///   [AuthorizationError]()
        ///   [DatabaseError]()
        ///   [DateError]()
        ///   [DistinctError]()
        ///   [FieldError]()
        ///   [FieldMaskError]()
        ///   [HeaderError]()
        ///   [IdError]()
        ///   [InternalError]()
        ///   [MutateError]()
        ///   [NewResourceCreationError]()
        ///   [NotEmptyError]()
        ///   [NullError]()
        ///   [OperatorError]()
        ///   [QuotaError]()
        ///   [RangeError]()
        ///   [RequestError]()
        ///   [ResourceCountLimitExceededError]()
        ///   [SharedSetError]()
        ///   [SizeLimitError]()
        ///   [StringFormatError]()
        ///   [StringLengthError]()
        async fn mutate_shared_sets(
            &self,
            request: tonic::Request<super::MutateSharedSetsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MutateSharedSetsResponse>,
            tonic::Status,
        >;
    }
    /// Service to manage shared sets.
    #[derive(Debug)]
    pub struct SharedSetServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> SharedSetServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for SharedSetServiceServer<T>
    where
        T: SharedSetService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/google.ads.googleads.v16.services.SharedSetService/MutateSharedSets" => {
                    #[allow(non_camel_case_types)]
                    struct MutateSharedSetsSvc<T: SharedSetService>(pub Arc<T>);
                    impl<
                        T: SharedSetService,
                    > tonic::server::UnaryService<super::MutateSharedSetsRequest>
                    for MutateSharedSetsSvc<T> {
                        type Response = super::MutateSharedSetsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::MutateSharedSetsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as SharedSetService>::mutate_shared_sets(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = MutateSharedSetsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for SharedSetServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "google.ads.googleads.v16.services.SharedSetService";
    impl<T> tonic::server::NamedService for SharedSetServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Request message for
/// [SmartCampaignSettingService.GetSmartCampaignStatus][google.ads.googleads.v16.services.SmartCampaignSettingService.GetSmartCampaignStatus].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSmartCampaignStatusRequest {
    /// Required. The resource name of the Smart campaign setting belonging to the
    /// Smart campaign to fetch the status of.
    #[prost(string, tag = "1")]
    pub resource_name: ::prost::alloc::string::String,
}
/// Details related to Smart campaigns that are not eligible to serve.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SmartCampaignNotEligibleDetails {
    /// The reason why the Smart campaign is not eligible to serve.
    #[prost(
        enumeration = "super::enums::smart_campaign_not_eligible_reason_enum::SmartCampaignNotEligibleReason",
        optional,
        tag = "1"
    )]
    pub not_eligible_reason: ::core::option::Option<i32>,
}
/// Details related to Smart campaigns that are eligible to serve.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SmartCampaignEligibleDetails {
    /// The timestamp of the last impression observed in the last 48 hours for this
    /// campaign.
    /// The timestamp is in the customer’s timezone and in
    /// “yyyy-MM-dd HH:mm:ss” format.
    #[prost(string, optional, tag = "1")]
    pub last_impression_date_time: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
    /// The timestamp of when the campaign will end, if applicable.
    /// The timestamp is in the customer’s timezone and in
    /// “yyyy-MM-dd HH:mm:ss” format.
    #[prost(string, optional, tag = "2")]
    pub end_date_time: ::core::option::Option<::prost::alloc::string::String>,
}
/// Details related to paused Smart campaigns.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SmartCampaignPausedDetails {
    /// The timestamp of when the campaign was last paused.
    /// The timestamp is in the customer’s timezone and in
    /// “yyyy-MM-dd HH:mm:ss” format.
    #[prost(string, optional, tag = "1")]
    pub paused_date_time: ::core::option::Option<::prost::alloc::string::String>,
}
/// Details related to removed Smart campaigns.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SmartCampaignRemovedDetails {
    /// The timestamp of when the campaign was removed.
    /// The timestamp is in the customer’s timezone and in
    /// “yyyy-MM-dd HH:mm:ss” format.
    #[prost(string, optional, tag = "1")]
    pub removed_date_time: ::core::option::Option<::prost::alloc::string::String>,
}
/// Details related to Smart campaigns that have ended.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SmartCampaignEndedDetails {
    /// The timestamp of when the campaign ended.
    /// The timestamp is in the customer’s timezone and in
    /// “yyyy-MM-dd HH:mm:ss” format.
    #[prost(string, optional, tag = "1")]
    pub end_date_time: ::core::option::Option<::prost::alloc::string::String>,
}
/// Response message for
/// [SmartCampaignSettingService.GetSmartCampaignStatus][google.ads.googleads.v16.services.SmartCampaignSettingService.GetSmartCampaignStatus].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSmartCampaignStatusResponse {
    /// The status of this Smart campaign.
    #[prost(
        enumeration = "super::enums::smart_campaign_status_enum::SmartCampaignStatus",
        tag = "1"
    )]
    pub smart_campaign_status: i32,
    /// Additional details accompanying the status of a Smart campaign.
    #[prost(
        oneof = "get_smart_campaign_status_response::SmartCampaignStatusDetails",
        tags = "2, 3, 4, 5, 6"
    )]
    pub smart_campaign_status_details: ::core::option::Option<
        get_smart_campaign_status_response::SmartCampaignStatusDetails,
    >,
}
/// Nested message and enum types in `GetSmartCampaignStatusResponse`.
pub mod get_smart_campaign_status_response {
    /// Additional details accompanying the status of a Smart campaign.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum SmartCampaignStatusDetails {
        /// Details related to Smart campaigns that are ineligible to serve.
        #[prost(message, tag = "2")]
        NotEligibleDetails(super::SmartCampaignNotEligibleDetails),
        /// Details related to Smart campaigns that are eligible to serve.
        #[prost(message, tag = "3")]
        EligibleDetails(super::SmartCampaignEligibleDetails),
        /// Details related to paused Smart campaigns.
        #[prost(message, tag = "4")]
        PausedDetails(super::SmartCampaignPausedDetails),
        /// Details related to removed Smart campaigns.
        #[prost(message, tag = "5")]
        RemovedDetails(super::SmartCampaignRemovedDetails),
        /// Details related to Smart campaigns that have ended.
        #[prost(message, tag = "6")]
        EndedDetails(super::SmartCampaignEndedDetails),
    }
}
/// Request message for
/// [SmartCampaignSettingService.MutateSmartCampaignSettings][google.ads.googleads.v16.services.SmartCampaignSettingService.MutateSmartCampaignSettings].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateSmartCampaignSettingsRequest {
    /// Required. The ID of the customer whose Smart campaign settings are being
    /// modified.
    #[prost(string, tag = "1")]
    pub customer_id: ::prost::alloc::string::String,
    /// Required. The list of operations to perform on individual Smart campaign
    /// settings.
    #[prost(message, repeated, tag = "2")]
    pub operations: ::prost::alloc::vec::Vec<SmartCampaignSettingOperation>,
    /// If true, successful operations will be carried out and invalid
    /// operations will return errors. If false, all operations will be carried
    /// out in one transaction if and only if they are all valid.
    /// Default is false.
    #[prost(bool, tag = "3")]
    pub partial_failure: bool,
    /// If true, the request is validated but not executed. Only errors are
    /// returned, not results.
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
    /// The response content type setting. Determines whether the mutable resource
    /// or just the resource name should be returned post mutation.
    #[prost(
        enumeration = "super::enums::response_content_type_enum::ResponseContentType",
        tag = "5"
    )]
    pub response_content_type: i32,
}
/// A single operation to update Smart campaign settings for a campaign.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SmartCampaignSettingOperation {
    /// Update operation: The Smart campaign setting must specify a valid
    /// resource name.
    #[prost(message, optional, tag = "1")]
    pub update: ::core::option::Option<super::resources::SmartCampaignSetting>,
    /// FieldMask that determines which resource fields are modified in an update.
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
/// Response message for campaign mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateSmartCampaignSettingsResponse {
    /// Errors that pertain to operation failures in the partial failure mode.
    /// Returned only when partial_failure = true and all errors occur inside the
    /// operations. If any errors occur outside the operations (for example, auth
    /// errors), we return an RPC level error.
    #[prost(message, optional, tag = "1")]
    pub partial_failure_error: ::core::option::Option<
        super::super::super::super::rpc::Status,
    >,
    /// All results for the mutate.
    #[prost(message, repeated, tag = "2")]
    pub results: ::prost::alloc::vec::Vec<MutateSmartCampaignSettingResult>,
}
/// The result for the Smart campaign setting mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateSmartCampaignSettingResult {
    /// Returned for successful operations.
    #[prost(string, tag = "1")]
    pub resource_name: ::prost::alloc::string::String,
    /// The mutated Smart campaign setting with only mutable fields after mutate.
    /// The field will only be returned when response_content_type is set to
    /// "MUTABLE_RESOURCE".
    #[prost(message, optional, tag = "2")]
    pub smart_campaign_setting: ::core::option::Option<
        super::resources::SmartCampaignSetting,
    >,
}
/// Generated server implementations.
pub mod smart_campaign_setting_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with SmartCampaignSettingServiceServer.
    #[async_trait]
    pub trait SmartCampaignSettingService: std::marker::Send + std::marker::Sync + 'static {
        /// Returns the status of the requested Smart campaign.
        async fn get_smart_campaign_status(
            &self,
            request: tonic::Request<super::GetSmartCampaignStatusRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetSmartCampaignStatusResponse>,
            tonic::Status,
        >;
        /// Updates Smart campaign settings for campaigns.
        async fn mutate_smart_campaign_settings(
            &self,
            request: tonic::Request<super::MutateSmartCampaignSettingsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MutateSmartCampaignSettingsResponse>,
            tonic::Status,
        >;
    }
    /// Service to manage Smart campaign settings.
    #[derive(Debug)]
    pub struct SmartCampaignSettingServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> SmartCampaignSettingServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>>
    for SmartCampaignSettingServiceServer<T>
    where
        T: SmartCampaignSettingService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/google.ads.googleads.v16.services.SmartCampaignSettingService/GetSmartCampaignStatus" => {
                    #[allow(non_camel_case_types)]
                    struct GetSmartCampaignStatusSvc<T: SmartCampaignSettingService>(
                        pub Arc<T>,
                    );
                    impl<
                        T: SmartCampaignSettingService,
                    > tonic::server::UnaryService<super::GetSmartCampaignStatusRequest>
                    for GetSmartCampaignStatusSvc<T> {
                        type Response = super::GetSmartCampaignStatusResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetSmartCampaignStatusRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as SmartCampaignSettingService>::get_smart_campaign_status(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetSmartCampaignStatusSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.ads.googleads.v16.services.SmartCampaignSettingService/MutateSmartCampaignSettings" => {
                    #[allow(non_camel_case_types)]
                    struct MutateSmartCampaignSettingsSvc<
                        T: SmartCampaignSettingService,
                    >(
                        pub Arc<T>,
                    );
                    impl<
                        T: SmartCampaignSettingService,
                    > tonic::server::UnaryService<
                        super::MutateSmartCampaignSettingsRequest,
                    > for MutateSmartCampaignSettingsSvc<T> {
                        type Response = super::MutateSmartCampaignSettingsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::MutateSmartCampaignSettingsRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as SmartCampaignSettingService>::mutate_smart_campaign_settings(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = MutateSmartCampaignSettingsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for SmartCampaignSettingServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "google.ads.googleads.v16.services.SmartCampaignSettingService";
    impl<T> tonic::server::NamedService for SmartCampaignSettingServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Request message for
/// [UserListService.MutateUserLists][google.ads.googleads.v16.services.UserListService.MutateUserLists].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateUserListsRequest {
    /// Required. The ID of the customer whose user lists are being modified.
    #[prost(string, tag = "1")]
    pub customer_id: ::prost::alloc::string::String,
    /// Required. The list of operations to perform on individual user lists.
    #[prost(message, repeated, tag = "2")]
    pub operations: ::prost::alloc::vec::Vec<UserListOperation>,
    /// If true, successful operations will be carried out and invalid
    /// operations will return errors. If false, all operations will be carried
    /// out in one transaction if and only if they are all valid.
    /// Default is false.
    #[prost(bool, tag = "3")]
    pub partial_failure: bool,
    /// If true, the request is validated but not executed. Only errors are
    /// returned, not results.
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
}
/// A single operation (create, update) on a user list.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UserListOperation {
    /// FieldMask that determines which resource fields are modified in an update.
    #[prost(message, optional, tag = "4")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// The mutate operation.
    #[prost(oneof = "user_list_operation::Operation", tags = "1, 2, 3")]
    pub operation: ::core::option::Option<user_list_operation::Operation>,
}
/// Nested message and enum types in `UserListOperation`.
pub mod user_list_operation {
    /// The mutate operation.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Operation {
        /// Create operation: No resource name is expected for the new user list.
        #[prost(message, tag = "1")]
        Create(super::super::resources::UserList),
        /// Update operation: The user list is expected to have a valid resource
        /// name.
        #[prost(message, tag = "2")]
        Update(super::super::resources::UserList),
        /// Remove operation: A resource name for the removed user list is expected,
        /// in this format:
        ///
        /// `customers/{customer_id}/userLists/{user_list_id}`
        #[prost(string, tag = "3")]
        Remove(::prost::alloc::string::String),
    }
}
/// Response message for user list mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateUserListsResponse {
    /// Errors that pertain to operation failures in the partial failure mode.
    /// Returned only when partial_failure = true and all errors occur inside the
    /// operations. If any errors occur outside the operations (for example, auth
    /// errors), we return an RPC level error.
    #[prost(message, optional, tag = "3")]
    pub partial_failure_error: ::core::option::Option<
        super::super::super::super::rpc::Status,
    >,
    /// All results for the mutate.
    #[prost(message, repeated, tag = "2")]
    pub results: ::prost::alloc::vec::Vec<MutateUserListResult>,
}
/// The result for the user list mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateUserListResult {
    /// Returned for successful operations.
    #[prost(string, tag = "1")]
    pub resource_name: ::prost::alloc::string::String,
}
/// Generated server implementations.
pub mod user_list_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with UserListServiceServer.
    #[async_trait]
    pub trait UserListService: std::marker::Send + std::marker::Sync + 'static {
        /// Creates or updates user lists. Operation statuses are returned.
        ///
        /// List of thrown errors:
        ///   [AuthenticationError]()
        ///   [AuthorizationError]()
        ///   [CollectionSizeError]()
        ///   [DatabaseError]()
        ///   [DistinctError]()
        ///   [FieldError]()
        ///   [FieldMaskError]()
        ///   [HeaderError]()
        ///   [InternalError]()
        ///   [MutateError]()
        ///   [NewResourceCreationError]()
        ///   [NotAllowlistedError]()
        ///   [NotEmptyError]()
        ///   [OperationAccessDeniedError]()
        ///   [QuotaError]()
        ///   [RangeError]()
        ///   [RequestError]()
        ///   [StringFormatError]()
        ///   [StringLengthError]()
        ///   [UserListError]()
        async fn mutate_user_lists(
            &self,
            request: tonic::Request<super::MutateUserListsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MutateUserListsResponse>,
            tonic::Status,
        >;
    }
    /// Service to manage user lists.
    #[derive(Debug)]
    pub struct UserListServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> UserListServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for UserListServiceServer<T>
    where
        T: UserListService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/google.ads.googleads.v16.services.UserListService/MutateUserLists" => {
                    #[allow(non_camel_case_types)]
                    struct MutateUserListsSvc<T: UserListService>(pub Arc<T>);
                    impl<
                        T: UserListService,
                    > tonic::server::UnaryService<super::MutateUserListsRequest>
                    for MutateUserListsSvc<T> {
                        type Response = super::MutateUserListsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::MutateUserListsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as UserListService>::mutate_user_lists(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = MutateUserListsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for UserListServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "google.ads.googleads.v16.services.UserListService";
    impl<T> tonic::server::NamedService for UserListServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Request message for
/// [GoogleAdsService.Search][google.ads.googleads.v16.services.GoogleAdsService.Search].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchGoogleAdsRequest {
    /// Required. The ID of the customer being queried.
    #[prost(string, tag = "1")]
    pub customer_id: ::prost::alloc::string::String,
    /// Required. The query string.
    #[prost(string, tag = "2")]
    pub query: ::prost::alloc::string::String,
    /// Token of the page to retrieve. If not specified, the first
    /// page of results will be returned. Use the value obtained from
    /// `next_page_token` in the previous response in order to request
    /// the next page of results.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Number of elements to retrieve in a single page.
    /// When too large a page is requested, the server may decide to
    /// further limit the number of returned resources.
    #[prost(int32, tag = "4")]
    pub page_size: i32,
    /// If true, the request is validated but not executed.
    #[prost(bool, tag = "5")]
    pub validate_only: bool,
    /// If true, the total number of results that match the query ignoring the
    /// LIMIT clause will be included in the response.
    /// Default is false.
    #[prost(bool, tag = "7")]
    pub return_total_results_count: bool,
    /// Determines whether a summary row will be returned. By default, summary row
    /// is not returned. If requested, the summary row will be sent in a response
    /// by itself after all other query results are returned.
    #[prost(
        enumeration = "super::enums::summary_row_setting_enum::SummaryRowSetting",
        tag = "8"
    )]
    pub summary_row_setting: i32,
}
/// Response message for
/// [GoogleAdsService.Search][google.ads.googleads.v16.services.GoogleAdsService.Search].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchGoogleAdsResponse {
    /// The list of rows that matched the query.
    #[prost(message, repeated, tag = "1")]
    pub results: ::prost::alloc::vec::Vec<GoogleAdsRow>,
    /// Pagination token used to retrieve the next page of results.
    /// Pass the content of this string as the `page_token` attribute of
    /// the next request. `next_page_token` is not returned for the last
    /// page.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    /// Total number of results that match the query ignoring the LIMIT
    /// clause.
    #[prost(int64, tag = "3")]
    pub total_results_count: i64,
    /// FieldMask that represents what fields were requested by the user.
    #[prost(message, optional, tag = "5")]
    pub field_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// Summary row that contains summary of metrics in results.
    /// Summary of metrics means aggregation of metrics across all results,
    /// here aggregation could be sum, average, rate, etc.
    #[prost(message, optional, tag = "6")]
    pub summary_row: ::core::option::Option<GoogleAdsRow>,
    /// The amount of resources consumed to serve the query.
    #[prost(int64, tag = "8")]
    pub query_resource_consumption: i64,
}
/// Request message for
/// [GoogleAdsService.SearchStream][google.ads.googleads.v16.services.GoogleAdsService.SearchStream].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchGoogleAdsStreamRequest {
    /// Required. The ID of the customer being queried.
    #[prost(string, tag = "1")]
    pub customer_id: ::prost::alloc::string::String,
    /// Required. The query string.
    #[prost(string, tag = "2")]
    pub query: ::prost::alloc::string::String,
    /// Determines whether a summary row will be returned. By default, summary row
    /// is not returned. If requested, the summary row will be sent in a response
    /// by itself after all other query results are returned.
    #[prost(
        enumeration = "super::enums::summary_row_setting_enum::SummaryRowSetting",
        tag = "3"
    )]
    pub summary_row_setting: i32,
}
/// Response message for
/// [GoogleAdsService.SearchStream][google.ads.googleads.v16.services.GoogleAdsService.SearchStream].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchGoogleAdsStreamResponse {
    /// The list of rows that matched the query.
    #[prost(message, repeated, tag = "1")]
    pub results: ::prost::alloc::vec::Vec<GoogleAdsRow>,
    /// FieldMask that represents what fields were requested by the user.
    #[prost(message, optional, tag = "2")]
    pub field_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// Summary row that contains summary of metrics in results.
    /// Summary of metrics means aggregation of metrics across all results,
    /// here aggregation could be sum, average, rate, etc.
    #[prost(message, optional, tag = "3")]
    pub summary_row: ::core::option::Option<GoogleAdsRow>,
    /// The unique id of the request that is used for debugging purposes.
    #[prost(string, tag = "4")]
    pub request_id: ::prost::alloc::string::String,
    /// The amount of resources consumed to serve the query.
    /// query_resource_consumption for the Summary row and non-Summary responses
    /// are returned separately in their respective rows.
    /// query_resource_consumption for non-Summary responses is returned in the
    /// final batch of results.
    #[prost(int64, tag = "6")]
    pub query_resource_consumption: i64,
}
/// A returned row from the query.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GoogleAdsRow {
    /// The account budget in the query.
    #[prost(message, optional, tag = "42")]
    pub account_budget: ::core::option::Option<super::resources::AccountBudget>,
    /// The account budget proposal referenced in the query.
    #[prost(message, optional, tag = "43")]
    pub account_budget_proposal: ::core::option::Option<
        super::resources::AccountBudgetProposal,
    >,
    /// The AccountLink referenced in the query.
    #[prost(message, optional, tag = "143")]
    pub account_link: ::core::option::Option<super::resources::AccountLink>,
    /// The ad group referenced in the query.
    #[prost(message, optional, tag = "3")]
    pub ad_group: ::core::option::Option<super::resources::AdGroup>,
    /// The ad referenced in the query.
    #[prost(message, optional, tag = "16")]
    pub ad_group_ad: ::core::option::Option<super::resources::AdGroupAd>,
    /// The ad group ad asset combination view in the query.
    #[prost(message, optional, tag = "193")]
    pub ad_group_ad_asset_combination_view: ::core::option::Option<
        super::resources::AdGroupAdAssetCombinationView,
    >,
    /// The ad group ad asset view in the query.
    #[prost(message, optional, tag = "131")]
    pub ad_group_ad_asset_view: ::core::option::Option<
        super::resources::AdGroupAdAssetView,
    >,
    /// The ad group ad label referenced in the query.
    #[prost(message, optional, tag = "120")]
    pub ad_group_ad_label: ::core::option::Option<super::resources::AdGroupAdLabel>,
    /// The ad group asset referenced in the query.
    #[prost(message, optional, tag = "154")]
    pub ad_group_asset: ::core::option::Option<super::resources::AdGroupAsset>,
    /// The ad group asset set referenced in the query.
    #[prost(message, optional, tag = "196")]
    pub ad_group_asset_set: ::core::option::Option<super::resources::AdGroupAssetSet>,
    /// The ad group audience view referenced in the query.
    #[prost(message, optional, tag = "57")]
    pub ad_group_audience_view: ::core::option::Option<
        super::resources::AdGroupAudienceView,
    >,
    /// The bid modifier referenced in the query.
    #[prost(message, optional, tag = "24")]
    pub ad_group_bid_modifier: ::core::option::Option<
        super::resources::AdGroupBidModifier,
    >,
    /// The criterion referenced in the query.
    #[prost(message, optional, tag = "17")]
    pub ad_group_criterion: ::core::option::Option<super::resources::AdGroupCriterion>,
    /// The ad group criterion customizer referenced in the query.
    #[prost(message, optional, tag = "187")]
    pub ad_group_criterion_customizer: ::core::option::Option<
        super::resources::AdGroupCriterionCustomizer,
    >,
    /// The ad group criterion label referenced in the query.
    #[prost(message, optional, tag = "121")]
    pub ad_group_criterion_label: ::core::option::Option<
        super::resources::AdGroupCriterionLabel,
    >,
    /// The ad group criterion simulation referenced in the query.
    #[prost(message, optional, tag = "110")]
    pub ad_group_criterion_simulation: ::core::option::Option<
        super::resources::AdGroupCriterionSimulation,
    >,
    /// The ad group customizer referenced in the query.
    #[prost(message, optional, tag = "185")]
    pub ad_group_customizer: ::core::option::Option<super::resources::AdGroupCustomizer>,
    /// The ad group extension setting referenced in the query.
    #[prost(message, optional, tag = "112")]
    pub ad_group_extension_setting: ::core::option::Option<
        super::resources::AdGroupExtensionSetting,
    >,
    /// The ad group feed referenced in the query.
    #[prost(message, optional, tag = "67")]
    pub ad_group_feed: ::core::option::Option<super::resources::AdGroupFeed>,
    /// The ad group label referenced in the query.
    #[prost(message, optional, tag = "115")]
    pub ad_group_label: ::core::option::Option<super::resources::AdGroupLabel>,
    /// The ad group simulation referenced in the query.
    #[prost(message, optional, tag = "107")]
    pub ad_group_simulation: ::core::option::Option<super::resources::AdGroupSimulation>,
    /// The ad parameter referenced in the query.
    #[prost(message, optional, tag = "130")]
    pub ad_parameter: ::core::option::Option<super::resources::AdParameter>,
    /// The age range view referenced in the query.
    #[prost(message, optional, tag = "48")]
    pub age_range_view: ::core::option::Option<super::resources::AgeRangeView>,
    /// The ad schedule view referenced in the query.
    #[prost(message, optional, tag = "89")]
    pub ad_schedule_view: ::core::option::Option<super::resources::AdScheduleView>,
    /// The domain category referenced in the query.
    #[prost(message, optional, tag = "91")]
    pub domain_category: ::core::option::Option<super::resources::DomainCategory>,
    /// The asset referenced in the query.
    #[prost(message, optional, tag = "105")]
    pub asset: ::core::option::Option<super::resources::Asset>,
    /// The asset field type view referenced in the query.
    #[prost(message, optional, tag = "168")]
    pub asset_field_type_view: ::core::option::Option<
        super::resources::AssetFieldTypeView,
    >,
    /// The asset group asset referenced in the query.
    #[prost(message, optional, tag = "173")]
    pub asset_group_asset: ::core::option::Option<super::resources::AssetGroupAsset>,
    /// The asset group signal referenced in the query.
    #[prost(message, optional, tag = "191")]
    pub asset_group_signal: ::core::option::Option<super::resources::AssetGroupSignal>,
    /// The asset group listing group filter referenced in the query.
    #[prost(message, optional, tag = "182")]
    pub asset_group_listing_group_filter: ::core::option::Option<
        super::resources::AssetGroupListingGroupFilter,
    >,
    /// The asset group product group view referenced in the query.
    #[prost(message, optional, tag = "189")]
    pub asset_group_product_group_view: ::core::option::Option<
        super::resources::AssetGroupProductGroupView,
    >,
    /// The asset group top combination view referenced in the query.
    #[prost(message, optional, tag = "199")]
    pub asset_group_top_combination_view: ::core::option::Option<
        super::resources::AssetGroupTopCombinationView,
    >,
    /// The asset group referenced in the query.
    #[prost(message, optional, tag = "172")]
    pub asset_group: ::core::option::Option<super::resources::AssetGroup>,
    /// The asset set asset referenced in the query.
    #[prost(message, optional, tag = "180")]
    pub asset_set_asset: ::core::option::Option<super::resources::AssetSetAsset>,
    /// The asset set referenced in the query.
    #[prost(message, optional, tag = "179")]
    pub asset_set: ::core::option::Option<super::resources::AssetSet>,
    /// The asset set type view referenced in the query.
    #[prost(message, optional, tag = "197")]
    pub asset_set_type_view: ::core::option::Option<super::resources::AssetSetTypeView>,
    /// The batch job referenced in the query.
    #[prost(message, optional, tag = "139")]
    pub batch_job: ::core::option::Option<super::resources::BatchJob>,
    /// The bidding data exclusion referenced in the query.
    #[prost(message, optional, tag = "159")]
    pub bidding_data_exclusion: ::core::option::Option<
        super::resources::BiddingDataExclusion,
    >,
    /// The bidding seasonality adjustment referenced in the query.
    #[prost(message, optional, tag = "160")]
    pub bidding_seasonality_adjustment: ::core::option::Option<
        super::resources::BiddingSeasonalityAdjustment,
    >,
    /// The bidding strategy referenced in the query.
    #[prost(message, optional, tag = "18")]
    pub bidding_strategy: ::core::option::Option<super::resources::BiddingStrategy>,
    /// The bidding strategy simulation referenced in the query.
    #[prost(message, optional, tag = "158")]
    pub bidding_strategy_simulation: ::core::option::Option<
        super::resources::BiddingStrategySimulation,
    >,
    /// The billing setup referenced in the query.
    #[prost(message, optional, tag = "41")]
    pub billing_setup: ::core::option::Option<super::resources::BillingSetup>,
    /// The call view referenced in the query.
    #[prost(message, optional, tag = "152")]
    pub call_view: ::core::option::Option<super::resources::CallView>,
    /// The campaign budget referenced in the query.
    #[prost(message, optional, tag = "19")]
    pub campaign_budget: ::core::option::Option<super::resources::CampaignBudget>,
    /// The campaign referenced in the query.
    #[prost(message, optional, tag = "2")]
    pub campaign: ::core::option::Option<super::resources::Campaign>,
    /// The campaign asset referenced in the query.
    #[prost(message, optional, tag = "142")]
    pub campaign_asset: ::core::option::Option<super::resources::CampaignAsset>,
    /// The campaign asset set referenced in the query.
    #[prost(message, optional, tag = "181")]
    pub campaign_asset_set: ::core::option::Option<super::resources::CampaignAssetSet>,
    /// The campaign audience view referenced in the query.
    #[prost(message, optional, tag = "69")]
    pub campaign_audience_view: ::core::option::Option<
        super::resources::CampaignAudienceView,
    >,
    /// The campaign bid modifier referenced in the query.
    #[prost(message, optional, tag = "26")]
    pub campaign_bid_modifier: ::core::option::Option<
        super::resources::CampaignBidModifier,
    >,
    /// The CampaignConversionGoal referenced in the query.
    #[prost(message, optional, tag = "175")]
    pub campaign_conversion_goal: ::core::option::Option<
        super::resources::CampaignConversionGoal,
    >,
    /// The campaign criterion referenced in the query.
    #[prost(message, optional, tag = "20")]
    pub campaign_criterion: ::core::option::Option<super::resources::CampaignCriterion>,
    /// The campaign customizer referenced in the query.
    #[prost(message, optional, tag = "186")]
    pub campaign_customizer: ::core::option::Option<
        super::resources::CampaignCustomizer,
    >,
    /// The campaign draft referenced in the query.
    #[prost(message, optional, tag = "49")]
    pub campaign_draft: ::core::option::Option<super::resources::CampaignDraft>,
    /// The campaign extension setting referenced in the query.
    #[prost(message, optional, tag = "113")]
    pub campaign_extension_setting: ::core::option::Option<
        super::resources::CampaignExtensionSetting,
    >,
    /// The campaign feed referenced in the query.
    #[prost(message, optional, tag = "63")]
    pub campaign_feed: ::core::option::Option<super::resources::CampaignFeed>,
    /// Campaign Group referenced in AWQL query.
    #[prost(message, optional, tag = "25")]
    pub campaign_group: ::core::option::Option<super::resources::CampaignGroup>,
    /// The campaign label referenced in the query.
    #[prost(message, optional, tag = "108")]
    pub campaign_label: ::core::option::Option<super::resources::CampaignLabel>,
    /// The campaign lifecycle goal referenced in the query.
    #[prost(message, optional, tag = "213")]
    pub campaign_lifecycle_goal: ::core::option::Option<
        super::resources::CampaignLifecycleGoal,
    >,
    /// The campaign search term insight referenced in the query.
    #[prost(message, optional, tag = "204")]
    pub campaign_search_term_insight: ::core::option::Option<
        super::resources::CampaignSearchTermInsight,
    >,
    /// Campaign Shared Set referenced in AWQL query.
    #[prost(message, optional, tag = "30")]
    pub campaign_shared_set: ::core::option::Option<super::resources::CampaignSharedSet>,
    /// The campaign simulation referenced in the query.
    #[prost(message, optional, tag = "157")]
    pub campaign_simulation: ::core::option::Option<
        super::resources::CampaignSimulation,
    >,
    /// The carrier constant referenced in the query.
    #[prost(message, optional, tag = "66")]
    pub carrier_constant: ::core::option::Option<super::resources::CarrierConstant>,
    /// The ChangeEvent referenced in the query.
    #[prost(message, optional, tag = "145")]
    pub change_event: ::core::option::Option<super::resources::ChangeEvent>,
    /// The ChangeStatus referenced in the query.
    #[prost(message, optional, tag = "37")]
    pub change_status: ::core::option::Option<super::resources::ChangeStatus>,
    /// The CombinedAudience referenced in the query.
    #[prost(message, optional, tag = "148")]
    pub combined_audience: ::core::option::Option<super::resources::CombinedAudience>,
    /// The Audience referenced in the query.
    #[prost(message, optional, tag = "190")]
    pub audience: ::core::option::Option<super::resources::Audience>,
    /// The conversion action referenced in the query.
    #[prost(message, optional, tag = "103")]
    pub conversion_action: ::core::option::Option<super::resources::ConversionAction>,
    /// The conversion custom variable referenced in the query.
    #[prost(message, optional, tag = "153")]
    pub conversion_custom_variable: ::core::option::Option<
        super::resources::ConversionCustomVariable,
    >,
    /// The ConversionGoalCampaignConfig referenced in the query.
    #[prost(message, optional, tag = "177")]
    pub conversion_goal_campaign_config: ::core::option::Option<
        super::resources::ConversionGoalCampaignConfig,
    >,
    /// The conversion value rule referenced in the query.
    #[prost(message, optional, tag = "164")]
    pub conversion_value_rule: ::core::option::Option<
        super::resources::ConversionValueRule,
    >,
    /// The conversion value rule set referenced in the query.
    #[prost(message, optional, tag = "165")]
    pub conversion_value_rule_set: ::core::option::Option<
        super::resources::ConversionValueRuleSet,
    >,
    /// The ClickView referenced in the query.
    #[prost(message, optional, tag = "122")]
    pub click_view: ::core::option::Option<super::resources::ClickView>,
    /// The currency constant referenced in the query.
    #[prost(message, optional, tag = "134")]
    pub currency_constant: ::core::option::Option<super::resources::CurrencyConstant>,
    /// The CustomAudience referenced in the query.
    #[prost(message, optional, tag = "147")]
    pub custom_audience: ::core::option::Option<super::resources::CustomAudience>,
    /// The CustomConversionGoal referenced in the query.
    #[prost(message, optional, tag = "176")]
    pub custom_conversion_goal: ::core::option::Option<
        super::resources::CustomConversionGoal,
    >,
    /// The CustomInterest referenced in the query.
    #[prost(message, optional, tag = "104")]
    pub custom_interest: ::core::option::Option<super::resources::CustomInterest>,
    /// The customer referenced in the query.
    #[prost(message, optional, tag = "1")]
    pub customer: ::core::option::Option<super::resources::Customer>,
    /// The customer asset referenced in the query.
    #[prost(message, optional, tag = "155")]
    pub customer_asset: ::core::option::Option<super::resources::CustomerAsset>,
    /// The customer asset set referenced in the query.
    #[prost(message, optional, tag = "195")]
    pub customer_asset_set: ::core::option::Option<super::resources::CustomerAssetSet>,
    /// The accessible bidding strategy referenced in the query.
    #[prost(message, optional, tag = "169")]
    pub accessible_bidding_strategy: ::core::option::Option<
        super::resources::AccessibleBiddingStrategy,
    >,
    /// The customer customizer referenced in the query.
    #[prost(message, optional, tag = "184")]
    pub customer_customizer: ::core::option::Option<
        super::resources::CustomerCustomizer,
    >,
    /// The CustomerManagerLink referenced in the query.
    #[prost(message, optional, tag = "61")]
    pub customer_manager_link: ::core::option::Option<
        super::resources::CustomerManagerLink,
    >,
    /// The CustomerClientLink referenced in the query.
    #[prost(message, optional, tag = "62")]
    pub customer_client_link: ::core::option::Option<
        super::resources::CustomerClientLink,
    >,
    /// The CustomerClient referenced in the query.
    #[prost(message, optional, tag = "70")]
    pub customer_client: ::core::option::Option<super::resources::CustomerClient>,
    /// The CustomerConversionGoal referenced in the query.
    #[prost(message, optional, tag = "174")]
    pub customer_conversion_goal: ::core::option::Option<
        super::resources::CustomerConversionGoal,
    >,
    /// The customer extension setting referenced in the query.
    #[prost(message, optional, tag = "114")]
    pub customer_extension_setting: ::core::option::Option<
        super::resources::CustomerExtensionSetting,
    >,
    /// The customer feed referenced in the query.
    #[prost(message, optional, tag = "64")]
    pub customer_feed: ::core::option::Option<super::resources::CustomerFeed>,
    /// The customer label referenced in the query.
    #[prost(message, optional, tag = "124")]
    pub customer_label: ::core::option::Option<super::resources::CustomerLabel>,
    /// The customer lifecycle goal referenced in the query.
    #[prost(message, optional, tag = "212")]
    pub customer_lifecycle_goal: ::core::option::Option<
        super::resources::CustomerLifecycleGoal,
    >,
    /// The customer negative criterion referenced in the query.
    #[prost(message, optional, tag = "88")]
    pub customer_negative_criterion: ::core::option::Option<
        super::resources::CustomerNegativeCriterion,
    >,
    /// The customer search term insight referenced in the query.
    #[prost(message, optional, tag = "205")]
    pub customer_search_term_insight: ::core::option::Option<
        super::resources::CustomerSearchTermInsight,
    >,
    /// The CustomerUserAccess referenced in the query.
    #[prost(message, optional, tag = "146")]
    pub customer_user_access: ::core::option::Option<
        super::resources::CustomerUserAccess,
    >,
    /// The CustomerUserAccessInvitation referenced in the query.
    #[prost(message, optional, tag = "150")]
    pub customer_user_access_invitation: ::core::option::Option<
        super::resources::CustomerUserAccessInvitation,
    >,
    /// The customizer attribute referenced in the query.
    #[prost(message, optional, tag = "178")]
    pub customizer_attribute: ::core::option::Option<
        super::resources::CustomizerAttribute,
    >,
    /// The detail placement view referenced in the query.
    #[prost(message, optional, tag = "118")]
    pub detail_placement_view: ::core::option::Option<
        super::resources::DetailPlacementView,
    >,
    /// The detailed demographic referenced in the query.
    #[prost(message, optional, tag = "166")]
    pub detailed_demographic: ::core::option::Option<
        super::resources::DetailedDemographic,
    >,
    /// The display keyword view referenced in the query.
    #[prost(message, optional, tag = "47")]
    pub display_keyword_view: ::core::option::Option<
        super::resources::DisplayKeywordView,
    >,
    /// The distance view referenced in the query.
    #[prost(message, optional, tag = "132")]
    pub distance_view: ::core::option::Option<super::resources::DistanceView>,
    /// The dynamic search ads search term view referenced in the query.
    #[prost(message, optional, tag = "106")]
    pub dynamic_search_ads_search_term_view: ::core::option::Option<
        super::resources::DynamicSearchAdsSearchTermView,
    >,
    /// The expanded landing page view referenced in the query.
    #[prost(message, optional, tag = "128")]
    pub expanded_landing_page_view: ::core::option::Option<
        super::resources::ExpandedLandingPageView,
    >,
    /// The extension feed item referenced in the query.
    #[prost(message, optional, tag = "85")]
    pub extension_feed_item: ::core::option::Option<super::resources::ExtensionFeedItem>,
    /// The feed referenced in the query.
    #[prost(message, optional, tag = "46")]
    pub feed: ::core::option::Option<super::resources::Feed>,
    /// The feed item referenced in the query.
    #[prost(message, optional, tag = "50")]
    pub feed_item: ::core::option::Option<super::resources::FeedItem>,
    /// The feed item set referenced in the query.
    #[prost(message, optional, tag = "149")]
    pub feed_item_set: ::core::option::Option<super::resources::FeedItemSet>,
    /// The feed item set link referenced in the query.
    #[prost(message, optional, tag = "151")]
    pub feed_item_set_link: ::core::option::Option<super::resources::FeedItemSetLink>,
    /// The feed item target referenced in the query.
    #[prost(message, optional, tag = "116")]
    pub feed_item_target: ::core::option::Option<super::resources::FeedItemTarget>,
    /// The feed mapping referenced in the query.
    #[prost(message, optional, tag = "58")]
    pub feed_mapping: ::core::option::Option<super::resources::FeedMapping>,
    /// The feed placeholder view referenced in the query.
    #[prost(message, optional, tag = "97")]
    pub feed_placeholder_view: ::core::option::Option<
        super::resources::FeedPlaceholderView,
    >,
    /// The gender view referenced in the query.
    #[prost(message, optional, tag = "40")]
    pub gender_view: ::core::option::Option<super::resources::GenderView>,
    /// The geo target constant referenced in the query.
    #[prost(message, optional, tag = "23")]
    pub geo_target_constant: ::core::option::Option<super::resources::GeoTargetConstant>,
    /// The geographic view referenced in the query.
    #[prost(message, optional, tag = "125")]
    pub geographic_view: ::core::option::Option<super::resources::GeographicView>,
    /// The group placement view referenced in the query.
    #[prost(message, optional, tag = "119")]
    pub group_placement_view: ::core::option::Option<
        super::resources::GroupPlacementView,
    >,
    /// The hotel group view referenced in the query.
    #[prost(message, optional, tag = "51")]
    pub hotel_group_view: ::core::option::Option<super::resources::HotelGroupView>,
    /// The hotel performance view referenced in the query.
    #[prost(message, optional, tag = "71")]
    pub hotel_performance_view: ::core::option::Option<
        super::resources::HotelPerformanceView,
    >,
    /// The hotel reconciliation referenced in the query.
    #[prost(message, optional, tag = "188")]
    pub hotel_reconciliation: ::core::option::Option<
        super::resources::HotelReconciliation,
    >,
    /// The income range view referenced in the query.
    #[prost(message, optional, tag = "138")]
    pub income_range_view: ::core::option::Option<super::resources::IncomeRangeView>,
    /// The keyword view referenced in the query.
    #[prost(message, optional, tag = "21")]
    pub keyword_view: ::core::option::Option<super::resources::KeywordView>,
    /// The keyword plan referenced in the query.
    #[prost(message, optional, tag = "32")]
    pub keyword_plan: ::core::option::Option<super::resources::KeywordPlan>,
    /// The keyword plan campaign referenced in the query.
    #[prost(message, optional, tag = "33")]
    pub keyword_plan_campaign: ::core::option::Option<
        super::resources::KeywordPlanCampaign,
    >,
    /// The keyword plan campaign keyword referenced in the query.
    #[prost(message, optional, tag = "140")]
    pub keyword_plan_campaign_keyword: ::core::option::Option<
        super::resources::KeywordPlanCampaignKeyword,
    >,
    /// The keyword plan ad group referenced in the query.
    #[prost(message, optional, tag = "35")]
    pub keyword_plan_ad_group: ::core::option::Option<
        super::resources::KeywordPlanAdGroup,
    >,
    /// The keyword plan ad group referenced in the query.
    #[prost(message, optional, tag = "141")]
    pub keyword_plan_ad_group_keyword: ::core::option::Option<
        super::resources::KeywordPlanAdGroupKeyword,
    >,
    /// The keyword theme constant referenced in the query.
    #[prost(message, optional, tag = "163")]
    pub keyword_theme_constant: ::core::option::Option<
        super::resources::KeywordThemeConstant,
    >,
    /// The label referenced in the query.
    #[prost(message, optional, tag = "52")]
    pub label: ::core::option::Option<super::resources::Label>,
    /// The landing page view referenced in the query.
    #[prost(message, optional, tag = "126")]
    pub landing_page_view: ::core::option::Option<super::resources::LandingPageView>,
    /// The language constant referenced in the query.
    #[prost(message, optional, tag = "55")]
    pub language_constant: ::core::option::Option<super::resources::LanguageConstant>,
    /// The location view referenced in the query.
    #[prost(message, optional, tag = "123")]
    pub location_view: ::core::option::Option<super::resources::LocationView>,
    /// The managed placement view referenced in the query.
    #[prost(message, optional, tag = "53")]
    pub managed_placement_view: ::core::option::Option<
        super::resources::ManagedPlacementView,
    >,
    /// The media file referenced in the query.
    #[prost(message, optional, tag = "90")]
    pub media_file: ::core::option::Option<super::resources::MediaFile>,
    /// The local services employee referenced in the query.
    #[prost(message, optional, tag = "223")]
    pub local_services_employee: ::core::option::Option<
        super::resources::LocalServicesEmployee,
    >,
    /// The local services verification artifact referenced in the query.
    #[prost(message, optional, tag = "211")]
    pub local_services_verification_artifact: ::core::option::Option<
        super::resources::LocalServicesVerificationArtifact,
    >,
    /// The mobile app category constant referenced in the query.
    #[prost(message, optional, tag = "87")]
    pub mobile_app_category_constant: ::core::option::Option<
        super::resources::MobileAppCategoryConstant,
    >,
    /// The mobile device constant referenced in the query.
    #[prost(message, optional, tag = "98")]
    pub mobile_device_constant: ::core::option::Option<
        super::resources::MobileDeviceConstant,
    >,
    /// Offline conversion upload client summary.
    #[prost(message, optional, tag = "216")]
    pub offline_conversion_upload_client_summary: ::core::option::Option<
        super::resources::OfflineConversionUploadClientSummary,
    >,
    /// The offline user data job referenced in the query.
    #[prost(message, optional, tag = "137")]
    pub offline_user_data_job: ::core::option::Option<
        super::resources::OfflineUserDataJob,
    >,
    /// The operating system version constant referenced in the query.
    #[prost(message, optional, tag = "86")]
    pub operating_system_version_constant: ::core::option::Option<
        super::resources::OperatingSystemVersionConstant,
    >,
    /// The paid organic search term view referenced in the query.
    #[prost(message, optional, tag = "129")]
    pub paid_organic_search_term_view: ::core::option::Option<
        super::resources::PaidOrganicSearchTermView,
    >,
    /// The qualifying question referenced in the query.
    #[prost(message, optional, tag = "202")]
    pub qualifying_question: ::core::option::Option<
        super::resources::QualifyingQuestion,
    >,
    /// The parental status view referenced in the query.
    #[prost(message, optional, tag = "45")]
    pub parental_status_view: ::core::option::Option<
        super::resources::ParentalStatusView,
    >,
    /// The per store view referenced in the query.
    #[prost(message, optional, tag = "198")]
    pub per_store_view: ::core::option::Option<super::resources::PerStoreView>,
    /// The product category referenced in the query.
    #[prost(message, optional, tag = "208")]
    pub product_category_constant: ::core::option::Option<
        super::resources::ProductCategoryConstant,
    >,
    /// The product group view referenced in the query.
    #[prost(message, optional, tag = "54")]
    pub product_group_view: ::core::option::Option<super::resources::ProductGroupView>,
    /// The product link referenced in the query.
    #[prost(message, optional, tag = "194")]
    pub product_link: ::core::option::Option<super::resources::ProductLink>,
    /// The product link invitation in the query.
    #[prost(message, optional, tag = "209")]
    pub product_link_invitation: ::core::option::Option<
        super::resources::ProductLinkInvitation,
    >,
    /// The recommendation referenced in the query.
    #[prost(message, optional, tag = "22")]
    pub recommendation: ::core::option::Option<super::resources::Recommendation>,
    /// The recommendation subscription referenced in the query.
    #[prost(message, optional, tag = "220")]
    pub recommendation_subscription: ::core::option::Option<
        super::resources::RecommendationSubscription,
    >,
    /// The search term view referenced in the query.
    #[prost(message, optional, tag = "68")]
    pub search_term_view: ::core::option::Option<super::resources::SearchTermView>,
    /// The shared set referenced in the query.
    #[prost(message, optional, tag = "29")]
    pub shared_criterion: ::core::option::Option<super::resources::SharedCriterion>,
    /// The shared set referenced in the query.
    #[prost(message, optional, tag = "27")]
    pub shared_set: ::core::option::Option<super::resources::SharedSet>,
    /// The Smart campaign setting referenced in the query.
    #[prost(message, optional, tag = "167")]
    pub smart_campaign_setting: ::core::option::Option<
        super::resources::SmartCampaignSetting,
    >,
    /// The shopping performance view referenced in the query.
    #[prost(message, optional, tag = "117")]
    pub shopping_performance_view: ::core::option::Option<
        super::resources::ShoppingPerformanceView,
    >,
    /// The Smart campaign search term view referenced in the query.
    #[prost(message, optional, tag = "170")]
    pub smart_campaign_search_term_view: ::core::option::Option<
        super::resources::SmartCampaignSearchTermView,
    >,
    /// The AccountLink referenced in the query.
    #[prost(message, optional, tag = "144")]
    pub third_party_app_analytics_link: ::core::option::Option<
        super::resources::ThirdPartyAppAnalyticsLink,
    >,
    /// The topic view referenced in the query.
    #[prost(message, optional, tag = "44")]
    pub topic_view: ::core::option::Option<super::resources::TopicView>,
    /// The travel activity group view referenced in the query.
    #[prost(message, optional, tag = "201")]
    pub travel_activity_group_view: ::core::option::Option<
        super::resources::TravelActivityGroupView,
    >,
    /// The travel activity performance view referenced in the query.
    #[prost(message, optional, tag = "200")]
    pub travel_activity_performance_view: ::core::option::Option<
        super::resources::TravelActivityPerformanceView,
    >,
    /// The experiment referenced in the query.
    #[prost(message, optional, tag = "133")]
    pub experiment: ::core::option::Option<super::resources::Experiment>,
    /// The experiment arm referenced in the query.
    #[prost(message, optional, tag = "183")]
    pub experiment_arm: ::core::option::Option<super::resources::ExperimentArm>,
    /// The user interest referenced in the query.
    #[prost(message, optional, tag = "59")]
    pub user_interest: ::core::option::Option<super::resources::UserInterest>,
    /// The life event referenced in the query.
    #[prost(message, optional, tag = "161")]
    pub life_event: ::core::option::Option<super::resources::LifeEvent>,
    /// The user list referenced in the query.
    #[prost(message, optional, tag = "38")]
    pub user_list: ::core::option::Option<super::resources::UserList>,
    /// The user location view referenced in the query.
    #[prost(message, optional, tag = "135")]
    pub user_location_view: ::core::option::Option<super::resources::UserLocationView>,
    /// The remarketing action referenced in the query.
    #[prost(message, optional, tag = "60")]
    pub remarketing_action: ::core::option::Option<super::resources::RemarketingAction>,
    /// The topic constant referenced in the query.
    #[prost(message, optional, tag = "31")]
    pub topic_constant: ::core::option::Option<super::resources::TopicConstant>,
    /// The video referenced in the query.
    #[prost(message, optional, tag = "39")]
    pub video: ::core::option::Option<super::resources::Video>,
    /// The webpage view referenced in the query.
    #[prost(message, optional, tag = "162")]
    pub webpage_view: ::core::option::Option<super::resources::WebpageView>,
    /// The lead form user submission referenced in the query.
    #[prost(message, optional, tag = "192")]
    pub lead_form_submission_data: ::core::option::Option<
        super::resources::LeadFormSubmissionData,
    >,
    /// The local services lead referenced in the query.
    #[prost(message, optional, tag = "210")]
    pub local_services_lead: ::core::option::Option<super::resources::LocalServicesLead>,
    /// The local services lead conversationreferenced in the query.
    #[prost(message, optional, tag = "214")]
    pub local_services_lead_conversation: ::core::option::Option<
        super::resources::LocalServicesLeadConversation,
    >,
    /// The android privacy shared key google ad group referenced in the query.
    #[prost(message, optional, tag = "217")]
    pub android_privacy_shared_key_google_ad_group: ::core::option::Option<
        super::resources::AndroidPrivacySharedKeyGoogleAdGroup,
    >,
    /// The android privacy shared key google campaign referenced in the query.
    #[prost(message, optional, tag = "218")]
    pub android_privacy_shared_key_google_campaign: ::core::option::Option<
        super::resources::AndroidPrivacySharedKeyGoogleCampaign,
    >,
    /// The android privacy shared key google network type referenced in the query.
    #[prost(message, optional, tag = "219")]
    pub android_privacy_shared_key_google_network_type: ::core::option::Option<
        super::resources::AndroidPrivacySharedKeyGoogleNetworkType,
    >,
    /// The metrics.
    #[prost(message, optional, tag = "4")]
    pub metrics: ::core::option::Option<super::common::Metrics>,
    /// The segments.
    #[prost(message, optional, tag = "102")]
    pub segments: ::core::option::Option<super::common::Segments>,
}
/// Request message for
/// [GoogleAdsService.Mutate][google.ads.googleads.v16.services.GoogleAdsService.Mutate].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateGoogleAdsRequest {
    /// Required. The ID of the customer whose resources are being modified.
    #[prost(string, tag = "1")]
    pub customer_id: ::prost::alloc::string::String,
    /// Required. The list of operations to perform on individual resources.
    #[prost(message, repeated, tag = "2")]
    pub mutate_operations: ::prost::alloc::vec::Vec<MutateOperation>,
    /// If true, successful operations will be carried out and invalid
    /// operations will return errors. If false, all operations will be carried
    /// out in one transaction if and only if they are all valid.
    /// Default is false.
    #[prost(bool, tag = "3")]
    pub partial_failure: bool,
    /// If true, the request is validated but not executed. Only errors are
    /// returned, not results.
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
    /// The response content type setting. Determines whether the mutable resource
    /// or just the resource name should be returned post mutation. The mutable
    /// resource will only be returned if the resource has the appropriate response
    /// field. For example, MutateCampaignResult.campaign.
    #[prost(
        enumeration = "super::enums::response_content_type_enum::ResponseContentType",
        tag = "5"
    )]
    pub response_content_type: i32,
}
/// Response message for
/// [GoogleAdsService.Mutate][google.ads.googleads.v16.services.GoogleAdsService.Mutate].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateGoogleAdsResponse {
    /// Errors that pertain to operation failures in the partial failure mode.
    /// Returned only when partial_failure = true and all errors occur inside the
    /// operations. If any errors occur outside the operations (for example, auth
    /// errors), we return an RPC level error.
    #[prost(message, optional, tag = "3")]
    pub partial_failure_error: ::core::option::Option<
        super::super::super::super::rpc::Status,
    >,
    /// All responses for the mutate.
    #[prost(message, repeated, tag = "1")]
    pub mutate_operation_responses: ::prost::alloc::vec::Vec<MutateOperationResponse>,
}
/// A single operation (create, update, remove) on a resource.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateOperation {
    /// The mutate operation.
    #[prost(
        oneof = "mutate_operation::Operation",
        tags = "17, 1, 56, 2, 77, 18, 3, 75, 19, 20, 21, 5, 49, 22, 23, 65, 78, 80, 62, 71, 72, 81, 58, 59, 6, 52, 73, 7, 8, 67, 13, 76, 24, 26, 27, 9, 28, 10, 11, 12, 55, 69, 63, 64, 68, 57, 66, 79, 30, 31, 32, 34, 35, 70, 82, 83, 36, 37, 53, 54, 38, 39, 40, 44, 50, 51, 45, 48, 41, 86, 43, 14, 15, 61, 16"
    )]
    pub operation: ::core::option::Option<mutate_operation::Operation>,
}
/// Nested message and enum types in `MutateOperation`.
pub mod mutate_operation {
    /// The mutate operation.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Operation {
        /// An ad group ad label mutate operation.
        #[prost(message, tag = "17")]
        AdGroupAdLabelOperation(super::AdGroupAdLabelOperation),
        /// An ad group ad mutate operation.
        #[prost(message, tag = "1")]
        AdGroupAdOperation(super::AdGroupAdOperation),
        /// An ad group asset mutate operation.
        #[prost(message, tag = "56")]
        AdGroupAssetOperation(super::AdGroupAssetOperation),
        /// An ad group bid modifier mutate operation.
        #[prost(message, tag = "2")]
        AdGroupBidModifierOperation(super::AdGroupBidModifierOperation),
        /// An ad group criterion customizer mutate operation.
        #[prost(message, tag = "77")]
        AdGroupCriterionCustomizerOperation(super::AdGroupCriterionCustomizerOperation),
        /// An ad group criterion label mutate operation.
        #[prost(message, tag = "18")]
        AdGroupCriterionLabelOperation(super::AdGroupCriterionLabelOperation),
        /// An ad group criterion mutate operation.
        #[prost(message, tag = "3")]
        AdGroupCriterionOperation(super::AdGroupCriterionOperation),
        /// An ad group customizer mutate operation.
        #[prost(message, tag = "75")]
        AdGroupCustomizerOperation(super::AdGroupCustomizerOperation),
        /// An ad group extension setting mutate operation.
        #[prost(message, tag = "19")]
        AdGroupExtensionSettingOperation(super::AdGroupExtensionSettingOperation),
        /// An ad group feed mutate operation.
        #[prost(message, tag = "20")]
        AdGroupFeedOperation(super::AdGroupFeedOperation),
        /// An ad group label mutate operation.
        #[prost(message, tag = "21")]
        AdGroupLabelOperation(super::AdGroupLabelOperation),
        /// An ad group mutate operation.
        #[prost(message, tag = "5")]
        AdGroupOperation(super::AdGroupOperation),
        /// An ad mutate operation.
        #[prost(message, tag = "49")]
        AdOperation(super::AdOperation),
        /// An ad parameter mutate operation.
        #[prost(message, tag = "22")]
        AdParameterOperation(super::AdParameterOperation),
        /// An asset mutate operation.
        #[prost(message, tag = "23")]
        AssetOperation(super::AssetOperation),
        /// An asset group asset mutate operation.
        #[prost(message, tag = "65")]
        AssetGroupAssetOperation(super::AssetGroupAssetOperation),
        /// An asset group listing group filter mutate operation.
        #[prost(message, tag = "78")]
        AssetGroupListingGroupFilterOperation(
            super::AssetGroupListingGroupFilterOperation,
        ),
        /// An asset group signal mutate operation.
        #[prost(message, tag = "80")]
        AssetGroupSignalOperation(super::AssetGroupSignalOperation),
        /// An asset group mutate operation.
        #[prost(message, tag = "62")]
        AssetGroupOperation(super::AssetGroupOperation),
        /// An asset set asset mutate operation.
        #[prost(message, tag = "71")]
        AssetSetAssetOperation(super::AssetSetAssetOperation),
        /// An asset set mutate operation.
        #[prost(message, tag = "72")]
        AssetSetOperation(super::AssetSetOperation),
        /// An audience mutate operation.
        #[prost(message, tag = "81")]
        AudienceOperation(super::AudienceOperation),
        /// A bidding data exclusion mutate operation.
        #[prost(message, tag = "58")]
        BiddingDataExclusionOperation(super::BiddingDataExclusionOperation),
        /// A bidding seasonality adjustment mutate operation.
        #[prost(message, tag = "59")]
        BiddingSeasonalityAdjustmentOperation(
            super::BiddingSeasonalityAdjustmentOperation,
        ),
        /// A bidding strategy mutate operation.
        #[prost(message, tag = "6")]
        BiddingStrategyOperation(super::BiddingStrategyOperation),
        /// A campaign asset mutate operation.
        #[prost(message, tag = "52")]
        CampaignAssetOperation(super::CampaignAssetOperation),
        /// A campaign asset mutate operation.
        #[prost(message, tag = "73")]
        CampaignAssetSetOperation(super::CampaignAssetSetOperation),
        /// A campaign bid modifier mutate operation.
        #[prost(message, tag = "7")]
        CampaignBidModifierOperation(super::CampaignBidModifierOperation),
        /// A campaign budget mutate operation.
        #[prost(message, tag = "8")]
        CampaignBudgetOperation(super::CampaignBudgetOperation),
        /// A campaign conversion goal mutate operation.
        #[prost(message, tag = "67")]
        CampaignConversionGoalOperation(super::CampaignConversionGoalOperation),
        /// A campaign criterion mutate operation.
        #[prost(message, tag = "13")]
        CampaignCriterionOperation(super::CampaignCriterionOperation),
        /// A campaign customizer mutate operation.
        #[prost(message, tag = "76")]
        CampaignCustomizerOperation(super::CampaignCustomizerOperation),
        /// A campaign draft mutate operation.
        #[prost(message, tag = "24")]
        CampaignDraftOperation(super::CampaignDraftOperation),
        /// A campaign extension setting mutate operation.
        #[prost(message, tag = "26")]
        CampaignExtensionSettingOperation(super::CampaignExtensionSettingOperation),
        /// A campaign feed mutate operation.
        #[prost(message, tag = "27")]
        CampaignFeedOperation(super::CampaignFeedOperation),
        /// A campaign group mutate operation.
        #[prost(message, tag = "9")]
        CampaignGroupOperation(super::CampaignGroupOperation),
        /// A campaign label mutate operation.
        #[prost(message, tag = "28")]
        CampaignLabelOperation(super::CampaignLabelOperation),
        /// A campaign mutate operation.
        #[prost(message, tag = "10")]
        CampaignOperation(super::CampaignOperation),
        /// A campaign shared set mutate operation.
        #[prost(message, tag = "11")]
        CampaignSharedSetOperation(super::CampaignSharedSetOperation),
        /// A conversion action mutate operation.
        #[prost(message, tag = "12")]
        ConversionActionOperation(super::ConversionActionOperation),
        /// A conversion custom variable mutate operation.
        #[prost(message, tag = "55")]
        ConversionCustomVariableOperation(super::ConversionCustomVariableOperation),
        /// A conversion goal campaign config mutate operation.
        #[prost(message, tag = "69")]
        ConversionGoalCampaignConfigOperation(
            super::ConversionGoalCampaignConfigOperation,
        ),
        /// A conversion value rule mutate operation.
        #[prost(message, tag = "63")]
        ConversionValueRuleOperation(super::ConversionValueRuleOperation),
        /// A conversion value rule set mutate operation.
        #[prost(message, tag = "64")]
        ConversionValueRuleSetOperation(super::ConversionValueRuleSetOperation),
        /// A custom conversion goal mutate operation.
        #[prost(message, tag = "68")]
        CustomConversionGoalOperation(super::CustomConversionGoalOperation),
        /// A customer asset mutate operation.
        #[prost(message, tag = "57")]
        CustomerAssetOperation(super::CustomerAssetOperation),
        /// A customer conversion goal mutate operation.
        #[prost(message, tag = "66")]
        CustomerConversionGoalOperation(super::CustomerConversionGoalOperation),
        /// A customer customizer mutate operation.
        #[prost(message, tag = "79")]
        CustomerCustomizerOperation(super::CustomerCustomizerOperation),
        /// A customer extension setting mutate operation.
        #[prost(message, tag = "30")]
        CustomerExtensionSettingOperation(super::CustomerExtensionSettingOperation),
        /// A customer feed mutate operation.
        #[prost(message, tag = "31")]
        CustomerFeedOperation(super::CustomerFeedOperation),
        /// A customer label mutate operation.
        #[prost(message, tag = "32")]
        CustomerLabelOperation(super::CustomerLabelOperation),
        /// A customer negative criterion mutate operation.
        #[prost(message, tag = "34")]
        CustomerNegativeCriterionOperation(super::CustomerNegativeCriterionOperation),
        /// A customer mutate operation.
        #[prost(message, tag = "35")]
        CustomerOperation(super::CustomerOperation),
        /// A customizer attribute mutate operation.
        #[prost(message, tag = "70")]
        CustomizerAttributeOperation(super::CustomizerAttributeOperation),
        /// An experiment mutate operation.
        #[prost(message, tag = "82")]
        ExperimentOperation(super::ExperimentOperation),
        /// An experiment arm mutate operation.
        #[prost(message, tag = "83")]
        ExperimentArmOperation(super::ExperimentArmOperation),
        /// An extension feed item mutate operation.
        #[prost(message, tag = "36")]
        ExtensionFeedItemOperation(super::ExtensionFeedItemOperation),
        /// A feed item mutate operation.
        #[prost(message, tag = "37")]
        FeedItemOperation(super::FeedItemOperation),
        /// A feed item set mutate operation.
        #[prost(message, tag = "53")]
        FeedItemSetOperation(super::FeedItemSetOperation),
        /// A feed item set link mutate operation.
        #[prost(message, tag = "54")]
        FeedItemSetLinkOperation(super::FeedItemSetLinkOperation),
        /// A feed item target mutate operation.
        #[prost(message, tag = "38")]
        FeedItemTargetOperation(super::FeedItemTargetOperation),
        /// A feed mapping mutate operation.
        #[prost(message, tag = "39")]
        FeedMappingOperation(super::FeedMappingOperation),
        /// A feed mutate operation.
        #[prost(message, tag = "40")]
        FeedOperation(super::FeedOperation),
        /// A keyword plan ad group operation.
        #[prost(message, tag = "44")]
        KeywordPlanAdGroupOperation(super::KeywordPlanAdGroupOperation),
        /// A keyword plan ad group keyword operation.
        #[prost(message, tag = "50")]
        KeywordPlanAdGroupKeywordOperation(super::KeywordPlanAdGroupKeywordOperation),
        /// A keyword plan campaign keyword operation.
        #[prost(message, tag = "51")]
        KeywordPlanCampaignKeywordOperation(super::KeywordPlanCampaignKeywordOperation),
        /// A keyword plan campaign operation.
        #[prost(message, tag = "45")]
        KeywordPlanCampaignOperation(super::KeywordPlanCampaignOperation),
        /// A keyword plan operation.
        #[prost(message, tag = "48")]
        KeywordPlanOperation(super::KeywordPlanOperation),
        /// A label mutate operation.
        #[prost(message, tag = "41")]
        LabelOperation(super::LabelOperation),
        /// A recommendation subscription mutate operation.
        #[prost(message, tag = "86")]
        RecommendationSubscriptionOperation(super::RecommendationSubscriptionOperation),
        /// A remarketing action mutate operation.
        #[prost(message, tag = "43")]
        RemarketingActionOperation(super::RemarketingActionOperation),
        /// A shared criterion mutate operation.
        #[prost(message, tag = "14")]
        SharedCriterionOperation(super::SharedCriterionOperation),
        /// A shared set mutate operation.
        #[prost(message, tag = "15")]
        SharedSetOperation(super::SharedSetOperation),
        /// A Smart campaign setting mutate operation.
        #[prost(message, tag = "61")]
        SmartCampaignSettingOperation(super::SmartCampaignSettingOperation),
        /// A user list mutate operation.
        #[prost(message, tag = "16")]
        UserListOperation(super::UserListOperation),
    }
}
/// Response message for the resource mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateOperationResponse {
    /// The mutate response.
    #[prost(
        oneof = "mutate_operation_response::Response",
        tags = "17, 1, 56, 2, 77, 18, 3, 75, 19, 20, 21, 5, 22, 49, 23, 65, 78, 79, 62, 71, 72, 80, 58, 59, 6, 52, 73, 7, 8, 67, 13, 76, 24, 26, 27, 9, 28, 10, 11, 12, 55, 69, 63, 64, 68, 57, 66, 74, 30, 31, 32, 34, 35, 70, 81, 82, 36, 37, 53, 54, 38, 39, 40, 44, 45, 50, 51, 48, 41, 85, 43, 14, 15, 61, 16"
    )]
    pub response: ::core::option::Option<mutate_operation_response::Response>,
}
/// Nested message and enum types in `MutateOperationResponse`.
pub mod mutate_operation_response {
    /// The mutate response.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Response {
        /// The result for the ad group ad label mutate.
        #[prost(message, tag = "17")]
        AdGroupAdLabelResult(super::MutateAdGroupAdLabelResult),
        /// The result for the ad group ad mutate.
        #[prost(message, tag = "1")]
        AdGroupAdResult(super::MutateAdGroupAdResult),
        /// The result for the ad group asset mutate.
        #[prost(message, tag = "56")]
        AdGroupAssetResult(super::MutateAdGroupAssetResult),
        /// The result for the ad group bid modifier mutate.
        #[prost(message, tag = "2")]
        AdGroupBidModifierResult(super::MutateAdGroupBidModifierResult),
        /// The result for the ad group criterion customizer mutate.
        #[prost(message, tag = "77")]
        AdGroupCriterionCustomizerResult(super::MutateAdGroupCriterionCustomizerResult),
        /// The result for the ad group criterion label mutate.
        #[prost(message, tag = "18")]
        AdGroupCriterionLabelResult(super::MutateAdGroupCriterionLabelResult),
        /// The result for the ad group criterion mutate.
        #[prost(message, tag = "3")]
        AdGroupCriterionResult(super::MutateAdGroupCriterionResult),
        /// The result for the ad group customizer mutate.
        #[prost(message, tag = "75")]
        AdGroupCustomizerResult(super::MutateAdGroupCustomizerResult),
        /// The result for the ad group extension setting mutate.
        #[prost(message, tag = "19")]
        AdGroupExtensionSettingResult(super::MutateAdGroupExtensionSettingResult),
        /// The result for the ad group feed mutate.
        #[prost(message, tag = "20")]
        AdGroupFeedResult(super::MutateAdGroupFeedResult),
        /// The result for the ad group label mutate.
        #[prost(message, tag = "21")]
        AdGroupLabelResult(super::MutateAdGroupLabelResult),
        /// The result for the ad group mutate.
        #[prost(message, tag = "5")]
        AdGroupResult(super::MutateAdGroupResult),
        /// The result for the ad parameter mutate.
        #[prost(message, tag = "22")]
        AdParameterResult(super::MutateAdParameterResult),
        /// The result for the ad mutate.
        #[prost(message, tag = "49")]
        AdResult(super::MutateAdResult),
        /// The result for the asset mutate.
        #[prost(message, tag = "23")]
        AssetResult(super::MutateAssetResult),
        /// The result for the asset group asset mutate.
        #[prost(message, tag = "65")]
        AssetGroupAssetResult(super::MutateAssetGroupAssetResult),
        /// The result for the asset group listing group filter mutate.
        #[prost(message, tag = "78")]
        AssetGroupListingGroupFilterResult(
            super::MutateAssetGroupListingGroupFilterResult,
        ),
        /// The result for the asset group signal mutate.
        #[prost(message, tag = "79")]
        AssetGroupSignalResult(super::MutateAssetGroupSignalResult),
        /// The result for the asset group mutate.
        #[prost(message, tag = "62")]
        AssetGroupResult(super::MutateAssetGroupResult),
        /// The result for the asset set asset mutate.
        #[prost(message, tag = "71")]
        AssetSetAssetResult(super::MutateAssetSetAssetResult),
        /// The result for the asset set mutate.
        #[prost(message, tag = "72")]
        AssetSetResult(super::MutateAssetSetResult),
        /// The result for the audience mutate.
        #[prost(message, tag = "80")]
        AudienceResult(super::MutateAudienceResult),
        /// The result for the bidding data exclusion mutate.
        #[prost(message, tag = "58")]
        BiddingDataExclusionResult(super::MutateBiddingDataExclusionsResult),
        /// The result for the bidding seasonality adjustment mutate.
        #[prost(message, tag = "59")]
        BiddingSeasonalityAdjustmentResult(
            super::MutateBiddingSeasonalityAdjustmentsResult,
        ),
        /// The result for the bidding strategy mutate.
        #[prost(message, tag = "6")]
        BiddingStrategyResult(super::MutateBiddingStrategyResult),
        /// The result for the campaign asset mutate.
        #[prost(message, tag = "52")]
        CampaignAssetResult(super::MutateCampaignAssetResult),
        /// The result for the campaign asset set mutate.
        #[prost(message, tag = "73")]
        CampaignAssetSetResult(super::MutateCampaignAssetSetResult),
        /// The result for the campaign bid modifier mutate.
        #[prost(message, tag = "7")]
        CampaignBidModifierResult(super::MutateCampaignBidModifierResult),
        /// The result for the campaign budget mutate.
        #[prost(message, tag = "8")]
        CampaignBudgetResult(super::MutateCampaignBudgetResult),
        /// The result for the campaign conversion goal mutate.
        #[prost(message, tag = "67")]
        CampaignConversionGoalResult(super::MutateCampaignConversionGoalResult),
        /// The result for the campaign criterion mutate.
        #[prost(message, tag = "13")]
        CampaignCriterionResult(super::MutateCampaignCriterionResult),
        /// The result for the campaign customizer mutate.
        #[prost(message, tag = "76")]
        CampaignCustomizerResult(super::MutateCampaignCustomizerResult),
        /// The result for the campaign draft mutate.
        #[prost(message, tag = "24")]
        CampaignDraftResult(super::MutateCampaignDraftResult),
        /// The result for the campaign extension setting mutate.
        #[prost(message, tag = "26")]
        CampaignExtensionSettingResult(super::MutateCampaignExtensionSettingResult),
        /// The result for the campaign feed mutate.
        #[prost(message, tag = "27")]
        CampaignFeedResult(super::MutateCampaignFeedResult),
        /// The result for the campaign group mutate.
        #[prost(message, tag = "9")]
        CampaignGroupResult(super::MutateCampaignGroupResult),
        /// The result for the campaign label mutate.
        #[prost(message, tag = "28")]
        CampaignLabelResult(super::MutateCampaignLabelResult),
        /// The result for the campaign mutate.
        #[prost(message, tag = "10")]
        CampaignResult(super::MutateCampaignResult),
        /// The result for the campaign shared set mutate.
        #[prost(message, tag = "11")]
        CampaignSharedSetResult(super::MutateCampaignSharedSetResult),
        /// The result for the conversion action mutate.
        #[prost(message, tag = "12")]
        ConversionActionResult(super::MutateConversionActionResult),
        /// The result for the conversion custom variable mutate.
        #[prost(message, tag = "55")]
        ConversionCustomVariableResult(super::MutateConversionCustomVariableResult),
        /// The result for the conversion goal campaign config mutate.
        #[prost(message, tag = "69")]
        ConversionGoalCampaignConfigResult(
            super::MutateConversionGoalCampaignConfigResult,
        ),
        /// The result for the conversion value rule mutate.
        #[prost(message, tag = "63")]
        ConversionValueRuleResult(super::MutateConversionValueRuleResult),
        /// The result for the conversion value rule set mutate.
        #[prost(message, tag = "64")]
        ConversionValueRuleSetResult(super::MutateConversionValueRuleSetResult),
        /// The result for the custom conversion goal mutate.
        #[prost(message, tag = "68")]
        CustomConversionGoalResult(super::MutateCustomConversionGoalResult),
        /// The result for the customer asset mutate.
        #[prost(message, tag = "57")]
        CustomerAssetResult(super::MutateCustomerAssetResult),
        /// The result for the customer conversion goal mutate.
        #[prost(message, tag = "66")]
        CustomerConversionGoalResult(super::MutateCustomerConversionGoalResult),
        /// The result for the customer customizer mutate.
        #[prost(message, tag = "74")]
        CustomerCustomizerResult(super::MutateCustomerCustomizerResult),
        /// The result for the customer extension setting mutate.
        #[prost(message, tag = "30")]
        CustomerExtensionSettingResult(super::MutateCustomerExtensionSettingResult),
        /// The result for the customer feed mutate.
        #[prost(message, tag = "31")]
        CustomerFeedResult(super::MutateCustomerFeedResult),
        /// The result for the customer label mutate.
        #[prost(message, tag = "32")]
        CustomerLabelResult(super::MutateCustomerLabelResult),
        /// The result for the customer negative criterion mutate.
        #[prost(message, tag = "34")]
        CustomerNegativeCriterionResult(super::MutateCustomerNegativeCriteriaResult),
        /// The result for the customer mutate.
        #[prost(message, tag = "35")]
        CustomerResult(super::MutateCustomerResult),
        /// The result for the customizer attribute mutate.
        #[prost(message, tag = "70")]
        CustomizerAttributeResult(super::MutateCustomizerAttributeResult),
        /// The result for the experiment mutate.
        #[prost(message, tag = "81")]
        ExperimentResult(super::MutateExperimentResult),
        /// The result for the experiment arm mutate.
        #[prost(message, tag = "82")]
        ExperimentArmResult(super::MutateExperimentArmResult),
        /// The result for the extension feed item mutate.
        #[prost(message, tag = "36")]
        ExtensionFeedItemResult(super::MutateExtensionFeedItemResult),
        /// The result for the feed item mutate.
        #[prost(message, tag = "37")]
        FeedItemResult(super::MutateFeedItemResult),
        /// The result for the feed item set mutate.
        #[prost(message, tag = "53")]
        FeedItemSetResult(super::MutateFeedItemSetResult),
        /// The result for the feed item set link mutate.
        #[prost(message, tag = "54")]
        FeedItemSetLinkResult(super::MutateFeedItemSetLinkResult),
        /// The result for the feed item target mutate.
        #[prost(message, tag = "38")]
        FeedItemTargetResult(super::MutateFeedItemTargetResult),
        /// The result for the feed mapping mutate.
        #[prost(message, tag = "39")]
        FeedMappingResult(super::MutateFeedMappingResult),
        /// The result for the feed mutate.
        #[prost(message, tag = "40")]
        FeedResult(super::MutateFeedResult),
        /// The result for the keyword plan ad group mutate.
        #[prost(message, tag = "44")]
        KeywordPlanAdGroupResult(super::MutateKeywordPlanAdGroupResult),
        /// The result for the keyword plan campaign mutate.
        #[prost(message, tag = "45")]
        KeywordPlanCampaignResult(super::MutateKeywordPlanCampaignResult),
        /// The result for the keyword plan ad group keyword mutate.
        #[prost(message, tag = "50")]
        KeywordPlanAdGroupKeywordResult(super::MutateKeywordPlanAdGroupKeywordResult),
        /// The result for the keyword plan campaign keyword mutate.
        #[prost(message, tag = "51")]
        KeywordPlanCampaignKeywordResult(super::MutateKeywordPlanCampaignKeywordResult),
        /// The result for the keyword plan mutate.
        #[prost(message, tag = "48")]
        KeywordPlanResult(super::MutateKeywordPlansResult),
        /// The result for the label mutate.
        #[prost(message, tag = "41")]
        LabelResult(super::MutateLabelResult),
        /// The result for the recommendation subscription mutate.
        #[prost(message, tag = "85")]
        RecommendationSubscriptionResult(super::MutateRecommendationSubscriptionResult),
        /// The result for the remarketing action mutate.
        #[prost(message, tag = "43")]
        RemarketingActionResult(super::MutateRemarketingActionResult),
        /// The result for the shared criterion mutate.
        #[prost(message, tag = "14")]
        SharedCriterionResult(super::MutateSharedCriterionResult),
        /// The result for the shared set mutate.
        #[prost(message, tag = "15")]
        SharedSetResult(super::MutateSharedSetResult),
        /// The result for the Smart campaign setting mutate.
        #[prost(message, tag = "61")]
        SmartCampaignSettingResult(super::MutateSmartCampaignSettingResult),
        /// The result for the user list mutate.
        #[prost(message, tag = "16")]
        UserListResult(super::MutateUserListResult),
    }
}
/// Generated server implementations.
pub mod google_ads_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with GoogleAdsServiceServer.
    #[async_trait]
    pub trait GoogleAdsService: std::marker::Send + std::marker::Sync + 'static {
        /// Returns all rows that match the search query.
        ///
        /// List of thrown errors:
        ///   [AuthenticationError]()
        ///   [AuthorizationError]()
        ///   [ChangeEventError]()
        ///   [ChangeStatusError]()
        ///   [ClickViewError]()
        ///   [HeaderError]()
        ///   [InternalError]()
        ///   [QueryError]()
        ///   [QuotaError]()
        ///   [RequestError]()
        async fn search(
            &self,
            request: tonic::Request<super::SearchGoogleAdsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SearchGoogleAdsResponse>,
            tonic::Status,
        >;
        /// Server streaming response type for the SearchStream method.
        type SearchStreamStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<
                    super::SearchGoogleAdsStreamResponse,
                    tonic::Status,
                >,
            >
            + std::marker::Send
            + 'static;
        /// Returns all rows that match the search stream query.
        ///
        /// List of thrown errors:
        ///   [AuthenticationError]()
        ///   [AuthorizationError]()
        ///   [ChangeEventError]()
        ///   [ChangeStatusError]()
        ///   [ClickViewError]()
        ///   [HeaderError]()
        ///   [InternalError]()
        ///   [QueryError]()
        ///   [QuotaError]()
        ///   [RequestError]()
        async fn search_stream(
            &self,
            request: tonic::Request<super::SearchGoogleAdsStreamRequest>,
        ) -> std::result::Result<
            tonic::Response<Self::SearchStreamStream>,
            tonic::Status,
        >;
        /// Creates, updates, or removes resources. This method supports atomic
        /// transactions with multiple types of resources. For example, you can
        /// atomically create a campaign and a campaign budget, or perform up to
        /// thousands of mutates atomically.
        ///
        /// This method is essentially a wrapper around a series of mutate methods. The
        /// only features it offers over calling those methods directly are:
        ///
        /// - Atomic transactions
        /// - Temp resource names (described below)
        /// - Somewhat reduced latency over making a series of mutate calls
        ///
        /// Note: Only resources that support atomic transactions are included, so this
        /// method can't replace all calls to individual services.
        ///
        /// ## Atomic Transaction Benefits
        ///
        /// Atomicity makes error handling much easier. If you're making a series of
        /// changes and one fails, it can leave your account in an inconsistent state.
        /// With atomicity, you either reach the chosen state directly, or the request
        /// fails and you can retry.
        ///
        /// ## Temp Resource Names
        ///
        /// Temp resource names are a special type of resource name used to create a
        /// resource and reference that resource in the same request. For example, if a
        /// campaign budget is created with `resource_name` equal to
        /// `customers/123/campaignBudgets/-1`, that resource name can be reused in
        /// the `Campaign.budget` field in the same request. That way, the two
        /// resources are created and linked atomically.
        ///
        /// To create a temp resource name, put a negative number in the part of the
        /// name that the server would normally allocate.
        ///
        /// Note:
        ///
        /// - Resources must be created with a temp name before the name can be reused.
        ///   For example, the previous CampaignBudget+Campaign example would fail if
        ///   the mutate order was reversed.
        /// - Temp names are not remembered across requests.
        /// - There's no limit to the number of temp names in a request.
        /// - Each temp name must use a unique negative number, even if the resource
        ///   types differ.
        ///
        /// ## Latency
        ///
        /// It's important to group mutates by resource type or the request may time
        /// out and fail. Latency is roughly equal to a series of calls to individual
        /// mutate methods, where each change in resource type is a new call. For
        /// example, mutating 10 campaigns then 10 ad groups is like 2 calls, while
        /// mutating 1 campaign, 1 ad group, 1 campaign, 1 ad group is like 4 calls.
        ///
        /// List of thrown errors:
        ///   [AdCustomizerError]()
        ///   [AdError]()
        ///   [AdGroupAdError]()
        ///   [AdGroupCriterionError]()
        ///   [AdGroupError]()
        ///   [AssetError]()
        ///   [AuthenticationError]()
        ///   [AuthorizationError]()
        ///   [BiddingError]()
        ///   [CampaignBudgetError]()
        ///   [CampaignCriterionError]()
        ///   [CampaignError]()
        ///   [CampaignExperimentError]()
        ///   [CampaignSharedSetError]()
        ///   [CollectionSizeError]()
        ///   [ContextError]()
        ///   [ConversionActionError]()
        ///   [CriterionError]()
        ///   [CustomerFeedError]()
        ///   [DatabaseError]()
        ///   [DateError]()
        ///   [DateRangeError]()
        ///   [DistinctError]()
        ///   [ExtensionFeedItemError]()
        ///   [ExtensionSettingError]()
        ///   [FeedAttributeReferenceError]()
        ///   [FeedError]()
        ///   [FeedItemError]()
        ///   [FeedItemSetError]()
        ///   [FieldError]()
        ///   [FieldMaskError]()
        ///   [FunctionParsingError]()
        ///   [HeaderError]()
        ///   [ImageError]()
        ///   [InternalError]()
        ///   [KeywordPlanAdGroupKeywordError]()
        ///   [KeywordPlanCampaignError]()
        ///   [KeywordPlanError]()
        ///   [LabelError]()
        ///   [ListOperationError]()
        ///   [MediaUploadError]()
        ///   [MutateError]()
        ///   [NewResourceCreationError]()
        ///   [NullError]()
        ///   [OperationAccessDeniedError]()
        ///   [PolicyFindingError]()
        ///   [PolicyViolationError]()
        ///   [QuotaError]()
        ///   [RangeError]()
        ///   [RequestError]()
        ///   [ResourceCountLimitExceededError]()
        ///   [SettingError]()
        ///   [SharedSetError]()
        ///   [SizeLimitError]()
        ///   [StringFormatError]()
        ///   [StringLengthError]()
        ///   [UrlFieldError]()
        ///   [UserListError]()
        ///   [YoutubeVideoRegistrationError]()
        async fn mutate(
            &self,
            request: tonic::Request<super::MutateGoogleAdsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MutateGoogleAdsResponse>,
            tonic::Status,
        >;
    }
    /// Service to fetch data and metrics across resources.
    #[derive(Debug)]
    pub struct GoogleAdsServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> GoogleAdsServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for GoogleAdsServiceServer<T>
    where
        T: GoogleAdsService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/google.ads.googleads.v16.services.GoogleAdsService/Search" => {
                    #[allow(non_camel_case_types)]
                    struct SearchSvc<T: GoogleAdsService>(pub Arc<T>);
                    impl<
                        T: GoogleAdsService,
                    > tonic::server::UnaryService<super::SearchGoogleAdsRequest>
                    for SearchSvc<T> {
                        type Response = super::SearchGoogleAdsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::SearchGoogleAdsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as GoogleAdsService>::search(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SearchSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.ads.googleads.v16.services.GoogleAdsService/SearchStream" => {
                    #[allow(non_camel_case_types)]
                    struct SearchStreamSvc<T: GoogleAdsService>(pub Arc<T>);
                    impl<
                        T: GoogleAdsService,
                    > tonic::server::ServerStreamingService<
                        super::SearchGoogleAdsStreamRequest,
                    > for SearchStreamSvc<T> {
                        type Response = super::SearchGoogleAdsStreamResponse;
                        type ResponseStream = T::SearchStreamStream;
                        type Future = BoxFuture<
                            tonic::Response<Self::ResponseStream>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::SearchGoogleAdsStreamRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as GoogleAdsService>::search_stream(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SearchStreamSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.server_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.ads.googleads.v16.services.GoogleAdsService/Mutate" => {
                    #[allow(non_camel_case_types)]
                    struct MutateSvc<T: GoogleAdsService>(pub Arc<T>);
                    impl<
                        T: GoogleAdsService,
                    > tonic::server::UnaryService<super::MutateGoogleAdsRequest>
                    for MutateSvc<T> {
                        type Response = super::MutateGoogleAdsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::MutateGoogleAdsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as GoogleAdsService>::mutate(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = MutateSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for GoogleAdsServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "google.ads.googleads.v16.services.GoogleAdsService";
    impl<T> tonic::server::NamedService for GoogleAdsServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Request message for
/// [BatchJobService.MutateBatchJob][google.ads.googleads.v16.services.BatchJobService.MutateBatchJob].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateBatchJobRequest {
    /// Required. The ID of the customer for which to create a batch job.
    #[prost(string, tag = "1")]
    pub customer_id: ::prost::alloc::string::String,
    /// Required. The operation to perform on an individual batch job.
    #[prost(message, optional, tag = "2")]
    pub operation: ::core::option::Option<BatchJobOperation>,
}
/// A single operation on a batch job.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchJobOperation {
    /// The mutate operation.
    #[prost(oneof = "batch_job_operation::Operation", tags = "1, 4")]
    pub operation: ::core::option::Option<batch_job_operation::Operation>,
}
/// Nested message and enum types in `BatchJobOperation`.
pub mod batch_job_operation {
    /// The mutate operation.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Operation {
        /// Create operation: No resource name is expected for the new batch job.
        #[prost(message, tag = "1")]
        Create(super::super::resources::BatchJob),
        /// Remove operation: The batch job must not have been run. A resource name
        /// for the removed batch job is expected, in this format:
        ///
        /// `customers/{customer_id}/batchJobs/{batch_job_id}`
        #[prost(string, tag = "4")]
        Remove(::prost::alloc::string::String),
    }
}
/// Response message for
/// [BatchJobService.MutateBatchJob][google.ads.googleads.v16.services.BatchJobService.MutateBatchJob].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateBatchJobResponse {
    /// The result for the mutate.
    #[prost(message, optional, tag = "1")]
    pub result: ::core::option::Option<MutateBatchJobResult>,
}
/// The result for the batch job mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateBatchJobResult {
    /// The resource name of the batch job.
    #[prost(string, tag = "1")]
    pub resource_name: ::prost::alloc::string::String,
}
/// Request message for
/// [BatchJobService.RunBatchJob][google.ads.googleads.v16.services.BatchJobService.RunBatchJob].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RunBatchJobRequest {
    /// Required. The resource name of the BatchJob to run.
    #[prost(string, tag = "1")]
    pub resource_name: ::prost::alloc::string::String,
}
/// Request message for
/// [BatchJobService.AddBatchJobOperations][google.ads.googleads.v16.services.BatchJobService.AddBatchJobOperations].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AddBatchJobOperationsRequest {
    /// Required. The resource name of the batch job.
    #[prost(string, tag = "1")]
    pub resource_name: ::prost::alloc::string::String,
    /// A token used to enforce sequencing.
    ///
    /// The first AddBatchJobOperations request for a batch job should not set
    /// sequence_token. Subsequent requests must set sequence_token to the value of
    /// next_sequence_token received in the previous AddBatchJobOperations
    /// response.
    #[prost(string, tag = "2")]
    pub sequence_token: ::prost::alloc::string::String,
    /// Required. The list of mutates being added.
    ///
    /// Operations can use negative integers as temp ids to signify dependencies
    /// between entities created in this batch job. For example, a customer with
    /// id = 1234 can create a campaign and an ad group in that same campaign by
    /// creating a campaign in the first operation with the resource name
    /// explicitly set to "customers/1234/campaigns/-1", and creating an ad group
    /// in the second operation with the campaign field also set to
    /// "customers/1234/campaigns/-1".
    #[prost(message, repeated, tag = "3")]
    pub mutate_operations: ::prost::alloc::vec::Vec<MutateOperation>,
}
/// Response message for
/// [BatchJobService.AddBatchJobOperations][google.ads.googleads.v16.services.BatchJobService.AddBatchJobOperations].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AddBatchJobOperationsResponse {
    /// The total number of operations added so far for this batch job.
    #[prost(int64, tag = "1")]
    pub total_operations: i64,
    /// The sequence token to be used when calling AddBatchJobOperations again if
    /// more operations need to be added. The next AddBatchJobOperations request
    /// must set the sequence_token field to the value of this field.
    #[prost(string, tag = "2")]
    pub next_sequence_token: ::prost::alloc::string::String,
}
/// Request message for
/// [BatchJobService.ListBatchJobResults][google.ads.googleads.v16.services.BatchJobService.ListBatchJobResults].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListBatchJobResultsRequest {
    /// Required. The resource name of the batch job whose results are being
    /// listed.
    #[prost(string, tag = "1")]
    pub resource_name: ::prost::alloc::string::String,
    /// Token of the page to retrieve. If not specified, the first
    /// page of results will be returned. Use the value obtained from
    /// `next_page_token` in the previous response in order to request
    /// the next page of results.
    #[prost(string, tag = "2")]
    pub page_token: ::prost::alloc::string::String,
    /// Number of elements to retrieve in a single page.
    /// When a page request is too large, the server may decide to
    /// further limit the number of returned resources.
    #[prost(int32, tag = "3")]
    pub page_size: i32,
    /// The response content type setting. Determines whether the mutable resource
    /// or just the resource name should be returned.
    #[prost(
        enumeration = "super::enums::response_content_type_enum::ResponseContentType",
        tag = "4"
    )]
    pub response_content_type: i32,
}
/// Response message for
/// [BatchJobService.ListBatchJobResults][google.ads.googleads.v16.services.BatchJobService.ListBatchJobResults].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListBatchJobResultsResponse {
    /// The list of rows that matched the query.
    #[prost(message, repeated, tag = "1")]
    pub results: ::prost::alloc::vec::Vec<BatchJobResult>,
    /// Pagination token used to retrieve the next page of results.
    /// Pass the content of this string as the `page_token` attribute of
    /// the next request. `next_page_token` is not returned for the last
    /// page.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// An individual batch job result.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchJobResult {
    /// Index of the mutate operation.
    #[prost(int64, tag = "1")]
    pub operation_index: i64,
    /// Response for the mutate.
    /// May be empty if errors occurred.
    #[prost(message, optional, tag = "2")]
    pub mutate_operation_response: ::core::option::Option<MutateOperationResponse>,
    /// Details of the errors when processing the operation.
    #[prost(message, optional, tag = "3")]
    pub status: ::core::option::Option<super::super::super::super::rpc::Status>,
}
/// Generated server implementations.
pub mod batch_job_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with BatchJobServiceServer.
    #[async_trait]
    pub trait BatchJobService: std::marker::Send + std::marker::Sync + 'static {
        /// Mutates a batch job.
        ///
        /// List of thrown errors:
        ///   [AuthenticationError]()
        ///   [AuthorizationError]()
        ///   [HeaderError]()
        ///   [InternalError]()
        ///   [QuotaError]()
        ///   [RequestError]()
        ///   [ResourceCountLimitExceededError]()
        async fn mutate_batch_job(
            &self,
            request: tonic::Request<super::MutateBatchJobRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MutateBatchJobResponse>,
            tonic::Status,
        >;
        /// Returns the results of the batch job. The job must be done.
        /// Supports standard list paging.
        ///
        /// List of thrown errors:
        ///   [AuthenticationError]()
        ///   [AuthorizationError]()
        ///   [BatchJobError]()
        ///   [HeaderError]()
        ///   [InternalError]()
        ///   [QuotaError]()
        ///   [RequestError]()
        async fn list_batch_job_results(
            &self,
            request: tonic::Request<super::ListBatchJobResultsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListBatchJobResultsResponse>,
            tonic::Status,
        >;
        /// Runs the batch job.
        ///
        /// The Operation.metadata field type is BatchJobMetadata. When finished, the
        /// long running operation will not contain errors or a response. Instead, use
        /// ListBatchJobResults to get the results of the job.
        ///
        /// List of thrown errors:
        ///   [AuthenticationError]()
        ///   [AuthorizationError]()
        ///   [BatchJobError]()
        ///   [HeaderError]()
        ///   [InternalError]()
        ///   [QuotaError]()
        ///   [RequestError]()
        async fn run_batch_job(
            &self,
            request: tonic::Request<super::RunBatchJobRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::super::longrunning::Operation>,
            tonic::Status,
        >;
        /// Add operations to the batch job.
        ///
        /// List of thrown errors:
        ///   [AuthenticationError]()
        ///   [AuthorizationError]()
        ///   [BatchJobError]()
        ///   [HeaderError]()
        ///   [InternalError]()
        ///   [QuotaError]()
        ///   [RequestError]()
        ///   [ResourceCountLimitExceededError]()
        async fn add_batch_job_operations(
            &self,
            request: tonic::Request<super::AddBatchJobOperationsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::AddBatchJobOperationsResponse>,
            tonic::Status,
        >;
    }
    /// Service to manage batch jobs.
    #[derive(Debug)]
    pub struct BatchJobServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> BatchJobServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for BatchJobServiceServer<T>
    where
        T: BatchJobService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/google.ads.googleads.v16.services.BatchJobService/MutateBatchJob" => {
                    #[allow(non_camel_case_types)]
                    struct MutateBatchJobSvc<T: BatchJobService>(pub Arc<T>);
                    impl<
                        T: BatchJobService,
                    > tonic::server::UnaryService<super::MutateBatchJobRequest>
                    for MutateBatchJobSvc<T> {
                        type Response = super::MutateBatchJobResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::MutateBatchJobRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as BatchJobService>::mutate_batch_job(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = MutateBatchJobSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.ads.googleads.v16.services.BatchJobService/ListBatchJobResults" => {
                    #[allow(non_camel_case_types)]
                    struct ListBatchJobResultsSvc<T: BatchJobService>(pub Arc<T>);
                    impl<
                        T: BatchJobService,
                    > tonic::server::UnaryService<super::ListBatchJobResultsRequest>
                    for ListBatchJobResultsSvc<T> {
                        type Response = super::ListBatchJobResultsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ListBatchJobResultsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as BatchJobService>::list_batch_job_results(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ListBatchJobResultsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.ads.googleads.v16.services.BatchJobService/RunBatchJob" => {
                    #[allow(non_camel_case_types)]
                    struct RunBatchJobSvc<T: BatchJobService>(pub Arc<T>);
                    impl<
                        T: BatchJobService,
                    > tonic::server::UnaryService<super::RunBatchJobRequest>
                    for RunBatchJobSvc<T> {
                        type Response = super::super::super::super::super::longrunning::Operation;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::RunBatchJobRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as BatchJobService>::run_batch_job(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = RunBatchJobSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.ads.googleads.v16.services.BatchJobService/AddBatchJobOperations" => {
                    #[allow(non_camel_case_types)]
                    struct AddBatchJobOperationsSvc<T: BatchJobService>(pub Arc<T>);
                    impl<
                        T: BatchJobService,
                    > tonic::server::UnaryService<super::AddBatchJobOperationsRequest>
                    for AddBatchJobOperationsSvc<T> {
                        type Response = super::AddBatchJobOperationsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::AddBatchJobOperationsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as BatchJobService>::add_batch_job_operations(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = AddBatchJobOperationsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for BatchJobServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "google.ads.googleads.v16.services.BatchJobService";
    impl<T> tonic::server::NamedService for BatchJobServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Request message for billing setup mutate operations.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateBillingSetupRequest {
    /// Required. Id of the customer to apply the billing setup mutate operation
    /// to.
    #[prost(string, tag = "1")]
    pub customer_id: ::prost::alloc::string::String,
    /// Required. The operation to perform.
    #[prost(message, optional, tag = "2")]
    pub operation: ::core::option::Option<BillingSetupOperation>,
}
/// A single operation on a billing setup, which describes the cancellation of an
/// existing billing setup.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BillingSetupOperation {
    /// Only one of these operations can be set. "Update" operations are not
    /// supported.
    #[prost(oneof = "billing_setup_operation::Operation", tags = "2, 1")]
    pub operation: ::core::option::Option<billing_setup_operation::Operation>,
}
/// Nested message and enum types in `BillingSetupOperation`.
pub mod billing_setup_operation {
    /// Only one of these operations can be set. "Update" operations are not
    /// supported.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Operation {
        /// Creates a billing setup. No resource name is expected for the new billing
        /// setup.
        #[prost(message, tag = "2")]
        Create(super::super::resources::BillingSetup),
        /// Resource name of the billing setup to remove. A setup cannot be
        /// removed unless it is in a pending state or its scheduled start time is in
        /// the future. The resource name looks like
        /// `customers/{customer_id}/billingSetups/{billing_id}`.
        #[prost(string, tag = "1")]
        Remove(::prost::alloc::string::String),
    }
}
/// Response message for a billing setup operation.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateBillingSetupResponse {
    /// A result that identifies the resource affected by the mutate request.
    #[prost(message, optional, tag = "1")]
    pub result: ::core::option::Option<MutateBillingSetupResult>,
}
/// Result for a single billing setup mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateBillingSetupResult {
    /// Returned for successful operations.
    #[prost(string, tag = "1")]
    pub resource_name: ::prost::alloc::string::String,
}
/// Generated server implementations.
pub mod billing_setup_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with BillingSetupServiceServer.
    #[async_trait]
    pub trait BillingSetupService: std::marker::Send + std::marker::Sync + 'static {
        /// Creates a billing setup, or cancels an existing billing setup.
        ///
        /// List of thrown errors:
        ///   [AuthenticationError]()
        ///   [AuthorizationError]()
        ///   [BillingSetupError]()
        ///   [DateError]()
        ///   [FieldError]()
        ///   [HeaderError]()
        ///   [InternalError]()
        ///   [MutateError]()
        ///   [QuotaError]()
        ///   [RequestError]()
        async fn mutate_billing_setup(
            &self,
            request: tonic::Request<super::MutateBillingSetupRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MutateBillingSetupResponse>,
            tonic::Status,
        >;
    }
    /// A service for designating the business entity responsible for accrued costs.
    ///
    /// A billing setup is associated with a payments account.  Billing-related
    /// activity for all billing setups associated with a particular payments account
    /// will appear on a single invoice generated monthly.
    ///
    /// Mutates:
    /// The REMOVE operation cancels a pending billing setup.
    /// The CREATE operation creates a new billing setup.
    #[derive(Debug)]
    pub struct BillingSetupServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> BillingSetupServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for BillingSetupServiceServer<T>
    where
        T: BillingSetupService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/google.ads.googleads.v16.services.BillingSetupService/MutateBillingSetup" => {
                    #[allow(non_camel_case_types)]
                    struct MutateBillingSetupSvc<T: BillingSetupService>(pub Arc<T>);
                    impl<
                        T: BillingSetupService,
                    > tonic::server::UnaryService<super::MutateBillingSetupRequest>
                    for MutateBillingSetupSvc<T> {
                        type Response = super::MutateBillingSetupResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::MutateBillingSetupRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as BillingSetupService>::mutate_billing_setup(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = MutateBillingSetupSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for BillingSetupServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "google.ads.googleads.v16.services.BillingSetupService";
    impl<T> tonic::server::NamedService for BillingSetupServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Request message for
/// [BrandSuggestionService.SuggestBrands][google.ads.googleads.v16.services.BrandSuggestionService.SuggestBrands].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SuggestBrandsRequest {
    /// Required. The ID of the customer onto which to apply the brand suggestion
    /// operation.
    #[prost(string, tag = "1")]
    pub customer_id: ::prost::alloc::string::String,
    /// Required. The prefix of a brand name.
    #[prost(string, optional, tag = "2")]
    pub brand_prefix: ::core::option::Option<::prost::alloc::string::String>,
    /// Optional. Ids of the brands already selected by advertisers. They will be
    /// excluded in response. These are expected to be brand ids not brand names.
    #[prost(string, repeated, tag = "3")]
    pub selected_brands: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Response message for
/// [BrandSuggestionService.SuggestBrands][google.ads.googleads.v16.services.BrandSuggestionService.SuggestBrands].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SuggestBrandsResponse {
    /// Generated brand suggestions of verified brands for the given prefix.
    #[prost(message, repeated, tag = "1")]
    pub brands: ::prost::alloc::vec::Vec<BrandSuggestion>,
}
/// Information of brand suggestion.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BrandSuggestion {
    /// Id for the brand. It would be CKG MID for verified/global scoped brands.
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    /// Name of the brand.
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    /// Urls which uniquely identify the brand.
    #[prost(string, repeated, tag = "3")]
    pub urls: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Current state of the brand.
    #[prost(enumeration = "super::enums::brand_state_enum::BrandState", tag = "4")]
    pub state: i32,
}
/// Generated server implementations.
pub mod brand_suggestion_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with BrandSuggestionServiceServer.
    #[async_trait]
    pub trait BrandSuggestionService: std::marker::Send + std::marker::Sync + 'static {
        /// Rpc to return a list of matching brands based on a prefix for this
        /// customer.
        async fn suggest_brands(
            &self,
            request: tonic::Request<super::SuggestBrandsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SuggestBrandsResponse>,
            tonic::Status,
        >;
    }
    /// This service will suggest brands based on a prefix.
    #[derive(Debug)]
    pub struct BrandSuggestionServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> BrandSuggestionServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>>
    for BrandSuggestionServiceServer<T>
    where
        T: BrandSuggestionService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/google.ads.googleads.v16.services.BrandSuggestionService/SuggestBrands" => {
                    #[allow(non_camel_case_types)]
                    struct SuggestBrandsSvc<T: BrandSuggestionService>(pub Arc<T>);
                    impl<
                        T: BrandSuggestionService,
                    > tonic::server::UnaryService<super::SuggestBrandsRequest>
                    for SuggestBrandsSvc<T> {
                        type Response = super::SuggestBrandsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::SuggestBrandsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as BrandSuggestionService>::suggest_brands(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SuggestBrandsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for BrandSuggestionServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "google.ads.googleads.v16.services.BrandSuggestionService";
    impl<T> tonic::server::NamedService for BrandSuggestionServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Request message for
/// [CampaignLifecycleGoalService.configureCampaignLifecycleGoals][].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConfigureCampaignLifecycleGoalsRequest {
    /// Required. The ID of the customer performing the upload.
    #[prost(string, tag = "1")]
    pub customer_id: ::prost::alloc::string::String,
    /// Required. The operation to perform campaign lifecycle goal update.
    #[prost(message, optional, tag = "2")]
    pub operation: ::core::option::Option<CampaignLifecycleGoalOperation>,
    /// Optional. If true, the request is validated but not executed. Only errors
    /// are returned, not results.
    #[prost(bool, tag = "3")]
    pub validate_only: bool,
}
/// A single operation on a campaign lifecycle goal.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CampaignLifecycleGoalOperation {
    /// Optional. FieldMask that determines which resource fields are modified in
    /// an update.
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// The mutate operation.
    #[prost(oneof = "campaign_lifecycle_goal_operation::Operation", tags = "1, 3")]
    pub operation: ::core::option::Option<campaign_lifecycle_goal_operation::Operation>,
}
/// Nested message and enum types in `CampaignLifecycleGoalOperation`.
pub mod campaign_lifecycle_goal_operation {
    /// The mutate operation.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Operation {
        /// Create operation: Create a new campaign lifecycle goal. The campaign
        /// field should be set for this operation.
        #[prost(message, tag = "1")]
        Create(super::super::resources::CampaignLifecycleGoal),
        /// Update operation: Update an existing campaign lifecycle goal. The
        /// campaign field should not be set for this operation.
        #[prost(message, tag = "3")]
        Update(super::super::resources::CampaignLifecycleGoal),
    }
}
/// Response message for
/// [CampaignLifecycleGoalService.configureCampaignLifecycleGoals][].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConfigureCampaignLifecycleGoalsResponse {
    /// Result for the campaign lifecycle goal configuration.
    #[prost(message, optional, tag = "1")]
    pub result: ::core::option::Option<ConfigureCampaignLifecycleGoalsResult>,
}
/// The result for the campaign lifecycle goal configuration.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConfigureCampaignLifecycleGoalsResult {
    /// Returned for the successful operation.
    #[prost(string, tag = "1")]
    pub resource_name: ::prost::alloc::string::String,
}
/// Generated server implementations.
pub mod campaign_lifecycle_goal_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with CampaignLifecycleGoalServiceServer.
    #[async_trait]
    pub trait CampaignLifecycleGoalService: std::marker::Send + std::marker::Sync + 'static {
        /// Process the given campaign lifecycle configurations.
        ///
        /// List of thrown errors:
        ///   [AuthenticationError]()
        ///   [AuthorizationError]()
        ///   [CampaignLifecycleGoalConfigError]()
        ///   [HeaderError]()
        ///   [InternalError]()
        ///   [QuotaError]()
        ///   [RequestError]()
        async fn configure_campaign_lifecycle_goals(
            &self,
            request: tonic::Request<super::ConfigureCampaignLifecycleGoalsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ConfigureCampaignLifecycleGoalsResponse>,
            tonic::Status,
        >;
    }
    /// Service to configure campaign lifecycle goals.
    #[derive(Debug)]
    pub struct CampaignLifecycleGoalServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> CampaignLifecycleGoalServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>>
    for CampaignLifecycleGoalServiceServer<T>
    where
        T: CampaignLifecycleGoalService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/google.ads.googleads.v16.services.CampaignLifecycleGoalService/ConfigureCampaignLifecycleGoals" => {
                    #[allow(non_camel_case_types)]
                    struct ConfigureCampaignLifecycleGoalsSvc<
                        T: CampaignLifecycleGoalService,
                    >(
                        pub Arc<T>,
                    );
                    impl<
                        T: CampaignLifecycleGoalService,
                    > tonic::server::UnaryService<
                        super::ConfigureCampaignLifecycleGoalsRequest,
                    > for ConfigureCampaignLifecycleGoalsSvc<T> {
                        type Response = super::ConfigureCampaignLifecycleGoalsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::ConfigureCampaignLifecycleGoalsRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as CampaignLifecycleGoalService>::configure_campaign_lifecycle_goals(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ConfigureCampaignLifecycleGoalsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for CampaignLifecycleGoalServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "google.ads.googleads.v16.services.CampaignLifecycleGoalService";
    impl<T> tonic::server::NamedService for CampaignLifecycleGoalServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Request message for
/// [ConversionAdjustmentUploadService.UploadConversionAdjustments][google.ads.googleads.v16.services.ConversionAdjustmentUploadService.UploadConversionAdjustments].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UploadConversionAdjustmentsRequest {
    /// Required. The ID of the customer performing the upload.
    #[prost(string, tag = "1")]
    pub customer_id: ::prost::alloc::string::String,
    /// Required. The conversion adjustments that are being uploaded.
    #[prost(message, repeated, tag = "2")]
    pub conversion_adjustments: ::prost::alloc::vec::Vec<ConversionAdjustment>,
    /// Required. If true, successful operations will be carried out and invalid
    /// operations will return errors. If false, all operations will be carried out
    /// in one transaction if and only if they are all valid. This should always be
    /// set to true.
    /// See
    /// <https://developers.google.com/google-ads/api/docs/best-practices/partial-failures>
    /// for more information about partial failure.
    #[prost(bool, tag = "3")]
    pub partial_failure: bool,
    /// If true, the request is validated but not executed. Only errors are
    /// returned, not results.
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
    /// Optional. Optional input to set job ID. Must be a non-negative number that
    /// is less than 2^31 if provided. If this field is not provided, the API will
    /// generate a job ID in the range \[2^31, (2^63)-1\]. The API will return the
    /// value for this request in the `job_id` field of the
    /// `UploadConversionAdjustmentsResponse`.
    #[prost(int32, optional, tag = "5")]
    pub job_id: ::core::option::Option<i32>,
}
/// Response message for
/// [ConversionAdjustmentUploadService.UploadConversionAdjustments][google.ads.googleads.v16.services.ConversionAdjustmentUploadService.UploadConversionAdjustments].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UploadConversionAdjustmentsResponse {
    /// Errors that pertain to conversion adjustment failures in the partial
    /// failure mode. Returned when all errors occur inside the adjustments. If any
    /// errors occur outside the adjustments (for example, auth errors), we return
    /// an RPC level error. See
    /// <https://developers.google.com/google-ads/api/docs/best-practices/partial-failures>
    /// for more information about partial failure.
    #[prost(message, optional, tag = "1")]
    pub partial_failure_error: ::core::option::Option<
        super::super::super::super::rpc::Status,
    >,
    /// Returned for successfully processed conversion adjustments. Proto will be
    /// empty for rows that received an error. Results are not returned when
    /// validate_only is true.
    #[prost(message, repeated, tag = "2")]
    pub results: ::prost::alloc::vec::Vec<ConversionAdjustmentResult>,
    /// Job ID for the upload batch.
    #[prost(int64, tag = "3")]
    pub job_id: i64,
}
/// A conversion adjustment.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConversionAdjustment {
    /// For adjustments, uniquely identifies a conversion that was reported
    /// without an order ID specified. If the adjustment_type is ENHANCEMENT, this
    /// value is optional but may be set in addition to the order_id.
    #[prost(message, optional, tag = "12")]
    pub gclid_date_time_pair: ::core::option::Option<GclidDateTimePair>,
    /// The order ID of the conversion to be adjusted. If the conversion was
    /// reported with an order ID specified, that order ID must be used as the
    /// identifier here. The order ID is required for enhancements.
    #[prost(string, optional, tag = "13")]
    pub order_id: ::core::option::Option<::prost::alloc::string::String>,
    /// Resource name of the conversion action associated with this conversion
    /// adjustment. Note: Although this resource name consists of a customer id and
    /// a conversion action id, validation will ignore the customer id and use the
    /// conversion action id as the sole identifier of the conversion action.
    #[prost(string, optional, tag = "8")]
    pub conversion_action: ::core::option::Option<::prost::alloc::string::String>,
    /// The date time at which the adjustment occurred. Must be after the
    /// conversion_date_time. The timezone must be specified. The format is
    /// "yyyy-mm-dd hh:mm:ss+|-hh:mm", for example, "2019-01-01 12:32:45-08:00".
    #[prost(string, optional, tag = "9")]
    pub adjustment_date_time: ::core::option::Option<::prost::alloc::string::String>,
    /// The adjustment type.
    #[prost(
        enumeration = "super::enums::conversion_adjustment_type_enum::ConversionAdjustmentType",
        tag = "5"
    )]
    pub adjustment_type: i32,
    /// Information needed to restate the conversion's value.
    /// Required for restatements. Should not be supplied for retractions. An error
    /// will be returned if provided for a retraction.
    /// NOTE: If you want to upload a second restatement with a different adjusted
    /// value, it must have a new, more recent, adjustment occurrence time.
    /// Otherwise, it will be treated as a duplicate of the previous restatement
    /// and ignored.
    #[prost(message, optional, tag = "6")]
    pub restatement_value: ::core::option::Option<RestatementValue>,
    /// The user identifiers to enhance the original conversion.
    /// ConversionAdjustmentUploadService only accepts user identifiers in
    /// enhancements. The maximum number of user identifiers for each
    /// enhancement is 5.
    #[prost(message, repeated, tag = "10")]
    pub user_identifiers: ::prost::alloc::vec::Vec<super::common::UserIdentifier>,
    /// The user agent to enhance the original conversion. This can be found in
    /// your user's HTTP request header when they convert on your web page.
    /// Example, "Mozilla/5.0 (iPhone; CPU iPhone OS 12_2 like Mac OS X)". User
    /// agent can only be specified in enhancements with user identifiers. This
    /// should match the user agent of the request that sent the original
    /// conversion so the conversion and its enhancement are either both attributed
    /// as same-device or both attributed as cross-device.
    #[prost(string, optional, tag = "11")]
    pub user_agent: ::core::option::Option<::prost::alloc::string::String>,
}
/// Contains information needed to restate a conversion's value.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RestatementValue {
    /// The restated conversion value. This is the value of the conversion after
    /// restatement. For example, to change the value of a conversion from 100 to
    /// 70, an adjusted value of 70 should be reported.
    /// NOTE: If you want to upload a second restatement with a different adjusted
    /// value, it must have a new, more recent, adjustment occurrence time.
    /// Otherwise, it will be treated as a duplicate of the previous restatement
    /// and ignored.
    #[prost(double, optional, tag = "3")]
    pub adjusted_value: ::core::option::Option<f64>,
    /// The currency of the restated value. If not provided, then the default
    /// currency from the conversion action is used, and if that is not set then
    /// the account currency is used. This is the ISO 4217 3-character currency
    /// code for example, USD or EUR.
    #[prost(string, optional, tag = "4")]
    pub currency_code: ::core::option::Option<::prost::alloc::string::String>,
}
/// Uniquely identifies a conversion that was reported without an order ID
/// specified.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GclidDateTimePair {
    /// Google click ID (gclid) associated with the original conversion for this
    /// adjustment.
    #[prost(string, optional, tag = "3")]
    pub gclid: ::core::option::Option<::prost::alloc::string::String>,
    /// The date time at which the original conversion for this adjustment
    /// occurred. The timezone must be specified. The format is "yyyy-mm-dd
    /// hh:mm:ss+|-hh:mm", for example, "2019-01-01 12:32:45-08:00".
    #[prost(string, optional, tag = "4")]
    pub conversion_date_time: ::core::option::Option<::prost::alloc::string::String>,
}
/// Information identifying a successfully processed ConversionAdjustment.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConversionAdjustmentResult {
    /// The gclid and conversion date time of the conversion.
    #[prost(message, optional, tag = "9")]
    pub gclid_date_time_pair: ::core::option::Option<GclidDateTimePair>,
    /// The order ID of the conversion to be adjusted.
    #[prost(string, tag = "10")]
    pub order_id: ::prost::alloc::string::String,
    /// Resource name of the conversion action associated with this conversion
    /// adjustment.
    #[prost(string, optional, tag = "7")]
    pub conversion_action: ::core::option::Option<::prost::alloc::string::String>,
    /// The date time at which the adjustment occurred. The format is
    /// "yyyy-mm-dd hh:mm:ss+|-hh:mm", for example, "2019-01-01 12:32:45-08:00".
    #[prost(string, optional, tag = "8")]
    pub adjustment_date_time: ::core::option::Option<::prost::alloc::string::String>,
    /// The adjustment type.
    #[prost(
        enumeration = "super::enums::conversion_adjustment_type_enum::ConversionAdjustmentType",
        tag = "5"
    )]
    pub adjustment_type: i32,
}
/// Generated server implementations.
pub mod conversion_adjustment_upload_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with ConversionAdjustmentUploadServiceServer.
    #[async_trait]
    pub trait ConversionAdjustmentUploadService: std::marker::Send + std::marker::Sync + 'static {
        /// Processes the given conversion adjustments.
        ///
        /// List of thrown errors:
        ///   [AuthenticationError]()
        ///   [AuthorizationError]()
        ///   [HeaderError]()
        ///   [InternalError]()
        ///   [PartialFailureError]()
        ///   [QuotaError]()
        ///   [RequestError]()
        async fn upload_conversion_adjustments(
            &self,
            request: tonic::Request<super::UploadConversionAdjustmentsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::UploadConversionAdjustmentsResponse>,
            tonic::Status,
        >;
    }
    /// Service to upload conversion adjustments.
    #[derive(Debug)]
    pub struct ConversionAdjustmentUploadServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> ConversionAdjustmentUploadServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>>
    for ConversionAdjustmentUploadServiceServer<T>
    where
        T: ConversionAdjustmentUploadService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/google.ads.googleads.v16.services.ConversionAdjustmentUploadService/UploadConversionAdjustments" => {
                    #[allow(non_camel_case_types)]
                    struct UploadConversionAdjustmentsSvc<
                        T: ConversionAdjustmentUploadService,
                    >(
                        pub Arc<T>,
                    );
                    impl<
                        T: ConversionAdjustmentUploadService,
                    > tonic::server::UnaryService<
                        super::UploadConversionAdjustmentsRequest,
                    > for UploadConversionAdjustmentsSvc<T> {
                        type Response = super::UploadConversionAdjustmentsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::UploadConversionAdjustmentsRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ConversionAdjustmentUploadService>::upload_conversion_adjustments(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = UploadConversionAdjustmentsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for ConversionAdjustmentUploadServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "google.ads.googleads.v16.services.ConversionAdjustmentUploadService";
    impl<T> tonic::server::NamedService for ConversionAdjustmentUploadServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Request message for
/// [ConversionUploadService.UploadClickConversions][google.ads.googleads.v16.services.ConversionUploadService.UploadClickConversions].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UploadClickConversionsRequest {
    /// Required. The ID of the customer performing the upload.
    #[prost(string, tag = "1")]
    pub customer_id: ::prost::alloc::string::String,
    /// Required. The conversions that are being uploaded.
    #[prost(message, repeated, tag = "2")]
    pub conversions: ::prost::alloc::vec::Vec<ClickConversion>,
    /// Required. If true, successful operations will be carried out and invalid
    /// operations will return errors. If false, all operations will be carried
    /// out in one transaction if and only if they are all valid.
    /// This should always be set to true.
    /// See
    /// <https://developers.google.com/google-ads/api/docs/best-practices/partial-failures>
    /// for more information about partial failure.
    #[prost(bool, tag = "3")]
    pub partial_failure: bool,
    /// If true, the request is validated but not executed. Only errors are
    /// returned, not results.
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
    /// If true, the API will perform all upload checks and return errors if
    /// any are found. If false, it will perform only basic input validation,
    /// skip subsequent upload checks, and return success even if no click
    /// was found for the provided `user_identifiers`.
    ///
    /// This setting only affects Enhanced conversions for leads uploads that use
    /// `user_identifiers` instead of `GCLID`, `GBRAID`, or `WBRAID`. When
    /// uploading enhanced conversions for leads, you should upload all conversion
    /// events to the API, including those that may not come from Google Ads
    /// campaigns. The upload of an event that is not from a Google Ads campaign
    /// will result in a `CLICK_NOT_FOUND` error if this field is set to `true`.
    /// Since these errors are expected for such events, set this field to `false`
    /// so you can confirm your uploads are properly formatted but ignore
    /// `CLICK_NOT_FOUND` errors from all of the conversions that are not from a
    /// Google Ads campaign. This will allow you to focus only on errors that you
    /// can address.
    ///
    /// Default is false.
    #[prost(bool, tag = "5")]
    pub debug_enabled: bool,
    /// Optional. Optional input to set job ID. Must be a non-negative number that
    /// is less than 2^31 if provided. If this field is not provided, the API will
    /// generate a job ID in the range \[2^31, (2^63)-1\]. The API will return the
    /// value for this request in the `job_id` field of the
    /// `UploadClickConversionsResponse`.
    #[prost(int32, optional, tag = "6")]
    pub job_id: ::core::option::Option<i32>,
}
/// Response message for
/// [ConversionUploadService.UploadClickConversions][google.ads.googleads.v16.services.ConversionUploadService.UploadClickConversions].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UploadClickConversionsResponse {
    /// Errors that pertain to conversion failures in the partial failure mode.
    /// Returned when all errors occur inside the conversions. If any errors occur
    /// outside the conversions (for example, auth errors), we return an RPC level
    /// error. See
    /// <https://developers.google.com/google-ads/api/docs/best-practices/partial-failures>
    /// for more information about partial failure.
    #[prost(message, optional, tag = "1")]
    pub partial_failure_error: ::core::option::Option<
        super::super::super::super::rpc::Status,
    >,
    /// Returned for successfully processed conversions. Proto will be empty for
    /// rows that received an error. Results are not returned when validate_only is
    /// true.
    #[prost(message, repeated, tag = "2")]
    pub results: ::prost::alloc::vec::Vec<ClickConversionResult>,
    /// Job ID for the upload batch.
    #[prost(int64, tag = "3")]
    pub job_id: i64,
}
/// Request message for
/// [ConversionUploadService.UploadCallConversions][google.ads.googleads.v16.services.ConversionUploadService.UploadCallConversions].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UploadCallConversionsRequest {
    /// Required. The ID of the customer performing the upload.
    #[prost(string, tag = "1")]
    pub customer_id: ::prost::alloc::string::String,
    /// Required. The conversions that are being uploaded.
    #[prost(message, repeated, tag = "2")]
    pub conversions: ::prost::alloc::vec::Vec<CallConversion>,
    /// Required. If true, successful operations will be carried out and invalid
    /// operations will return errors. If false, all operations will be carried
    /// out in one transaction if and only if they are all valid.
    /// This should always be set to true.
    /// See
    /// <https://developers.google.com/google-ads/api/docs/best-practices/partial-failures>
    /// for more information about partial failure.
    #[prost(bool, tag = "3")]
    pub partial_failure: bool,
    /// If true, the request is validated but not executed. Only errors are
    /// returned, not results.
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
}
/// Response message for
/// [ConversionUploadService.UploadCallConversions][google.ads.googleads.v16.services.ConversionUploadService.UploadCallConversions].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UploadCallConversionsResponse {
    /// Errors that pertain to conversion failures in the partial failure mode.
    /// Returned when all errors occur inside the conversions. If any errors occur
    /// outside the conversions (for example, auth errors), we return an RPC level
    /// error. See
    /// <https://developers.google.com/google-ads/api/docs/best-practices/partial-failures>
    /// for more information about partial failure.
    #[prost(message, optional, tag = "1")]
    pub partial_failure_error: ::core::option::Option<
        super::super::super::super::rpc::Status,
    >,
    /// Returned for successfully processed conversions. Proto will be empty for
    /// rows that received an error. Results are not returned when validate_only is
    /// true.
    #[prost(message, repeated, tag = "2")]
    pub results: ::prost::alloc::vec::Vec<CallConversionResult>,
}
/// A click conversion.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClickConversion {
    /// The Google click ID (gclid) associated with this conversion.
    #[prost(string, optional, tag = "9")]
    pub gclid: ::core::option::Option<::prost::alloc::string::String>,
    /// The click identifier for clicks associated with app conversions and
    /// originating from iOS devices starting with iOS14.
    #[prost(string, tag = "18")]
    pub gbraid: ::prost::alloc::string::String,
    /// The click identifier for clicks associated with web conversions and
    /// originating from iOS devices starting with iOS14.
    #[prost(string, tag = "19")]
    pub wbraid: ::prost::alloc::string::String,
    /// Resource name of the conversion action associated with this conversion.
    /// Note: Although this resource name consists of a customer id and a
    /// conversion action id, validation will ignore the customer id and use the
    /// conversion action id as the sole identifier of the conversion action.
    #[prost(string, optional, tag = "10")]
    pub conversion_action: ::core::option::Option<::prost::alloc::string::String>,
    /// The date time at which the conversion occurred. Must be after
    /// the click time. The timezone must be specified. The format is
    /// "yyyy-mm-dd hh:mm:ss+|-hh:mm", for example, "2019-01-01 12:32:45-08:00".
    #[prost(string, optional, tag = "11")]
    pub conversion_date_time: ::core::option::Option<::prost::alloc::string::String>,
    /// The value of the conversion for the advertiser.
    #[prost(double, optional, tag = "12")]
    pub conversion_value: ::core::option::Option<f64>,
    /// Currency associated with the conversion value. This is the ISO 4217
    /// 3-character currency code. For example: USD, EUR.
    #[prost(string, optional, tag = "13")]
    pub currency_code: ::core::option::Option<::prost::alloc::string::String>,
    /// The order ID associated with the conversion. An order id can only be used
    /// for one conversion per conversion action.
    #[prost(string, optional, tag = "14")]
    pub order_id: ::core::option::Option<::prost::alloc::string::String>,
    /// Additional data about externally attributed conversions. This field
    /// is required for conversions with an externally attributed conversion
    /// action, but should not be set otherwise.
    #[prost(message, optional, tag = "7")]
    pub external_attribution_data: ::core::option::Option<ExternalAttributionData>,
    /// The custom variables associated with this conversion.
    #[prost(message, repeated, tag = "15")]
    pub custom_variables: ::prost::alloc::vec::Vec<CustomVariable>,
    /// The cart data associated with this conversion.
    #[prost(message, optional, tag = "16")]
    pub cart_data: ::core::option::Option<CartData>,
    /// The user identifiers associated with this conversion. Only hashed_email and
    /// hashed_phone_number are supported for conversion uploads. The maximum
    /// number of user identifiers for each conversion is 5.
    #[prost(message, repeated, tag = "17")]
    pub user_identifiers: ::prost::alloc::vec::Vec<super::common::UserIdentifier>,
    /// The environment this conversion was recorded on, for example, App or Web.
    #[prost(
        enumeration = "super::enums::conversion_environment_enum::ConversionEnvironment",
        tag = "20"
    )]
    pub conversion_environment: i32,
    /// The consent setting for the event.
    #[prost(message, optional, tag = "23")]
    pub consent: ::core::option::Option<super::common::Consent>,
}
/// A call conversion.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CallConversion {
    /// The caller id from which this call was placed. Caller id is expected to be
    /// in E.164 format with preceding '+' sign, for example, "+16502531234".
    #[prost(string, optional, tag = "7")]
    pub caller_id: ::core::option::Option<::prost::alloc::string::String>,
    /// The date time at which the call occurred. The timezone must be specified.
    /// The format is "yyyy-mm-dd hh:mm:ss+|-hh:mm",
    /// for example, "2019-01-01 12:32:45-08:00".
    #[prost(string, optional, tag = "8")]
    pub call_start_date_time: ::core::option::Option<::prost::alloc::string::String>,
    /// Resource name of the conversion action associated with this conversion.
    /// Note: Although this resource name consists of a customer id and a
    /// conversion action id, validation will ignore the customer id and use the
    /// conversion action id as the sole identifier of the conversion action.
    #[prost(string, optional, tag = "9")]
    pub conversion_action: ::core::option::Option<::prost::alloc::string::String>,
    /// The date time at which the conversion occurred. Must be after the call
    /// time. The timezone must be specified. The format is
    /// "yyyy-mm-dd hh:mm:ss+|-hh:mm", for example, "2019-01-01 12:32:45-08:00".
    #[prost(string, optional, tag = "10")]
    pub conversion_date_time: ::core::option::Option<::prost::alloc::string::String>,
    /// The value of the conversion for the advertiser.
    #[prost(double, optional, tag = "11")]
    pub conversion_value: ::core::option::Option<f64>,
    /// Currency associated with the conversion value. This is the ISO 4217
    /// 3-character currency code. For example: USD, EUR.
    #[prost(string, optional, tag = "12")]
    pub currency_code: ::core::option::Option<::prost::alloc::string::String>,
    /// The custom variables associated with this conversion.
    #[prost(message, repeated, tag = "13")]
    pub custom_variables: ::prost::alloc::vec::Vec<CustomVariable>,
    /// The consent setting for the event.
    #[prost(message, optional, tag = "14")]
    pub consent: ::core::option::Option<super::common::Consent>,
}
/// Contains additional information about externally attributed conversions.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExternalAttributionData {
    /// Represents the fraction of the conversion that is attributed to the
    /// Google Ads click.
    #[prost(double, optional, tag = "3")]
    pub external_attribution_credit: ::core::option::Option<f64>,
    /// Specifies the attribution model name.
    #[prost(string, optional, tag = "4")]
    pub external_attribution_model: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
}
/// Identifying information for a successfully processed ClickConversion.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClickConversionResult {
    /// The Google Click ID (gclid) associated with this conversion.
    #[prost(string, optional, tag = "4")]
    pub gclid: ::core::option::Option<::prost::alloc::string::String>,
    /// The click identifier for clicks associated with app conversions and
    /// originating from iOS devices starting with iOS14.
    #[prost(string, tag = "8")]
    pub gbraid: ::prost::alloc::string::String,
    /// The click identifier for clicks associated with web conversions and
    /// originating from iOS devices starting with iOS14.
    #[prost(string, tag = "9")]
    pub wbraid: ::prost::alloc::string::String,
    /// Resource name of the conversion action associated with this conversion.
    #[prost(string, optional, tag = "5")]
    pub conversion_action: ::core::option::Option<::prost::alloc::string::String>,
    /// The date time at which the conversion occurred. The format is
    /// "yyyy-mm-dd hh:mm:ss+|-hh:mm", for example, "2019-01-01 12:32:45-08:00".
    #[prost(string, optional, tag = "6")]
    pub conversion_date_time: ::core::option::Option<::prost::alloc::string::String>,
    /// The user identifiers associated with this conversion. Only hashed_email and
    /// hashed_phone_number are supported for conversion uploads. The maximum
    /// number of user identifiers for each conversion is 5.
    #[prost(message, repeated, tag = "7")]
    pub user_identifiers: ::prost::alloc::vec::Vec<super::common::UserIdentifier>,
}
/// Identifying information for a successfully processed CallConversionUpload.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CallConversionResult {
    /// The caller id from which this call was placed. Caller id is expected to be
    /// in E.164 format with preceding '+' sign.
    #[prost(string, optional, tag = "5")]
    pub caller_id: ::core::option::Option<::prost::alloc::string::String>,
    /// The date time at which the call occurred. The format is
    /// "yyyy-mm-dd hh:mm:ss+|-hh:mm", for example, "2019-01-01 12:32:45-08:00".
    #[prost(string, optional, tag = "6")]
    pub call_start_date_time: ::core::option::Option<::prost::alloc::string::String>,
    /// Resource name of the conversion action associated with this conversion.
    #[prost(string, optional, tag = "7")]
    pub conversion_action: ::core::option::Option<::prost::alloc::string::String>,
    /// The date time at which the conversion occurred. The format is
    /// "yyyy-mm-dd hh:mm:ss+|-hh:mm", for example, "2019-01-01 12:32:45-08:00".
    #[prost(string, optional, tag = "8")]
    pub conversion_date_time: ::core::option::Option<::prost::alloc::string::String>,
}
/// A custom variable.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CustomVariable {
    /// Resource name of the custom variable associated with this conversion.
    /// Note: Although this resource name consists of a customer id and a
    /// conversion custom variable id, validation will ignore the customer id and
    /// use the conversion custom variable id as the sole identifier of the
    /// conversion custom variable.
    #[prost(string, tag = "1")]
    pub conversion_custom_variable: ::prost::alloc::string::String,
    /// The value string of this custom variable.
    /// The value of the custom variable should not contain private customer data,
    /// such as email addresses or phone numbers.
    #[prost(string, tag = "2")]
    pub value: ::prost::alloc::string::String,
}
/// Contains additional information about cart data.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CartData {
    /// The Merchant Center ID where the items are uploaded.
    #[prost(int64, tag = "6")]
    pub merchant_id: i64,
    /// The country code associated with the feed where the items are uploaded.
    #[prost(string, tag = "2")]
    pub feed_country_code: ::prost::alloc::string::String,
    /// The language code associated with the feed where the items are uploaded.
    #[prost(string, tag = "3")]
    pub feed_language_code: ::prost::alloc::string::String,
    /// Sum of all transaction level discounts, such as free shipping and
    /// coupon discounts for the whole cart. The currency code is the same
    /// as that in the ClickConversion message.
    #[prost(double, tag = "4")]
    pub local_transaction_cost: f64,
    /// Data of the items purchased.
    #[prost(message, repeated, tag = "5")]
    pub items: ::prost::alloc::vec::Vec<cart_data::Item>,
}
/// Nested message and enum types in `CartData`.
pub mod cart_data {
    /// Contains data of the items purchased.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Item {
        /// The shopping id of the item. Must be equal to the Merchant Center product
        /// identifier.
        #[prost(string, tag = "1")]
        pub product_id: ::prost::alloc::string::String,
        /// Number of items sold.
        #[prost(int32, tag = "2")]
        pub quantity: i32,
        /// Unit price excluding tax, shipping, and any transaction
        /// level discounts. The currency code is the same as that in the
        /// ClickConversion message.
        #[prost(double, tag = "3")]
        pub unit_price: f64,
    }
}
/// Generated server implementations.
pub mod conversion_upload_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with ConversionUploadServiceServer.
    #[async_trait]
    pub trait ConversionUploadService: std::marker::Send + std::marker::Sync + 'static {
        /// Processes the given click conversions.
        ///
        /// List of thrown errors:
        ///   [AuthenticationError]()
        ///   [AuthorizationError]()
        ///   [ConversionUploadError]()
        ///   [HeaderError]()
        ///   [InternalError]()
        ///   [PartialFailureError]()
        ///   [QuotaError]()
        ///   [RequestError]()
        async fn upload_click_conversions(
            &self,
            request: tonic::Request<super::UploadClickConversionsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::UploadClickConversionsResponse>,
            tonic::Status,
        >;
        /// Processes the given call conversions.
        ///
        /// List of thrown errors:
        ///   [AuthenticationError]()
        ///   [AuthorizationError]()
        ///   [HeaderError]()
        ///   [InternalError]()
        ///   [PartialFailureError]()
        ///   [QuotaError]()
        ///   [RequestError]()
        async fn upload_call_conversions(
            &self,
            request: tonic::Request<super::UploadCallConversionsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::UploadCallConversionsResponse>,
            tonic::Status,
        >;
    }
    /// Service to upload conversions.
    #[derive(Debug)]
    pub struct ConversionUploadServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> ConversionUploadServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>>
    for ConversionUploadServiceServer<T>
    where
        T: ConversionUploadService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/google.ads.googleads.v16.services.ConversionUploadService/UploadClickConversions" => {
                    #[allow(non_camel_case_types)]
                    struct UploadClickConversionsSvc<T: ConversionUploadService>(
                        pub Arc<T>,
                    );
                    impl<
                        T: ConversionUploadService,
                    > tonic::server::UnaryService<super::UploadClickConversionsRequest>
                    for UploadClickConversionsSvc<T> {
                        type Response = super::UploadClickConversionsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::UploadClickConversionsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ConversionUploadService>::upload_click_conversions(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = UploadClickConversionsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.ads.googleads.v16.services.ConversionUploadService/UploadCallConversions" => {
                    #[allow(non_camel_case_types)]
                    struct UploadCallConversionsSvc<T: ConversionUploadService>(
                        pub Arc<T>,
                    );
                    impl<
                        T: ConversionUploadService,
                    > tonic::server::UnaryService<super::UploadCallConversionsRequest>
                    for UploadCallConversionsSvc<T> {
                        type Response = super::UploadCallConversionsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::UploadCallConversionsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ConversionUploadService>::upload_call_conversions(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = UploadCallConversionsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for ConversionUploadServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "google.ads.googleads.v16.services.ConversionUploadService";
    impl<T> tonic::server::NamedService for ConversionUploadServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Request message for
/// [CustomAudienceService.MutateCustomAudiences][google.ads.googleads.v16.services.CustomAudienceService.MutateCustomAudiences].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCustomAudiencesRequest {
    /// Required. The ID of the customer whose custom audiences are being modified.
    #[prost(string, tag = "1")]
    pub customer_id: ::prost::alloc::string::String,
    /// Required. The list of operations to perform on individual custom audiences.
    #[prost(message, repeated, tag = "2")]
    pub operations: ::prost::alloc::vec::Vec<CustomAudienceOperation>,
    /// If true, the request is validated but not executed. Only errors are
    /// returned, not results.
    #[prost(bool, tag = "3")]
    pub validate_only: bool,
}
/// A single operation (create, update) on a custom audience.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CustomAudienceOperation {
    /// FieldMask that determines which resource fields are modified in an update.
    #[prost(message, optional, tag = "4")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// The mutate operation.
    #[prost(oneof = "custom_audience_operation::Operation", tags = "1, 2, 3")]
    pub operation: ::core::option::Option<custom_audience_operation::Operation>,
}
/// Nested message and enum types in `CustomAudienceOperation`.
pub mod custom_audience_operation {
    /// The mutate operation.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Operation {
        /// Create operation: No resource name is expected for the new custom
        /// audience.
        #[prost(message, tag = "1")]
        Create(super::super::resources::CustomAudience),
        /// Update operation: The custom audience is expected to have a valid
        /// resource name.
        #[prost(message, tag = "2")]
        Update(super::super::resources::CustomAudience),
        /// Remove operation: A resource name for the removed custom audience is
        /// expected, in this format:
        ///
        /// `customers/{customer_id}/customAudiences/{custom_audience_id}`
        #[prost(string, tag = "3")]
        Remove(::prost::alloc::string::String),
    }
}
/// Response message for custom audience mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCustomAudiencesResponse {
    /// All results for the mutate.
    #[prost(message, repeated, tag = "1")]
    pub results: ::prost::alloc::vec::Vec<MutateCustomAudienceResult>,
}
/// The result for the custom audience mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCustomAudienceResult {
    /// Returned for successful operations.
    #[prost(string, tag = "1")]
    pub resource_name: ::prost::alloc::string::String,
}
/// Generated server implementations.
pub mod custom_audience_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with CustomAudienceServiceServer.
    #[async_trait]
    pub trait CustomAudienceService: std::marker::Send + std::marker::Sync + 'static {
        /// Creates or updates custom audiences. Operation statuses are returned.
        ///
        /// List of thrown errors:
        ///   [AuthenticationError]()
        ///   [AuthorizationError]()
        ///   [CustomAudienceError]()
        ///   [CustomInterestError]()
        ///   [FieldError]()
        ///   [FieldMaskError]()
        ///   [HeaderError]()
        ///   [InternalError]()
        ///   [MutateError]()
        ///   [OperationAccessDeniedError]()
        ///   [PolicyViolationError]()
        ///   [QuotaError]()
        ///   [RequestError]()
        async fn mutate_custom_audiences(
            &self,
            request: tonic::Request<super::MutateCustomAudiencesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MutateCustomAudiencesResponse>,
            tonic::Status,
        >;
    }
    /// Service to manage custom audiences.
    #[derive(Debug)]
    pub struct CustomAudienceServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> CustomAudienceServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>>
    for CustomAudienceServiceServer<T>
    where
        T: CustomAudienceService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/google.ads.googleads.v16.services.CustomAudienceService/MutateCustomAudiences" => {
                    #[allow(non_camel_case_types)]
                    struct MutateCustomAudiencesSvc<T: CustomAudienceService>(
                        pub Arc<T>,
                    );
                    impl<
                        T: CustomAudienceService,
                    > tonic::server::UnaryService<super::MutateCustomAudiencesRequest>
                    for MutateCustomAudiencesSvc<T> {
                        type Response = super::MutateCustomAudiencesResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::MutateCustomAudiencesRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as CustomAudienceService>::mutate_custom_audiences(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = MutateCustomAudiencesSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for CustomAudienceServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "google.ads.googleads.v16.services.CustomAudienceService";
    impl<T> tonic::server::NamedService for CustomAudienceServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Request message for
/// [CustomInterestService.MutateCustomInterests][google.ads.googleads.v16.services.CustomInterestService.MutateCustomInterests].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCustomInterestsRequest {
    /// Required. The ID of the customer whose custom interests are being modified.
    #[prost(string, tag = "1")]
    pub customer_id: ::prost::alloc::string::String,
    /// Required. The list of operations to perform on individual custom interests.
    #[prost(message, repeated, tag = "2")]
    pub operations: ::prost::alloc::vec::Vec<CustomInterestOperation>,
    /// If true, the request is validated but not executed. Only errors are
    /// returned, not results.
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
}
/// A single operation (create, update) on a custom interest.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CustomInterestOperation {
    /// FieldMask that determines which resource fields are modified in an update.
    #[prost(message, optional, tag = "4")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// The mutate operation.
    #[prost(oneof = "custom_interest_operation::Operation", tags = "1, 2")]
    pub operation: ::core::option::Option<custom_interest_operation::Operation>,
}
/// Nested message and enum types in `CustomInterestOperation`.
pub mod custom_interest_operation {
    /// The mutate operation.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Operation {
        /// Create operation: No resource name is expected for the new custom
        /// interest.
        #[prost(message, tag = "1")]
        Create(super::super::resources::CustomInterest),
        /// Update operation: The custom interest is expected to have a valid
        /// resource name.
        #[prost(message, tag = "2")]
        Update(super::super::resources::CustomInterest),
    }
}
/// Response message for custom interest mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCustomInterestsResponse {
    /// All results for the mutate.
    #[prost(message, repeated, tag = "2")]
    pub results: ::prost::alloc::vec::Vec<MutateCustomInterestResult>,
}
/// The result for the custom interest mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCustomInterestResult {
    /// Returned for successful operations.
    #[prost(string, tag = "1")]
    pub resource_name: ::prost::alloc::string::String,
}
/// Generated server implementations.
pub mod custom_interest_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with CustomInterestServiceServer.
    #[async_trait]
    pub trait CustomInterestService: std::marker::Send + std::marker::Sync + 'static {
        /// Creates or updates custom interests. Operation statuses are returned.
        ///
        /// List of thrown errors:
        ///   [AuthenticationError]()
        ///   [AuthorizationError]()
        ///   [CriterionError]()
        ///   [CustomInterestError]()
        ///   [HeaderError]()
        ///   [InternalError]()
        ///   [MutateError]()
        ///   [PolicyViolationError]()
        ///   [QuotaError]()
        ///   [RequestError]()
        ///   [StringLengthError]()
        async fn mutate_custom_interests(
            &self,
            request: tonic::Request<super::MutateCustomInterestsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MutateCustomInterestsResponse>,
            tonic::Status,
        >;
    }
    /// Service to manage custom interests.
    #[derive(Debug)]
    pub struct CustomInterestServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> CustomInterestServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>>
    for CustomInterestServiceServer<T>
    where
        T: CustomInterestService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/google.ads.googleads.v16.services.CustomInterestService/MutateCustomInterests" => {
                    #[allow(non_camel_case_types)]
                    struct MutateCustomInterestsSvc<T: CustomInterestService>(
                        pub Arc<T>,
                    );
                    impl<
                        T: CustomInterestService,
                    > tonic::server::UnaryService<super::MutateCustomInterestsRequest>
                    for MutateCustomInterestsSvc<T> {
                        type Response = super::MutateCustomInterestsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::MutateCustomInterestsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as CustomInterestService>::mutate_custom_interests(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = MutateCustomInterestsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for CustomInterestServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "google.ads.googleads.v16.services.CustomInterestService";
    impl<T> tonic::server::NamedService for CustomInterestServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Request message for
/// [CustomerAssetSetService.MutateCustomerAssetSets][google.ads.googleads.v16.services.CustomerAssetSetService.MutateCustomerAssetSets].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCustomerAssetSetsRequest {
    /// Required. The ID of the customer whose customer asset sets are being
    /// modified.
    #[prost(string, tag = "1")]
    pub customer_id: ::prost::alloc::string::String,
    /// Required. The list of operations to perform on individual customer asset
    /// sets.
    #[prost(message, repeated, tag = "2")]
    pub operations: ::prost::alloc::vec::Vec<CustomerAssetSetOperation>,
    /// If true, successful operations will be carried out and invalid
    /// operations will return errors. If false, all operations will be carried
    /// out in one transaction if and only if they are all valid.
    /// Default is false.
    #[prost(bool, tag = "3")]
    pub partial_failure: bool,
    /// If true, the request is validated but not executed. Only errors are
    /// returned, not results.
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
    /// The response content type setting. Determines whether the mutable resource
    /// or just the resource name should be returned post mutation.
    #[prost(
        enumeration = "super::enums::response_content_type_enum::ResponseContentType",
        tag = "5"
    )]
    pub response_content_type: i32,
}
/// A single operation (create, remove) on a customer asset set.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CustomerAssetSetOperation {
    /// The mutate operation.
    #[prost(oneof = "customer_asset_set_operation::Operation", tags = "1, 2")]
    pub operation: ::core::option::Option<customer_asset_set_operation::Operation>,
}
/// Nested message and enum types in `CustomerAssetSetOperation`.
pub mod customer_asset_set_operation {
    /// The mutate operation.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Operation {
        /// Create operation: No resource name is expected for the new customer asset
        /// set.
        #[prost(message, tag = "1")]
        Create(super::super::resources::CustomerAssetSet),
        /// Remove operation: A resource name for the removed customer asset set is
        /// expected, in this format:
        /// `customers/{customer_id}/customerAssetSets/{asset_set_id}`
        #[prost(string, tag = "2")]
        Remove(::prost::alloc::string::String),
    }
}
/// Response message for a customer asset set mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCustomerAssetSetsResponse {
    /// All results for the mutate.
    #[prost(message, repeated, tag = "1")]
    pub results: ::prost::alloc::vec::Vec<MutateCustomerAssetSetResult>,
    /// Errors that pertain to operation failures in the partial failure mode.
    /// Returned only when partial_failure = true and all errors occur inside the
    /// operations. If any errors occur outside the operations (e.g. auth errors),
    /// we return an RPC level error.
    #[prost(message, optional, tag = "2")]
    pub partial_failure_error: ::core::option::Option<
        super::super::super::super::rpc::Status,
    >,
}
/// The result for the customer asset set mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCustomerAssetSetResult {
    /// Returned for successful operations.
    #[prost(string, tag = "1")]
    pub resource_name: ::prost::alloc::string::String,
    /// The mutated customer asset set with only mutable fields after mutate. The
    /// field will only be returned when response_content_type is set to
    /// "MUTABLE_RESOURCE".
    #[prost(message, optional, tag = "2")]
    pub customer_asset_set: ::core::option::Option<super::resources::CustomerAssetSet>,
}
/// Generated server implementations.
pub mod customer_asset_set_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with CustomerAssetSetServiceServer.
    #[async_trait]
    pub trait CustomerAssetSetService: std::marker::Send + std::marker::Sync + 'static {
        /// Creates, or removes customer asset sets. Operation statuses are
        /// returned.
        async fn mutate_customer_asset_sets(
            &self,
            request: tonic::Request<super::MutateCustomerAssetSetsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MutateCustomerAssetSetsResponse>,
            tonic::Status,
        >;
    }
    /// Service to manage customer asset set
    #[derive(Debug)]
    pub struct CustomerAssetSetServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> CustomerAssetSetServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>>
    for CustomerAssetSetServiceServer<T>
    where
        T: CustomerAssetSetService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/google.ads.googleads.v16.services.CustomerAssetSetService/MutateCustomerAssetSets" => {
                    #[allow(non_camel_case_types)]
                    struct MutateCustomerAssetSetsSvc<T: CustomerAssetSetService>(
                        pub Arc<T>,
                    );
                    impl<
                        T: CustomerAssetSetService,
                    > tonic::server::UnaryService<super::MutateCustomerAssetSetsRequest>
                    for MutateCustomerAssetSetsSvc<T> {
                        type Response = super::MutateCustomerAssetSetsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::MutateCustomerAssetSetsRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as CustomerAssetSetService>::mutate_customer_asset_sets(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = MutateCustomerAssetSetsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for CustomerAssetSetServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "google.ads.googleads.v16.services.CustomerAssetSetService";
    impl<T> tonic::server::NamedService for CustomerAssetSetServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Request message for
/// [CustomerClientLinkService.MutateCustomerClientLink][google.ads.googleads.v16.services.CustomerClientLinkService.MutateCustomerClientLink].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCustomerClientLinkRequest {
    /// Required. The ID of the customer whose customer link are being modified.
    #[prost(string, tag = "1")]
    pub customer_id: ::prost::alloc::string::String,
    /// Required. The operation to perform on the individual CustomerClientLink.
    #[prost(message, optional, tag = "2")]
    pub operation: ::core::option::Option<CustomerClientLinkOperation>,
    /// If true, the request is validated but not executed. Only errors are
    /// returned, not results.
    #[prost(bool, tag = "3")]
    pub validate_only: bool,
}
/// A single operation (create, update) on a CustomerClientLink.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CustomerClientLinkOperation {
    /// FieldMask that determines which resource fields are modified in an update.
    #[prost(message, optional, tag = "4")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// The mutate operation.
    #[prost(oneof = "customer_client_link_operation::Operation", tags = "1, 2")]
    pub operation: ::core::option::Option<customer_client_link_operation::Operation>,
}
/// Nested message and enum types in `CustomerClientLinkOperation`.
pub mod customer_client_link_operation {
    /// The mutate operation.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Operation {
        /// Create operation: No resource name is expected for the new link.
        #[prost(message, tag = "1")]
        Create(super::super::resources::CustomerClientLink),
        /// Update operation: The link is expected to have a valid resource name.
        #[prost(message, tag = "2")]
        Update(super::super::resources::CustomerClientLink),
    }
}
/// Response message for a CustomerClientLink mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCustomerClientLinkResponse {
    /// A result that identifies the resource affected by the mutate request.
    #[prost(message, optional, tag = "1")]
    pub result: ::core::option::Option<MutateCustomerClientLinkResult>,
}
/// The result for a single customer client link mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCustomerClientLinkResult {
    /// Returned for successful operations.
    #[prost(string, tag = "1")]
    pub resource_name: ::prost::alloc::string::String,
}
/// Generated server implementations.
pub mod customer_client_link_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with CustomerClientLinkServiceServer.
    #[async_trait]
    pub trait CustomerClientLinkService: std::marker::Send + std::marker::Sync + 'static {
        /// Creates or updates a customer client link. Operation statuses are returned.
        ///
        /// List of thrown errors:
        ///   [AuthenticationError]()
        ///   [AuthorizationError]()
        ///   [DatabaseError]()
        ///   [FieldError]()
        ///   [FieldMaskError]()
        ///   [HeaderError]()
        ///   [InternalError]()
        ///   [ManagerLinkError]()
        ///   [MutateError]()
        ///   [NewResourceCreationError]()
        ///   [QuotaError]()
        ///   [RequestError]()
        async fn mutate_customer_client_link(
            &self,
            request: tonic::Request<super::MutateCustomerClientLinkRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MutateCustomerClientLinkResponse>,
            tonic::Status,
        >;
    }
    /// Service to manage customer client links.
    #[derive(Debug)]
    pub struct CustomerClientLinkServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> CustomerClientLinkServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>>
    for CustomerClientLinkServiceServer<T>
    where
        T: CustomerClientLinkService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/google.ads.googleads.v16.services.CustomerClientLinkService/MutateCustomerClientLink" => {
                    #[allow(non_camel_case_types)]
                    struct MutateCustomerClientLinkSvc<T: CustomerClientLinkService>(
                        pub Arc<T>,
                    );
                    impl<
                        T: CustomerClientLinkService,
                    > tonic::server::UnaryService<super::MutateCustomerClientLinkRequest>
                    for MutateCustomerClientLinkSvc<T> {
                        type Response = super::MutateCustomerClientLinkResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::MutateCustomerClientLinkRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as CustomerClientLinkService>::mutate_customer_client_link(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = MutateCustomerClientLinkSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for CustomerClientLinkServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "google.ads.googleads.v16.services.CustomerClientLinkService";
    impl<T> tonic::server::NamedService for CustomerClientLinkServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Request message for
/// [CustomerLifecycleGoalService.configureCustomerLifecycleGoals][].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConfigureCustomerLifecycleGoalsRequest {
    /// Required. The ID of the customer performing the upload.
    #[prost(string, tag = "1")]
    pub customer_id: ::prost::alloc::string::String,
    /// Required. The operation to perform customer lifecycle goal update.
    #[prost(message, optional, tag = "2")]
    pub operation: ::core::option::Option<CustomerLifecycleGoalOperation>,
    /// Optional. If true, the request is validated but not executed. Only errors
    /// are returned, not results.
    #[prost(bool, tag = "3")]
    pub validate_only: bool,
}
/// A single operation on a customer lifecycle goal.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CustomerLifecycleGoalOperation {
    /// Optional. FieldMask that determines which resource fields are modified in
    /// an update.
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// The mutate operation.
    #[prost(oneof = "customer_lifecycle_goal_operation::Operation", tags = "1, 3")]
    pub operation: ::core::option::Option<customer_lifecycle_goal_operation::Operation>,
}
/// Nested message and enum types in `CustomerLifecycleGoalOperation`.
pub mod customer_lifecycle_goal_operation {
    /// The mutate operation.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Operation {
        /// Create operation: Create a new customer lifecycle goal.
        #[prost(message, tag = "1")]
        Create(super::super::resources::CustomerLifecycleGoal),
        /// Update operation: Update an existing customer lifecycle goal.
        #[prost(message, tag = "3")]
        Update(super::super::resources::CustomerLifecycleGoal),
    }
}
/// Response message for
/// [CustomerLifecycleGoalService.configureCustomerLifecycleGoals][].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConfigureCustomerLifecycleGoalsResponse {
    /// result for the customer lifecycle goal configuration.
    #[prost(message, optional, tag = "1")]
    pub result: ::core::option::Option<ConfigureCustomerLifecycleGoalsResult>,
}
/// The result for the customer lifecycle goal configuration.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConfigureCustomerLifecycleGoalsResult {
    /// Returned for the successful operation.
    #[prost(string, tag = "1")]
    pub resource_name: ::prost::alloc::string::String,
}
/// Generated server implementations.
pub mod customer_lifecycle_goal_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with CustomerLifecycleGoalServiceServer.
    #[async_trait]
    pub trait CustomerLifecycleGoalService: std::marker::Send + std::marker::Sync + 'static {
        /// Process the given customer lifecycle configurations.
        ///
        /// List of thrown errors:
        ///   [AuthenticationError]()
        ///   [AuthorizationError]()
        ///   [CustomerLifecycleGoalConfigError]()
        ///   [HeaderError]()
        ///   [InternalError]()
        ///   [QuotaError]()
        ///   [RequestError]()
        async fn configure_customer_lifecycle_goals(
            &self,
            request: tonic::Request<super::ConfigureCustomerLifecycleGoalsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ConfigureCustomerLifecycleGoalsResponse>,
            tonic::Status,
        >;
    }
    /// Service to configure customer lifecycle goals.
    #[derive(Debug)]
    pub struct CustomerLifecycleGoalServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> CustomerLifecycleGoalServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>>
    for CustomerLifecycleGoalServiceServer<T>
    where
        T: CustomerLifecycleGoalService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/google.ads.googleads.v16.services.CustomerLifecycleGoalService/ConfigureCustomerLifecycleGoals" => {
                    #[allow(non_camel_case_types)]
                    struct ConfigureCustomerLifecycleGoalsSvc<
                        T: CustomerLifecycleGoalService,
                    >(
                        pub Arc<T>,
                    );
                    impl<
                        T: CustomerLifecycleGoalService,
                    > tonic::server::UnaryService<
                        super::ConfigureCustomerLifecycleGoalsRequest,
                    > for ConfigureCustomerLifecycleGoalsSvc<T> {
                        type Response = super::ConfigureCustomerLifecycleGoalsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::ConfigureCustomerLifecycleGoalsRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as CustomerLifecycleGoalService>::configure_customer_lifecycle_goals(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ConfigureCustomerLifecycleGoalsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for CustomerLifecycleGoalServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "google.ads.googleads.v16.services.CustomerLifecycleGoalService";
    impl<T> tonic::server::NamedService for CustomerLifecycleGoalServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Request message for
/// [CustomerManagerLinkService.MutateCustomerManagerLink][google.ads.googleads.v16.services.CustomerManagerLinkService.MutateCustomerManagerLink].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCustomerManagerLinkRequest {
    /// Required. The ID of the customer whose customer manager links are being
    /// modified.
    #[prost(string, tag = "1")]
    pub customer_id: ::prost::alloc::string::String,
    /// Required. The list of operations to perform on individual customer manager
    /// links.
    #[prost(message, repeated, tag = "2")]
    pub operations: ::prost::alloc::vec::Vec<CustomerManagerLinkOperation>,
    /// If true, the request is validated but not executed. Only errors are
    /// returned, not results.
    #[prost(bool, tag = "3")]
    pub validate_only: bool,
}
/// Request message for
/// [CustomerManagerLinkService.MoveManagerLink][google.ads.googleads.v16.services.CustomerManagerLinkService.MoveManagerLink].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MoveManagerLinkRequest {
    /// Required. The ID of the client customer that is being moved.
    #[prost(string, tag = "1")]
    pub customer_id: ::prost::alloc::string::String,
    /// Required. The resource name of the previous CustomerManagerLink.
    /// The resource name has the form:
    /// `customers/{customer_id}/customerManagerLinks/{manager_customer_id}~{manager_link_id}`
    #[prost(string, tag = "2")]
    pub previous_customer_manager_link: ::prost::alloc::string::String,
    /// Required. The resource name of the new manager customer that the client
    /// wants to move to. Customer resource names have the format:
    /// "customers/{customer_id}"
    #[prost(string, tag = "3")]
    pub new_manager: ::prost::alloc::string::String,
    /// If true, the request is validated but not executed. Only errors are
    /// returned, not results.
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
}
/// Updates the status of a CustomerManagerLink.
/// The following actions are possible:
/// 1. Update operation with status ACTIVE accepts a pending invitation.
/// 2. Update operation with status REFUSED declines a pending invitation.
/// 3. Update operation with status INACTIVE terminates link to manager.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CustomerManagerLinkOperation {
    /// FieldMask that determines which resource fields are modified in an update.
    #[prost(message, optional, tag = "4")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// The mutate operation.
    #[prost(oneof = "customer_manager_link_operation::Operation", tags = "2")]
    pub operation: ::core::option::Option<customer_manager_link_operation::Operation>,
}
/// Nested message and enum types in `CustomerManagerLinkOperation`.
pub mod customer_manager_link_operation {
    /// The mutate operation.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Operation {
        /// Update operation: The link is expected to have a valid resource name.
        #[prost(message, tag = "2")]
        Update(super::super::resources::CustomerManagerLink),
    }
}
/// Response message for a CustomerManagerLink mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCustomerManagerLinkResponse {
    /// A result that identifies the resource affected by the mutate request.
    #[prost(message, repeated, tag = "1")]
    pub results: ::prost::alloc::vec::Vec<MutateCustomerManagerLinkResult>,
}
/// Response message for a CustomerManagerLink moveManagerLink.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MoveManagerLinkResponse {
    /// Returned for successful operations. Represents a CustomerManagerLink
    /// resource of the newly created link between client customer and new manager
    /// customer.
    #[prost(string, tag = "1")]
    pub resource_name: ::prost::alloc::string::String,
}
/// The result for the customer manager link mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCustomerManagerLinkResult {
    /// Returned for successful operations.
    #[prost(string, tag = "1")]
    pub resource_name: ::prost::alloc::string::String,
}
/// Generated server implementations.
pub mod customer_manager_link_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with CustomerManagerLinkServiceServer.
    #[async_trait]
    pub trait CustomerManagerLinkService: std::marker::Send + std::marker::Sync + 'static {
        /// Updates customer manager links. Operation statuses are returned.
        ///
        /// List of thrown errors:
        ///   [AuthenticationError]()
        ///   [AuthorizationError]()
        ///   [DatabaseError]()
        ///   [FieldError]()
        ///   [FieldMaskError]()
        ///   [HeaderError]()
        ///   [InternalError]()
        ///   [ManagerLinkError]()
        ///   [MutateError]()
        ///   [QuotaError]()
        ///   [RequestError]()
        async fn mutate_customer_manager_link(
            &self,
            request: tonic::Request<super::MutateCustomerManagerLinkRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MutateCustomerManagerLinkResponse>,
            tonic::Status,
        >;
        /// Moves a client customer to a new manager customer.
        /// This simplifies the complex request that requires two operations to move
        /// a client customer to a new manager, for example:
        /// 1. Update operation with Status INACTIVE (previous manager) and,
        /// 2. Update operation with Status ACTIVE (new manager).
        ///
        /// List of thrown errors:
        ///   [AuthenticationError]()
        ///   [AuthorizationError]()
        ///   [DatabaseError]()
        ///   [FieldError]()
        ///   [HeaderError]()
        ///   [InternalError]()
        ///   [MutateError]()
        ///   [QuotaError]()
        ///   [RequestError]()
        async fn move_manager_link(
            &self,
            request: tonic::Request<super::MoveManagerLinkRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MoveManagerLinkResponse>,
            tonic::Status,
        >;
    }
    /// Service to manage customer-manager links.
    #[derive(Debug)]
    pub struct CustomerManagerLinkServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> CustomerManagerLinkServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>>
    for CustomerManagerLinkServiceServer<T>
    where
        T: CustomerManagerLinkService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/google.ads.googleads.v16.services.CustomerManagerLinkService/MutateCustomerManagerLink" => {
                    #[allow(non_camel_case_types)]
                    struct MutateCustomerManagerLinkSvc<T: CustomerManagerLinkService>(
                        pub Arc<T>,
                    );
                    impl<
                        T: CustomerManagerLinkService,
                    > tonic::server::UnaryService<
                        super::MutateCustomerManagerLinkRequest,
                    > for MutateCustomerManagerLinkSvc<T> {
                        type Response = super::MutateCustomerManagerLinkResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::MutateCustomerManagerLinkRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as CustomerManagerLinkService>::mutate_customer_manager_link(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = MutateCustomerManagerLinkSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.ads.googleads.v16.services.CustomerManagerLinkService/MoveManagerLink" => {
                    #[allow(non_camel_case_types)]
                    struct MoveManagerLinkSvc<T: CustomerManagerLinkService>(pub Arc<T>);
                    impl<
                        T: CustomerManagerLinkService,
                    > tonic::server::UnaryService<super::MoveManagerLinkRequest>
                    for MoveManagerLinkSvc<T> {
                        type Response = super::MoveManagerLinkResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::MoveManagerLinkRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as CustomerManagerLinkService>::move_manager_link(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = MoveManagerLinkSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for CustomerManagerLinkServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "google.ads.googleads.v16.services.CustomerManagerLinkService";
    impl<T> tonic::server::NamedService for CustomerManagerLinkServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// A single update operation for a CustomerSkAdNetworkConversionValueSchema.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CustomerSkAdNetworkConversionValueSchemaOperation {
    /// Update operation: The schema is expected to have a valid resource name.
    #[prost(message, optional, tag = "1")]
    pub update: ::core::option::Option<
        super::resources::CustomerSkAdNetworkConversionValueSchema,
    >,
}
/// Request message for
/// [CustomerSkAdNetworkConversionValueSchemaService.MutateCustomerSkAdNetworkConversionValueSchema][google.ads.googleads.v16.services.CustomerSkAdNetworkConversionValueSchemaService.MutateCustomerSkAdNetworkConversionValueSchema].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCustomerSkAdNetworkConversionValueSchemaRequest {
    /// The ID of the customer whose shared sets are being modified.
    #[prost(string, tag = "1")]
    pub customer_id: ::prost::alloc::string::String,
    /// The operation to perform.
    #[prost(message, optional, tag = "2")]
    pub operation: ::core::option::Option<
        CustomerSkAdNetworkConversionValueSchemaOperation,
    >,
    /// If true, the request is validated but not executed. Only errors are
    /// returned, not results.
    #[prost(bool, tag = "3")]
    pub validate_only: bool,
    /// Optional. If true, enables returning warnings. Warnings return error
    /// messages and error codes without blocking the execution of the mutate
    /// operation.
    #[prost(bool, tag = "4")]
    pub enable_warnings: bool,
}
/// The result for the CustomerSkAdNetworkConversionValueSchema mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCustomerSkAdNetworkConversionValueSchemaResult {
    /// Resource name of the customer that was modified.
    #[prost(string, tag = "1")]
    pub resource_name: ::prost::alloc::string::String,
    /// App ID of the SkanConversionValue modified.
    #[prost(string, tag = "2")]
    pub app_id: ::prost::alloc::string::String,
}
/// Response message for MutateCustomerSkAdNetworkConversionValueSchema.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCustomerSkAdNetworkConversionValueSchemaResponse {
    /// All results for the mutate.
    #[prost(message, optional, tag = "1")]
    pub result: ::core::option::Option<
        MutateCustomerSkAdNetworkConversionValueSchemaResult,
    >,
    /// Non blocking errors that provides schema validation failure details.
    /// Returned only when enable_warnings = true.
    #[prost(message, optional, tag = "2")]
    pub warning: ::core::option::Option<super::super::super::super::rpc::Status>,
}
/// Generated server implementations.
pub mod customer_sk_ad_network_conversion_value_schema_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with CustomerSkAdNetworkConversionValueSchemaServiceServer.
    #[async_trait]
    pub trait CustomerSkAdNetworkConversionValueSchemaService: std::marker::Send + std::marker::Sync + 'static {
        /// Creates or updates the CustomerSkAdNetworkConversionValueSchema.
        ///
        /// List of thrown errors:
        ///   [AuthenticationError]()
        ///   [AuthorizationError]()
        ///   [FieldError]()
        ///   [InternalError]()
        ///   [MutateError]()
        async fn mutate_customer_sk_ad_network_conversion_value_schema(
            &self,
            request: tonic::Request<
                super::MutateCustomerSkAdNetworkConversionValueSchemaRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<
                super::MutateCustomerSkAdNetworkConversionValueSchemaResponse,
            >,
            tonic::Status,
        >;
    }
    /// Service to manage CustomerSkAdNetworkConversionValueSchema.
    #[derive(Debug)]
    pub struct CustomerSkAdNetworkConversionValueSchemaServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> CustomerSkAdNetworkConversionValueSchemaServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>>
    for CustomerSkAdNetworkConversionValueSchemaServiceServer<T>
    where
        T: CustomerSkAdNetworkConversionValueSchemaService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/google.ads.googleads.v16.services.CustomerSkAdNetworkConversionValueSchemaService/MutateCustomerSkAdNetworkConversionValueSchema" => {
                    #[allow(non_camel_case_types)]
                    struct MutateCustomerSkAdNetworkConversionValueSchemaSvc<
                        T: CustomerSkAdNetworkConversionValueSchemaService,
                    >(
                        pub Arc<T>,
                    );
                    impl<
                        T: CustomerSkAdNetworkConversionValueSchemaService,
                    > tonic::server::UnaryService<
                        super::MutateCustomerSkAdNetworkConversionValueSchemaRequest,
                    > for MutateCustomerSkAdNetworkConversionValueSchemaSvc<T> {
                        type Response = super::MutateCustomerSkAdNetworkConversionValueSchemaResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::MutateCustomerSkAdNetworkConversionValueSchemaRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as CustomerSkAdNetworkConversionValueSchemaService>::mutate_customer_sk_ad_network_conversion_value_schema(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = MutateCustomerSkAdNetworkConversionValueSchemaSvc(
                            inner,
                        );
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for CustomerSkAdNetworkConversionValueSchemaServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "google.ads.googleads.v16.services.CustomerSkAdNetworkConversionValueSchemaService";
    impl<T> tonic::server::NamedService
    for CustomerSkAdNetworkConversionValueSchemaServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Request message for
/// [CustomerUserAccessInvitationService.MutateCustomerUserAccessInvitation][google.ads.googleads.v16.services.CustomerUserAccessInvitationService.MutateCustomerUserAccessInvitation]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCustomerUserAccessInvitationRequest {
    /// Required. The ID of the customer whose access invitation is being modified.
    #[prost(string, tag = "1")]
    pub customer_id: ::prost::alloc::string::String,
    /// Required. The operation to perform on the access invitation
    #[prost(message, optional, tag = "2")]
    pub operation: ::core::option::Option<CustomerUserAccessInvitationOperation>,
}
/// A single operation (create or remove) on customer user access invitation.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CustomerUserAccessInvitationOperation {
    /// The mutate operation
    #[prost(
        oneof = "customer_user_access_invitation_operation::Operation",
        tags = "1, 2"
    )]
    pub operation: ::core::option::Option<
        customer_user_access_invitation_operation::Operation,
    >,
}
/// Nested message and enum types in `CustomerUserAccessInvitationOperation`.
pub mod customer_user_access_invitation_operation {
    /// The mutate operation
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Operation {
        /// Create operation: No resource name is expected for the new access
        /// invitation.
        #[prost(message, tag = "1")]
        Create(super::super::resources::CustomerUserAccessInvitation),
        /// Remove operation: A resource name for the revoke invitation is
        /// expected, in this format:
        ///
        /// `customers/{customer_id}/customerUserAccessInvitations/{invitation_id}`
        #[prost(string, tag = "2")]
        Remove(::prost::alloc::string::String),
    }
}
/// Response message for access invitation mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCustomerUserAccessInvitationResponse {
    /// Result for the mutate.
    #[prost(message, optional, tag = "1")]
    pub result: ::core::option::Option<MutateCustomerUserAccessInvitationResult>,
}
/// The result for the access invitation mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCustomerUserAccessInvitationResult {
    /// Returned for successful operations.
    #[prost(string, tag = "1")]
    pub resource_name: ::prost::alloc::string::String,
}
/// Generated server implementations.
pub mod customer_user_access_invitation_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with CustomerUserAccessInvitationServiceServer.
    #[async_trait]
    pub trait CustomerUserAccessInvitationService: std::marker::Send + std::marker::Sync + 'static {
        /// Creates or removes an access invitation.
        ///
        /// List of thrown errors:
        ///   [AccessInvitationError]()
        ///   [AuthenticationError]()
        ///   [AuthorizationError]()
        ///   [HeaderError]()
        ///   [InternalError]()
        ///   [QuotaError]()
        ///   [RequestError]()
        async fn mutate_customer_user_access_invitation(
            &self,
            request: tonic::Request<super::MutateCustomerUserAccessInvitationRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MutateCustomerUserAccessInvitationResponse>,
            tonic::Status,
        >;
    }
    /// This service manages the access invitation extended to users for a given
    /// customer.
    #[derive(Debug)]
    pub struct CustomerUserAccessInvitationServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> CustomerUserAccessInvitationServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>>
    for CustomerUserAccessInvitationServiceServer<T>
    where
        T: CustomerUserAccessInvitationService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/google.ads.googleads.v16.services.CustomerUserAccessInvitationService/MutateCustomerUserAccessInvitation" => {
                    #[allow(non_camel_case_types)]
                    struct MutateCustomerUserAccessInvitationSvc<
                        T: CustomerUserAccessInvitationService,
                    >(
                        pub Arc<T>,
                    );
                    impl<
                        T: CustomerUserAccessInvitationService,
                    > tonic::server::UnaryService<
                        super::MutateCustomerUserAccessInvitationRequest,
                    > for MutateCustomerUserAccessInvitationSvc<T> {
                        type Response = super::MutateCustomerUserAccessInvitationResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::MutateCustomerUserAccessInvitationRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as CustomerUserAccessInvitationService>::mutate_customer_user_access_invitation(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = MutateCustomerUserAccessInvitationSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for CustomerUserAccessInvitationServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "google.ads.googleads.v16.services.CustomerUserAccessInvitationService";
    impl<T> tonic::server::NamedService
    for CustomerUserAccessInvitationServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Mutate Request for
/// [CustomerUserAccessService.MutateCustomerUserAccess][google.ads.googleads.v16.services.CustomerUserAccessService.MutateCustomerUserAccess].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCustomerUserAccessRequest {
    /// Required. The ID of the customer being modified.
    #[prost(string, tag = "1")]
    pub customer_id: ::prost::alloc::string::String,
    /// Required. The operation to perform on the customer
    #[prost(message, optional, tag = "2")]
    pub operation: ::core::option::Option<CustomerUserAccessOperation>,
}
/// A single operation (update, remove) on customer user access.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CustomerUserAccessOperation {
    /// FieldMask that determines which resource fields are modified in an update.
    #[prost(message, optional, tag = "3")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// The mutate operation.
    #[prost(oneof = "customer_user_access_operation::Operation", tags = "1, 2")]
    pub operation: ::core::option::Option<customer_user_access_operation::Operation>,
}
/// Nested message and enum types in `CustomerUserAccessOperation`.
pub mod customer_user_access_operation {
    /// The mutate operation.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Operation {
        /// Update operation: The customer user access is expected to have a valid
        /// resource name.
        #[prost(message, tag = "1")]
        Update(super::super::resources::CustomerUserAccess),
        /// Remove operation: A resource name for the removed access is
        /// expected, in this format:
        ///
        /// `customers/{customer_id}/customerUserAccesses/{CustomerUserAccess.user_id}`
        #[prost(string, tag = "2")]
        Remove(::prost::alloc::string::String),
    }
}
/// Response message for customer user access mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCustomerUserAccessResponse {
    /// Result for the mutate.
    #[prost(message, optional, tag = "1")]
    pub result: ::core::option::Option<MutateCustomerUserAccessResult>,
}
/// The result for the customer user access mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCustomerUserAccessResult {
    /// Returned for successful operations.
    #[prost(string, tag = "1")]
    pub resource_name: ::prost::alloc::string::String,
}
/// Generated server implementations.
pub mod customer_user_access_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with CustomerUserAccessServiceServer.
    #[async_trait]
    pub trait CustomerUserAccessService: std::marker::Send + std::marker::Sync + 'static {
        /// Updates, removes permission of a user on a given customer. Operation
        /// statuses are returned.
        ///
        /// List of thrown errors:
        ///   [AuthenticationError]()
        ///   [AuthorizationError]()
        ///   [CustomerUserAccessError]()
        ///   [FieldMaskError]()
        ///   [HeaderError]()
        ///   [InternalError]()
        ///   [MutateError]()
        ///   [QuotaError]()
        ///   [RequestError]()
        async fn mutate_customer_user_access(
            &self,
            request: tonic::Request<super::MutateCustomerUserAccessRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MutateCustomerUserAccessResponse>,
            tonic::Status,
        >;
    }
    /// This service manages the permissions of a user on a given customer.
    #[derive(Debug)]
    pub struct CustomerUserAccessServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> CustomerUserAccessServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>>
    for CustomerUserAccessServiceServer<T>
    where
        T: CustomerUserAccessService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/google.ads.googleads.v16.services.CustomerUserAccessService/MutateCustomerUserAccess" => {
                    #[allow(non_camel_case_types)]
                    struct MutateCustomerUserAccessSvc<T: CustomerUserAccessService>(
                        pub Arc<T>,
                    );
                    impl<
                        T: CustomerUserAccessService,
                    > tonic::server::UnaryService<super::MutateCustomerUserAccessRequest>
                    for MutateCustomerUserAccessSvc<T> {
                        type Response = super::MutateCustomerUserAccessResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::MutateCustomerUserAccessRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as CustomerUserAccessService>::mutate_customer_user_access(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = MutateCustomerUserAccessSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for CustomerUserAccessServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "google.ads.googleads.v16.services.CustomerUserAccessService";
    impl<T> tonic::server::NamedService for CustomerUserAccessServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Request message for
/// [GeoTargetConstantService.SuggestGeoTargetConstants][google.ads.googleads.v16.services.GeoTargetConstantService.SuggestGeoTargetConstants].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SuggestGeoTargetConstantsRequest {
    /// If possible, returned geo targets are translated using this locale. If not,
    /// en is used by default. This is also used as a hint for returned geo
    /// targets.
    #[prost(string, optional, tag = "6")]
    pub locale: ::core::option::Option<::prost::alloc::string::String>,
    /// Returned geo targets are restricted to this country code.
    #[prost(string, optional, tag = "7")]
    pub country_code: ::core::option::Option<::prost::alloc::string::String>,
    /// Required. A selector of geo target constants.
    #[prost(oneof = "suggest_geo_target_constants_request::Query", tags = "1, 2")]
    pub query: ::core::option::Option<suggest_geo_target_constants_request::Query>,
}
/// Nested message and enum types in `SuggestGeoTargetConstantsRequest`.
pub mod suggest_geo_target_constants_request {
    /// A list of location names.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct LocationNames {
        /// A list of location names.
        #[prost(string, repeated, tag = "2")]
        pub names: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    }
    /// A list of geo target constant resource names.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct GeoTargets {
        /// A list of geo target constant resource names.
        #[prost(string, repeated, tag = "2")]
        pub geo_target_constants: ::prost::alloc::vec::Vec<
            ::prost::alloc::string::String,
        >,
    }
    /// Required. A selector of geo target constants.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Query {
        /// The location names to search by. At most 25 names can be set.
        #[prost(message, tag = "1")]
        LocationNames(LocationNames),
        /// The geo target constant resource names to filter by.
        #[prost(message, tag = "2")]
        GeoTargets(GeoTargets),
    }
}
/// Response message for
/// [GeoTargetConstantService.SuggestGeoTargetConstants][google.ads.googleads.v16.services.GeoTargetConstantService.SuggestGeoTargetConstants].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SuggestGeoTargetConstantsResponse {
    /// Geo target constant suggestions.
    #[prost(message, repeated, tag = "1")]
    pub geo_target_constant_suggestions: ::prost::alloc::vec::Vec<
        GeoTargetConstantSuggestion,
    >,
}
/// A geo target constant suggestion.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GeoTargetConstantSuggestion {
    /// The language this GeoTargetConstantSuggestion is currently translated to.
    /// It affects the name of geo target fields. For example, if locale=en, then
    /// name=Spain. If locale=es, then name=España. The default locale will be
    /// returned if no translation exists for the locale in the request.
    #[prost(string, optional, tag = "6")]
    pub locale: ::core::option::Option<::prost::alloc::string::String>,
    /// Approximate user population that will be targeted, rounded to the
    /// nearest 100.
    #[prost(int64, optional, tag = "7")]
    pub reach: ::core::option::Option<i64>,
    /// If the request searched by location name, this is the location name that
    /// matched the geo target.
    #[prost(string, optional, tag = "8")]
    pub search_term: ::core::option::Option<::prost::alloc::string::String>,
    /// The GeoTargetConstant result.
    #[prost(message, optional, tag = "4")]
    pub geo_target_constant: ::core::option::Option<super::resources::GeoTargetConstant>,
    /// The list of parents of the geo target constant.
    #[prost(message, repeated, tag = "5")]
    pub geo_target_constant_parents: ::prost::alloc::vec::Vec<
        super::resources::GeoTargetConstant,
    >,
}
/// Generated server implementations.
pub mod geo_target_constant_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with GeoTargetConstantServiceServer.
    #[async_trait]
    pub trait GeoTargetConstantService: std::marker::Send + std::marker::Sync + 'static {
        /// Returns GeoTargetConstant suggestions by location name or by resource name.
        ///
        /// List of thrown errors:
        ///   [AuthenticationError]()
        ///   [AuthorizationError]()
        ///   [GeoTargetConstantSuggestionError]()
        ///   [HeaderError]()
        ///   [InternalError]()
        ///   [QuotaError]()
        ///   [RequestError]()
        async fn suggest_geo_target_constants(
            &self,
            request: tonic::Request<super::SuggestGeoTargetConstantsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SuggestGeoTargetConstantsResponse>,
            tonic::Status,
        >;
    }
    /// Service to fetch geo target constants.
    #[derive(Debug)]
    pub struct GeoTargetConstantServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> GeoTargetConstantServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>>
    for GeoTargetConstantServiceServer<T>
    where
        T: GeoTargetConstantService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/google.ads.googleads.v16.services.GeoTargetConstantService/SuggestGeoTargetConstants" => {
                    #[allow(non_camel_case_types)]
                    struct SuggestGeoTargetConstantsSvc<T: GeoTargetConstantService>(
                        pub Arc<T>,
                    );
                    impl<
                        T: GeoTargetConstantService,
                    > tonic::server::UnaryService<
                        super::SuggestGeoTargetConstantsRequest,
                    > for SuggestGeoTargetConstantsSvc<T> {
                        type Response = super::SuggestGeoTargetConstantsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::SuggestGeoTargetConstantsRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as GeoTargetConstantService>::suggest_geo_target_constants(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SuggestGeoTargetConstantsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for GeoTargetConstantServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "google.ads.googleads.v16.services.GeoTargetConstantService";
    impl<T> tonic::server::NamedService for GeoTargetConstantServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Request message for
/// [GoogleAdsFieldService.GetGoogleAdsField][google.ads.googleads.v16.services.GoogleAdsFieldService.GetGoogleAdsField].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetGoogleAdsFieldRequest {
    /// Required. The resource name of the field to get.
    #[prost(string, tag = "1")]
    pub resource_name: ::prost::alloc::string::String,
}
/// Request message for
/// [GoogleAdsFieldService.SearchGoogleAdsFields][google.ads.googleads.v16.services.GoogleAdsFieldService.SearchGoogleAdsFields].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchGoogleAdsFieldsRequest {
    /// Required. The query string.
    #[prost(string, tag = "1")]
    pub query: ::prost::alloc::string::String,
    /// Token of the page to retrieve. If not specified, the first page of
    /// results will be returned. Use the value obtained from `next_page_token`
    /// in the previous response in order to request the next page of results.
    #[prost(string, tag = "2")]
    pub page_token: ::prost::alloc::string::String,
    /// Number of elements to retrieve in a single page.
    /// When too large a page is requested, the server may decide to further
    /// limit the number of returned resources.
    #[prost(int32, tag = "3")]
    pub page_size: i32,
}
/// Response message for
/// [GoogleAdsFieldService.SearchGoogleAdsFields][google.ads.googleads.v16.services.GoogleAdsFieldService.SearchGoogleAdsFields].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchGoogleAdsFieldsResponse {
    /// The list of fields that matched the query.
    #[prost(message, repeated, tag = "1")]
    pub results: ::prost::alloc::vec::Vec<super::resources::GoogleAdsField>,
    /// Pagination token used to retrieve the next page of results. Pass the
    /// content of this string as the `page_token` attribute of the next request.
    /// `next_page_token` is not returned for the last page.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    /// Total number of results that match the query ignoring the LIMIT clause.
    #[prost(int64, tag = "3")]
    pub total_results_count: i64,
}
/// Generated server implementations.
pub mod google_ads_field_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with GoogleAdsFieldServiceServer.
    #[async_trait]
    pub trait GoogleAdsFieldService: std::marker::Send + std::marker::Sync + 'static {
        /// Returns just the requested field.
        ///
        /// List of thrown errors:
        ///   [AuthenticationError]()
        ///   [AuthorizationError]()
        ///   [HeaderError]()
        ///   [InternalError]()
        ///   [QuotaError]()
        ///   [RequestError]()
        async fn get_google_ads_field(
            &self,
            request: tonic::Request<super::GetGoogleAdsFieldRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::resources::GoogleAdsField>,
            tonic::Status,
        >;
        /// Returns all fields that match the search query.
        ///
        /// List of thrown errors:
        ///   [AuthenticationError]()
        ///   [AuthorizationError]()
        ///   [HeaderError]()
        ///   [InternalError]()
        ///   [QueryError]()
        ///   [QuotaError]()
        ///   [RequestError]()
        async fn search_google_ads_fields(
            &self,
            request: tonic::Request<super::SearchGoogleAdsFieldsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SearchGoogleAdsFieldsResponse>,
            tonic::Status,
        >;
    }
    /// Service to fetch Google Ads API fields.
    #[derive(Debug)]
    pub struct GoogleAdsFieldServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> GoogleAdsFieldServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>>
    for GoogleAdsFieldServiceServer<T>
    where
        T: GoogleAdsFieldService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/google.ads.googleads.v16.services.GoogleAdsFieldService/GetGoogleAdsField" => {
                    #[allow(non_camel_case_types)]
                    struct GetGoogleAdsFieldSvc<T: GoogleAdsFieldService>(pub Arc<T>);
                    impl<
                        T: GoogleAdsFieldService,
                    > tonic::server::UnaryService<super::GetGoogleAdsFieldRequest>
                    for GetGoogleAdsFieldSvc<T> {
                        type Response = super::super::resources::GoogleAdsField;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetGoogleAdsFieldRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as GoogleAdsFieldService>::get_google_ads_field(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetGoogleAdsFieldSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.ads.googleads.v16.services.GoogleAdsFieldService/SearchGoogleAdsFields" => {
                    #[allow(non_camel_case_types)]
                    struct SearchGoogleAdsFieldsSvc<T: GoogleAdsFieldService>(
                        pub Arc<T>,
                    );
                    impl<
                        T: GoogleAdsFieldService,
                    > tonic::server::UnaryService<super::SearchGoogleAdsFieldsRequest>
                    for SearchGoogleAdsFieldsSvc<T> {
                        type Response = super::SearchGoogleAdsFieldsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::SearchGoogleAdsFieldsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as GoogleAdsFieldService>::search_google_ads_fields(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SearchGoogleAdsFieldsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for GoogleAdsFieldServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "google.ads.googleads.v16.services.GoogleAdsFieldService";
    impl<T> tonic::server::NamedService for GoogleAdsFieldServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Request message for
///   \[IdentityVerificationService.StartIdentityVerification\].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StartIdentityVerificationRequest {
    /// Required. The Id of the customer for whom we are creating this
    /// verification.
    #[prost(string, tag = "1")]
    pub customer_id: ::prost::alloc::string::String,
    /// Required. The verification program type for which we want to start the
    /// verification.
    #[prost(
        enumeration = "super::enums::identity_verification_program_enum::IdentityVerificationProgram",
        tag = "2"
    )]
    pub verification_program: i32,
}
/// Request message for
///   \[IdentityVerificationService.GetIdentityVerification\].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetIdentityVerificationRequest {
    /// Required.  The ID of the customer for whom we are requesting verification
    ///   information.
    #[prost(string, tag = "1")]
    pub customer_id: ::prost::alloc::string::String,
}
/// Response message for
///   \[IdentityVerificationService.GetIdentityVerification\].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetIdentityVerificationResponse {
    /// List of identity verifications for the customer.
    #[prost(message, repeated, tag = "1")]
    pub identity_verification: ::prost::alloc::vec::Vec<IdentityVerification>,
}
/// An identity verification for a customer.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IdentityVerification {
    /// The verification program type.
    #[prost(
        enumeration = "super::enums::identity_verification_program_enum::IdentityVerificationProgram",
        tag = "1"
    )]
    pub verification_program: i32,
    /// The verification requirement for this verification program for this
    /// customer.
    #[prost(message, optional, tag = "2")]
    pub identity_verification_requirement: ::core::option::Option<
        IdentityVerificationRequirement,
    >,
    /// Information regarding progress for this verification program for this
    /// customer.
    #[prost(message, optional, tag = "3")]
    pub verification_progress: ::core::option::Option<IdentityVerificationProgress>,
}
/// Information regarding the verification progress for a verification program
/// type.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IdentityVerificationProgress {
    /// Current Status (PENDING_USER_ACTION, SUCCESS, FAILURE etc)
    #[prost(
        enumeration = "super::enums::identity_verification_program_status_enum::IdentityVerificationProgramStatus",
        tag = "1"
    )]
    pub program_status: i32,
    /// The timestamp when the action url will expire in "yyyy-MM-dd HH:mm:ss"
    /// format.
    #[prost(string, tag = "2")]
    pub invitation_link_expiration_time: ::prost::alloc::string::String,
    /// Action URL for user to complete verification for the given verification
    /// program type.
    #[prost(string, tag = "3")]
    pub action_url: ::prost::alloc::string::String,
}
/// Information regarding the verification requirement for a verification program
/// type.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IdentityVerificationRequirement {
    /// The deadline to start verification in "yyyy-MM-dd HH:mm:ss" format.
    #[prost(string, tag = "1")]
    pub verification_start_deadline_time: ::prost::alloc::string::String,
    /// The deadline to submit verification.
    #[prost(string, tag = "2")]
    pub verification_completion_deadline_time: ::prost::alloc::string::String,
}
/// Generated server implementations.
pub mod identity_verification_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with IdentityVerificationServiceServer.
    #[async_trait]
    pub trait IdentityVerificationService: std::marker::Send + std::marker::Sync + 'static {
        /// Starts Identity Verification for a given verification program type.
        ///  Statuses are returned.
        ///
        /// List of thrown errors:
        ///   [AuthenticationError]()
        ///   [AuthorizationError]()
        ///   [HeaderError]()
        ///   [InternalError]()
        ///   [QuotaError]()
        ///   [RequestError]()
        async fn start_identity_verification(
            &self,
            request: tonic::Request<super::StartIdentityVerificationRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status>;
        /// Returns Identity Verification information.
        ///
        /// List of thrown errors:
        ///   [AuthenticationError]()
        ///   [AuthorizationError]()
        ///   [HeaderError]()
        ///   [InternalError]()
        ///   [QuotaError]()
        ///   [RequestError]()
        async fn get_identity_verification(
            &self,
            request: tonic::Request<super::GetIdentityVerificationRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetIdentityVerificationResponse>,
            tonic::Status,
        >;
    }
    /// A service for managing Identity Verification Service.
    #[derive(Debug)]
    pub struct IdentityVerificationServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> IdentityVerificationServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>>
    for IdentityVerificationServiceServer<T>
    where
        T: IdentityVerificationService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/google.ads.googleads.v16.services.IdentityVerificationService/StartIdentityVerification" => {
                    #[allow(non_camel_case_types)]
                    struct StartIdentityVerificationSvc<T: IdentityVerificationService>(
                        pub Arc<T>,
                    );
                    impl<
                        T: IdentityVerificationService,
                    > tonic::server::UnaryService<
                        super::StartIdentityVerificationRequest,
                    > for StartIdentityVerificationSvc<T> {
                        type Response = ();
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::StartIdentityVerificationRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as IdentityVerificationService>::start_identity_verification(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = StartIdentityVerificationSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.ads.googleads.v16.services.IdentityVerificationService/GetIdentityVerification" => {
                    #[allow(non_camel_case_types)]
                    struct GetIdentityVerificationSvc<T: IdentityVerificationService>(
                        pub Arc<T>,
                    );
                    impl<
                        T: IdentityVerificationService,
                    > tonic::server::UnaryService<super::GetIdentityVerificationRequest>
                    for GetIdentityVerificationSvc<T> {
                        type Response = super::GetIdentityVerificationResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::GetIdentityVerificationRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as IdentityVerificationService>::get_identity_verification(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetIdentityVerificationSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for IdentityVerificationServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "google.ads.googleads.v16.services.IdentityVerificationService";
    impl<T> tonic::server::NamedService for IdentityVerificationServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Request message for fetching the invoices of a given billing setup that were
/// issued during a given month.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListInvoicesRequest {
    /// Required. The ID of the customer to fetch invoices for.
    #[prost(string, tag = "1")]
    pub customer_id: ::prost::alloc::string::String,
    /// Required. The billing setup resource name of the requested invoices.
    ///
    /// `customers/{customer_id}/billingSetups/{billing_setup_id}`
    #[prost(string, tag = "2")]
    pub billing_setup: ::prost::alloc::string::String,
    /// Required. The issue year to retrieve invoices, in yyyy format. Only
    /// invoices issued in 2019 or later can be retrieved.
    #[prost(string, tag = "3")]
    pub issue_year: ::prost::alloc::string::String,
    /// Required. The issue month to retrieve invoices.
    #[prost(enumeration = "super::enums::month_of_year_enum::MonthOfYear", tag = "4")]
    pub issue_month: i32,
}
/// Response message for
/// [InvoiceService.ListInvoices][google.ads.googleads.v16.services.InvoiceService.ListInvoices].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListInvoicesResponse {
    /// The list of invoices that match the billing setup and time period.
    #[prost(message, repeated, tag = "1")]
    pub invoices: ::prost::alloc::vec::Vec<super::resources::Invoice>,
}
/// Generated server implementations.
pub mod invoice_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with InvoiceServiceServer.
    #[async_trait]
    pub trait InvoiceService: std::marker::Send + std::marker::Sync + 'static {
        /// Returns all invoices associated with a billing setup, for a given month.
        ///
        /// List of thrown errors:
        ///   [AuthenticationError]()
        ///   [AuthorizationError]()
        ///   [FieldError]()
        ///   [HeaderError]()
        ///   [InternalError]()
        ///   [InvoiceError]()
        ///   [QuotaError]()
        ///   [RequestError]()
        async fn list_invoices(
            &self,
            request: tonic::Request<super::ListInvoicesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListInvoicesResponse>,
            tonic::Status,
        >;
    }
    /// A service to fetch invoices issued for a billing setup during a given month.
    #[derive(Debug)]
    pub struct InvoiceServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> InvoiceServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for InvoiceServiceServer<T>
    where
        T: InvoiceService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/google.ads.googleads.v16.services.InvoiceService/ListInvoices" => {
                    #[allow(non_camel_case_types)]
                    struct ListInvoicesSvc<T: InvoiceService>(pub Arc<T>);
                    impl<
                        T: InvoiceService,
                    > tonic::server::UnaryService<super::ListInvoicesRequest>
                    for ListInvoicesSvc<T> {
                        type Response = super::ListInvoicesResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ListInvoicesRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as InvoiceService>::list_invoices(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ListInvoicesSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for InvoiceServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "google.ads.googleads.v16.services.InvoiceService";
    impl<T> tonic::server::NamedService for InvoiceServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Request message for
/// [KeywordPlanIdeaService.GenerateKeywordIdeas][google.ads.googleads.v16.services.KeywordPlanIdeaService.GenerateKeywordIdeas].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenerateKeywordIdeasRequest {
    /// The ID of the customer with the recommendation.
    #[prost(string, tag = "1")]
    pub customer_id: ::prost::alloc::string::String,
    /// The resource name of the language to target.
    /// Each keyword belongs to some set of languages; a keyword is included if
    /// language is one of its languages.
    /// If not set, all keywords will be included.
    #[prost(string, optional, tag = "14")]
    pub language: ::core::option::Option<::prost::alloc::string::String>,
    /// The resource names of the location to target. Maximum is 10.
    /// An empty list MAY be used to specify all targeting geos.
    #[prost(string, repeated, tag = "15")]
    pub geo_target_constants: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// If true, adult keywords will be included in response.
    /// The default value is false.
    #[prost(bool, tag = "10")]
    pub include_adult_keywords: bool,
    /// Token of the page to retrieve. If not specified, the first
    /// page of results will be returned. To request next page of results use the
    /// value obtained from `next_page_token` in the previous response.
    /// The request fields must match across pages.
    #[prost(string, tag = "12")]
    pub page_token: ::prost::alloc::string::String,
    /// Number of results to retrieve in a single page.
    /// A maximum of 10,000 results may be returned, if the page_size
    /// exceeds this, it is ignored.
    /// If unspecified, at most 10,000 results will be returned.
    /// The server may decide to further limit the number of returned resources.
    /// If the response contains fewer than 10,000 results it may not be assumed
    /// as last page of results.
    #[prost(int32, tag = "13")]
    pub page_size: i32,
    /// Targeting network.
    /// If not set, Google Search And Partners Network will be used.
    #[prost(
        enumeration = "super::enums::keyword_plan_network_enum::KeywordPlanNetwork",
        tag = "9"
    )]
    pub keyword_plan_network: i32,
    /// The keyword annotations to include in response.
    #[prost(
        enumeration = "super::enums::keyword_plan_keyword_annotation_enum::KeywordPlanKeywordAnnotation",
        repeated,
        tag = "17"
    )]
    pub keyword_annotation: ::prost::alloc::vec::Vec<i32>,
    /// The aggregate fields to include in response.
    #[prost(message, optional, tag = "16")]
    pub aggregate_metrics: ::core::option::Option<
        super::common::KeywordPlanAggregateMetrics,
    >,
    /// The options for historical metrics data.
    #[prost(message, optional, tag = "18")]
    pub historical_metrics_options: ::core::option::Option<
        super::common::HistoricalMetricsOptions,
    >,
    /// The type of seed to generate keyword ideas.
    #[prost(oneof = "generate_keyword_ideas_request::Seed", tags = "2, 3, 5, 11")]
    pub seed: ::core::option::Option<generate_keyword_ideas_request::Seed>,
}
/// Nested message and enum types in `GenerateKeywordIdeasRequest`.
pub mod generate_keyword_ideas_request {
    /// The type of seed to generate keyword ideas.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Seed {
        /// A Keyword and a specific Url to generate ideas from
        /// for example, cars, www.example.com/cars.
        #[prost(message, tag = "2")]
        KeywordAndUrlSeed(super::KeywordAndUrlSeed),
        /// A Keyword or phrase to generate ideas from, for example, cars.
        #[prost(message, tag = "3")]
        KeywordSeed(super::KeywordSeed),
        /// A specific url to generate ideas from, for example, www.example.com/cars.
        #[prost(message, tag = "5")]
        UrlSeed(super::UrlSeed),
        /// The site to generate ideas from, for example, www.example.com.
        #[prost(message, tag = "11")]
        SiteSeed(super::SiteSeed),
    }
}
/// Keyword And Url Seed
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KeywordAndUrlSeed {
    /// The URL to crawl in order to generate keyword ideas.
    #[prost(string, optional, tag = "3")]
    pub url: ::core::option::Option<::prost::alloc::string::String>,
    /// Requires at least one keyword.
    #[prost(string, repeated, tag = "4")]
    pub keywords: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Keyword Seed
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KeywordSeed {
    /// Requires at least one keyword.
    #[prost(string, repeated, tag = "2")]
    pub keywords: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Site Seed
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SiteSeed {
    /// The domain name of the site. If the customer requesting the ideas doesn't
    /// own the site provided only public information is returned.
    #[prost(string, optional, tag = "2")]
    pub site: ::core::option::Option<::prost::alloc::string::String>,
}
/// Url Seed
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UrlSeed {
    /// The URL to crawl in order to generate keyword ideas.
    #[prost(string, optional, tag = "2")]
    pub url: ::core::option::Option<::prost::alloc::string::String>,
}
/// Response message for
/// [KeywordPlanIdeaService.GenerateKeywordIdeas][google.ads.googleads.v16.services.KeywordPlanIdeaService.GenerateKeywordIdeas].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenerateKeywordIdeaResponse {
    /// Results of generating keyword ideas.
    #[prost(message, repeated, tag = "1")]
    pub results: ::prost::alloc::vec::Vec<GenerateKeywordIdeaResult>,
    /// The aggregate metrics for all keyword ideas.
    #[prost(message, optional, tag = "4")]
    pub aggregate_metric_results: ::core::option::Option<
        super::common::KeywordPlanAggregateMetricResults,
    >,
    /// Pagination token used to retrieve the next page of results.
    /// Pass the content of this string as the `page_token` attribute of
    /// the next request.
    /// `next_page_token` is not returned for the last page.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    /// Total number of results available.
    #[prost(int64, tag = "3")]
    pub total_size: i64,
}
/// The result of generating keyword ideas.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenerateKeywordIdeaResult {
    /// Text of the keyword idea.
    /// As in Keyword Plan historical metrics, this text may not be an actual
    /// keyword, but the canonical form of multiple keywords.
    /// See KeywordPlanKeywordHistoricalMetrics message in KeywordPlanService.
    #[prost(string, optional, tag = "5")]
    pub text: ::core::option::Option<::prost::alloc::string::String>,
    /// The historical metrics for the keyword.
    #[prost(message, optional, tag = "3")]
    pub keyword_idea_metrics: ::core::option::Option<
        super::common::KeywordPlanHistoricalMetrics,
    >,
    /// The annotations for the keyword.
    /// The annotation data is only provided if requested.
    #[prost(message, optional, tag = "6")]
    pub keyword_annotations: ::core::option::Option<super::common::KeywordAnnotations>,
    /// The list of close variants from the requested keywords that
    /// are combined into this GenerateKeywordIdeaResult. See
    /// <https://support.google.com/google-ads/answer/9342105> for the
    /// definition of "close variants".
    #[prost(string, repeated, tag = "7")]
    pub close_variants: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Request message for
/// [KeywordPlanIdeaService.GenerateKeywordHistoricalMetrics][google.ads.googleads.v16.services.KeywordPlanIdeaService.GenerateKeywordHistoricalMetrics].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenerateKeywordHistoricalMetricsRequest {
    /// The ID of the customer with the recommendation.
    #[prost(string, tag = "1")]
    pub customer_id: ::prost::alloc::string::String,
    /// A list of keywords to get historical metrics.
    /// Not all inputs will be returned as a result of near-exact deduplication.
    /// For example, if stats for "car" and "cars" are requested, only "car" will
    /// be returned.
    /// A maximum of 10,000 keywords can be used.
    #[prost(string, repeated, tag = "2")]
    pub keywords: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// The resource name of the language to target.
    /// Each keyword belongs to some set of languages; a keyword is included if
    /// language is one of its languages.
    /// If not set, all keywords will be included.
    #[prost(string, optional, tag = "4")]
    pub language: ::core::option::Option<::prost::alloc::string::String>,
    /// If true, adult keywords will be included in response.
    /// The default value is false.
    #[prost(bool, tag = "5")]
    pub include_adult_keywords: bool,
    /// The resource names of the location to target. Maximum is 10.
    /// An empty list MAY be used to specify all targeting geos.
    #[prost(string, repeated, tag = "6")]
    pub geo_target_constants: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Targeting network.
    /// If not set, Google Search And Partners Network will be used.
    #[prost(
        enumeration = "super::enums::keyword_plan_network_enum::KeywordPlanNetwork",
        tag = "7"
    )]
    pub keyword_plan_network: i32,
    /// The aggregate fields to include in response.
    #[prost(message, optional, tag = "8")]
    pub aggregate_metrics: ::core::option::Option<
        super::common::KeywordPlanAggregateMetrics,
    >,
    /// The options for historical metrics data.
    #[prost(message, optional, tag = "3")]
    pub historical_metrics_options: ::core::option::Option<
        super::common::HistoricalMetricsOptions,
    >,
}
/// Response message for
/// [KeywordPlanIdeaService.GenerateKeywordHistoricalMetrics][google.ads.googleads.v16.services.KeywordPlanIdeaService.GenerateKeywordHistoricalMetrics].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenerateKeywordHistoricalMetricsResponse {
    /// List of keywords and their historical metrics.
    #[prost(message, repeated, tag = "1")]
    pub results: ::prost::alloc::vec::Vec<GenerateKeywordHistoricalMetricsResult>,
    /// The aggregate metrics for all keywords.
    #[prost(message, optional, tag = "2")]
    pub aggregate_metric_results: ::core::option::Option<
        super::common::KeywordPlanAggregateMetricResults,
    >,
}
/// The result of generating keyword historical metrics.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenerateKeywordHistoricalMetricsResult {
    /// The text of the query associated with one or more keywords.
    /// Note that we de-dupe your keywords list, eliminating close variants
    /// before returning the keywords as text. For example, if your request
    /// originally contained the keywords "car" and "cars", the returned search
    /// query will only contain "cars". The list of de-duped queries will be
    /// included in close_variants field.
    #[prost(string, optional, tag = "1")]
    pub text: ::core::option::Option<::prost::alloc::string::String>,
    /// The list of close variants from the requested keywords whose stats
    /// are combined into this GenerateKeywordHistoricalMetricsResult.
    #[prost(string, repeated, tag = "3")]
    pub close_variants: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// The historical metrics for text and its close variants
    #[prost(message, optional, tag = "2")]
    pub keyword_metrics: ::core::option::Option<
        super::common::KeywordPlanHistoricalMetrics,
    >,
}
/// Request message for
/// [KeywordPlanIdeaService.GenerateAdGroupThemes][google.ads.googleads.v16.services.KeywordPlanIdeaService.GenerateAdGroupThemes].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenerateAdGroupThemesRequest {
    /// Required. The ID of the customer.
    #[prost(string, tag = "1")]
    pub customer_id: ::prost::alloc::string::String,
    /// Required. A list of keywords to group into the provided AdGroups.
    #[prost(string, repeated, tag = "2")]
    pub keywords: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Required. A list of resource names of AdGroups to group keywords into.
    ///   Resource name format: `customers/{customer_id}/adGroups/{ad_group_id}`
    #[prost(string, repeated, tag = "3")]
    pub ad_groups: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Response message for
/// [KeywordPlanIdeaService.GenerateAdGroupThemes][google.ads.googleads.v16.services.KeywordPlanIdeaService.GenerateAdGroupThemes].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenerateAdGroupThemesResponse {
    /// A list of suggested AdGroup/keyword pairings.
    #[prost(message, repeated, tag = "1")]
    pub ad_group_keyword_suggestions: ::prost::alloc::vec::Vec<AdGroupKeywordSuggestion>,
    /// A list of provided AdGroups that could not be used as suggestions.
    #[prost(message, repeated, tag = "2")]
    pub unusable_ad_groups: ::prost::alloc::vec::Vec<UnusableAdGroup>,
}
/// The suggested text and AdGroup/Campaign pairing for a given keyword.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AdGroupKeywordSuggestion {
    /// The original keyword text.
    #[prost(string, tag = "1")]
    pub keyword_text: ::prost::alloc::string::String,
    /// The normalized version of keyword_text for BROAD/EXACT/PHRASE suggestions.
    #[prost(string, tag = "2")]
    pub suggested_keyword_text: ::prost::alloc::string::String,
    /// The suggested keyword match type.
    #[prost(
        enumeration = "super::enums::keyword_match_type_enum::KeywordMatchType",
        tag = "3"
    )]
    pub suggested_match_type: i32,
    /// The suggested AdGroup for the keyword.
    /// Resource name format: `customers/{customer_id}/adGroups/{ad_group_id}`
    #[prost(string, tag = "4")]
    pub suggested_ad_group: ::prost::alloc::string::String,
    /// The suggested Campaign for the keyword.
    /// Resource name format: `customers/{customer_id}/campaigns/{campaign_id}`
    #[prost(string, tag = "5")]
    pub suggested_campaign: ::prost::alloc::string::String,
}
/// An AdGroup/Campaign pair that could not be used as a suggestion for keywords.
///
/// AdGroups may not be usable if the AdGroup
///
/// * belongs to a Campaign that is not ENABLED or PAUSED
/// * is itself not ENABLED
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UnusableAdGroup {
    /// The AdGroup resource name.
    /// Resource name format: `customers/{customer_id}/adGroups/{ad_group_id}`
    #[prost(string, tag = "1")]
    pub ad_group: ::prost::alloc::string::String,
    /// The Campaign resource name.
    /// Resource name format: `customers/{customer_id}/campaigns/{campaign_id}`
    #[prost(string, tag = "2")]
    pub campaign: ::prost::alloc::string::String,
}
/// Request message for \[KeywordPlanIdeaService.GenerateKeywordForecastMetrics\].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenerateKeywordForecastMetricsRequest {
    /// The ID of the customer.
    #[prost(string, tag = "1")]
    pub customer_id: ::prost::alloc::string::String,
    /// The currency used for exchange rate conversion.
    /// By default, the account currency of the customer is used.
    /// Set this field only if the currency is different from the account currency.
    /// The list of valid currency codes can be found at
    /// <https://developers.google.com/google-ads/api/data/codes-formats#currency-codes.>
    #[prost(string, optional, tag = "2")]
    pub currency_code: ::core::option::Option<::prost::alloc::string::String>,
    /// The date range for the forecast. The start date must be in the future and
    /// end date must be within 1 year from today. The reference timezone used is
    /// the one of the Google Ads account belonging to the customer. If not set, a
    /// default date range from next Sunday to the following Saturday will be used.
    #[prost(message, optional, tag = "3")]
    pub forecast_period: ::core::option::Option<super::common::DateRange>,
    /// Required. The campaign used in the forecast.
    #[prost(message, optional, tag = "4")]
    pub campaign: ::core::option::Option<CampaignToForecast>,
}
/// A campaign to do a keyword campaign forecast.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CampaignToForecast {
    /// The list of resource names of languages to be targeted. The resource name
    /// is of the format "languageConstants/{criterion_id}". See
    /// <https://developers.google.com/google-ads/api/data/codes-formats#languages>
    /// for the list of language criterion codes.
    #[prost(string, repeated, tag = "1")]
    pub language_constants: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Locations to be targeted. Locations must be unique.
    #[prost(message, repeated, tag = "2")]
    pub geo_modifiers: ::prost::alloc::vec::Vec<CriterionBidModifier>,
    /// Required. The network used for targeting.
    #[prost(
        enumeration = "super::enums::keyword_plan_network_enum::KeywordPlanNetwork",
        tag = "3"
    )]
    pub keyword_plan_network: i32,
    /// The list of negative keywords to be used in the campaign when doing the
    /// forecast.
    #[prost(message, repeated, tag = "4")]
    pub negative_keywords: ::prost::alloc::vec::Vec<super::common::KeywordInfo>,
    /// Required. The bidding strategy for the campaign.
    #[prost(message, optional, tag = "5")]
    pub bidding_strategy: ::core::option::Option<
        campaign_to_forecast::CampaignBiddingStrategy,
    >,
    /// The expected conversion rate (number of conversions divided by number of
    /// total clicks) as defined by the user. This value is expressed as a decimal
    /// value, so an expected conversion rate of 2% should be entered as 0.02. If
    /// left empty, an estimated conversion rate will be used.
    #[prost(double, optional, tag = "6")]
    pub conversion_rate: ::core::option::Option<f64>,
    /// The ad groups in the new campaign to forecast.
    #[prost(message, repeated, tag = "7")]
    pub ad_groups: ::prost::alloc::vec::Vec<ForecastAdGroup>,
}
/// Nested message and enum types in `CampaignToForecast`.
pub mod campaign_to_forecast {
    /// Supported bidding strategies for new campaign forecasts.
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct CampaignBiddingStrategy {
        /// Bidding strategies.
        #[prost(oneof = "campaign_bidding_strategy::BiddingStrategy", tags = "1, 2, 3")]
        pub bidding_strategy: ::core::option::Option<
            campaign_bidding_strategy::BiddingStrategy,
        >,
    }
    /// Nested message and enum types in `CampaignBiddingStrategy`.
    pub mod campaign_bidding_strategy {
        /// Bidding strategies.
        #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
        pub enum BiddingStrategy {
            /// Use manual CPC bidding strategy for forecasting.
            #[prost(message, tag = "1")]
            ManualCpcBiddingStrategy(super::super::ManualCpcBiddingStrategy),
            /// Use maximize clicks bidding strategy for forecasting.
            #[prost(message, tag = "2")]
            MaximizeClicksBiddingStrategy(super::super::MaximizeClicksBiddingStrategy),
            /// Use maximize conversions bidding strategy for forecasting.
            #[prost(message, tag = "3")]
            MaximizeConversionsBiddingStrategy(
                super::super::MaximizeConversionsBiddingStrategy,
            ),
        }
    }
}
/// An ad group that is part of a campaign to be forecasted.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ForecastAdGroup {
    /// The max cpc to use for the ad group when generating forecasted traffic.
    /// This value will override the max cpc value set in the bidding strategy.
    /// Only specify this field for bidding strategies that max cpc values.
    #[prost(int64, optional, tag = "1")]
    pub max_cpc_bid_micros: ::core::option::Option<i64>,
    /// Required. The list of biddable keywords to be used in the ad group when
    /// doing the forecast. Requires at least one keyword.
    #[prost(message, repeated, tag = "2")]
    pub biddable_keywords: ::prost::alloc::vec::Vec<BiddableKeyword>,
    /// The details of the keyword. You should specify both the keyword text and
    /// match type.
    #[prost(message, repeated, tag = "3")]
    pub negative_keywords: ::prost::alloc::vec::Vec<super::common::KeywordInfo>,
}
/// A biddable keyword part of an ad group.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BiddableKeyword {
    /// Required. Keyword. Must have text and match type.
    #[prost(message, optional, tag = "1")]
    pub keyword: ::core::option::Option<super::common::KeywordInfo>,
    /// A max cpc bid in micros that overrides the ad group level max cpc bid in
    /// forecast simulation. This value will override the max cpc value set in the
    /// bidding strategy and ad group. Only specify this field for bidding
    /// strategies that support max cpc values.
    #[prost(int64, optional, tag = "2")]
    pub max_cpc_bid_micros: ::core::option::Option<i64>,
}
/// Location Criterion bid modifier.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CriterionBidModifier {
    /// The resource name of the geo location to target. The resource name is of
    /// the format "geoTargetConstants/{criterion_id}".
    #[prost(string, tag = "1")]
    pub geo_target_constant: ::prost::alloc::string::String,
    /// The associated multiplier for the criterion_id. If set, this value cannot
    /// be 0.
    #[prost(double, optional, tag = "2")]
    pub bid_modifier: ::core::option::Option<f64>,
}
/// Manual CPC Bidding Strategy.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ManualCpcBiddingStrategy {
    /// Campaign level budget in micros. If set, a minimum value
    /// is enforced for the local currency used in the campaign. An error
    /// will occur showing the minimum value if this field is set too low.
    #[prost(int64, optional, tag = "1")]
    pub daily_budget_micros: ::core::option::Option<i64>,
    /// Required. A bid in micros to be applied to ad groups within the campaign
    /// for a manual CPC bidding strategy.
    #[prost(int64, tag = "2")]
    pub max_cpc_bid_micros: i64,
}
/// Maximize Clicks Bidding Strategy.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MaximizeClicksBiddingStrategy {
    /// Required. The daily target spend in micros to be used for estimation. A
    /// minimum value is enforced for the local currency used in the campaign. An
    /// error will occur showing the minimum value if this field is set too low.
    #[prost(int64, tag = "1")]
    pub daily_target_spend_micros: i64,
    /// Ceiling on max CPC bids in micros.
    #[prost(int64, optional, tag = "2")]
    pub max_cpc_bid_ceiling_micros: ::core::option::Option<i64>,
}
/// Maximize Conversions Bidding Strategy.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MaximizeConversionsBiddingStrategy {
    /// Required. The daily target spend in micros to be used for estimation. This
    /// value must be greater than zero.
    #[prost(int64, tag = "1")]
    pub daily_target_spend_micros: i64,
}
/// Response message for \[KeywordPlanIdeaService.GenerateKeywordForecastMetrics\].
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GenerateKeywordForecastMetricsResponse {
    /// Results of the campaign forecast.
    #[prost(message, optional, tag = "1")]
    pub campaign_forecast_metrics: ::core::option::Option<KeywordForecastMetrics>,
}
/// The forecast metrics for the planless keyword campaign.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct KeywordForecastMetrics {
    /// The total number of impressions.
    #[prost(double, optional, tag = "1")]
    pub impressions: ::core::option::Option<f64>,
    /// The average click through rate. Available only if impressions > 0.
    #[prost(double, optional, tag = "2")]
    pub click_through_rate: ::core::option::Option<f64>,
    /// The average cpc. Available only if clicks > 0.
    #[prost(int64, optional, tag = "3")]
    pub average_cpc_micros: ::core::option::Option<i64>,
    /// The total number of clicks.
    #[prost(double, optional, tag = "4")]
    pub clicks: ::core::option::Option<f64>,
    /// The total cost.
    #[prost(int64, optional, tag = "5")]
    pub cost_micros: ::core::option::Option<i64>,
    /// Forecasted number of conversions: clicks * conversion_rate.
    #[prost(double, optional, tag = "6")]
    pub conversions: ::core::option::Option<f64>,
    /// Forecasted conversion rate.
    #[prost(double, optional, tag = "7")]
    pub conversion_rate: ::core::option::Option<f64>,
    /// Average cost per acquisition calculated as cost_micros / conversions.
    #[prost(int64, optional, tag = "8")]
    pub average_cpa_micros: ::core::option::Option<i64>,
}
/// Generated server implementations.
pub mod keyword_plan_idea_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with KeywordPlanIdeaServiceServer.
    #[async_trait]
    pub trait KeywordPlanIdeaService: std::marker::Send + std::marker::Sync + 'static {
        /// Returns a list of keyword ideas.
        ///
        /// List of thrown errors:
        ///   [AuthenticationError]()
        ///   [AuthorizationError]()
        ///   [CollectionSizeError]()
        ///   [HeaderError]()
        ///   [InternalError]()
        ///   [KeywordPlanIdeaError]()
        ///   [QuotaError]()
        ///   [RequestError]()
        async fn generate_keyword_ideas(
            &self,
            request: tonic::Request<super::GenerateKeywordIdeasRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GenerateKeywordIdeaResponse>,
            tonic::Status,
        >;
        /// Returns a list of keyword historical metrics.
        ///
        /// List of thrown errors:
        ///   [AuthenticationError]()
        ///   [AuthorizationError]()
        ///   [CollectionSizeError]()
        ///   [HeaderError]()
        ///   [InternalError]()
        ///   [QuotaError]()
        ///   [RequestError]()
        async fn generate_keyword_historical_metrics(
            &self,
            request: tonic::Request<super::GenerateKeywordHistoricalMetricsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GenerateKeywordHistoricalMetricsResponse>,
            tonic::Status,
        >;
        /// Returns a list of suggested AdGroups and suggested modifications
        /// (text, match type) for the given keywords.
        ///
        /// List of thrown errors:
        ///   [AuthenticationError]()
        ///   [AuthorizationError]()
        ///   [CollectionSizeError]()
        ///   [HeaderError]()
        ///   [InternalError]()
        ///   [QuotaError]()
        ///   [RequestError]()
        async fn generate_ad_group_themes(
            &self,
            request: tonic::Request<super::GenerateAdGroupThemesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GenerateAdGroupThemesResponse>,
            tonic::Status,
        >;
        /// Returns metrics (such as impressions, clicks, total cost) of a keyword
        /// forecast for the given campaign.
        ///
        /// List of thrown errors:
        ///   [AuthenticationError]()
        ///   [AuthorizationError]()
        ///   [CollectionSizeError]()
        ///   [HeaderError]()
        ///   [InternalError]()
        ///   [QuotaError]()
        ///   [RequestError]()
        async fn generate_keyword_forecast_metrics(
            &self,
            request: tonic::Request<super::GenerateKeywordForecastMetricsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GenerateKeywordForecastMetricsResponse>,
            tonic::Status,
        >;
    }
    /// Service to generate keyword ideas.
    #[derive(Debug)]
    pub struct KeywordPlanIdeaServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> KeywordPlanIdeaServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>>
    for KeywordPlanIdeaServiceServer<T>
    where
        T: KeywordPlanIdeaService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/google.ads.googleads.v16.services.KeywordPlanIdeaService/GenerateKeywordIdeas" => {
                    #[allow(non_camel_case_types)]
                    struct GenerateKeywordIdeasSvc<T: KeywordPlanIdeaService>(
                        pub Arc<T>,
                    );
                    impl<
                        T: KeywordPlanIdeaService,
                    > tonic::server::UnaryService<super::GenerateKeywordIdeasRequest>
                    for GenerateKeywordIdeasSvc<T> {
                        type Response = super::GenerateKeywordIdeaResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GenerateKeywordIdeasRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as KeywordPlanIdeaService>::generate_keyword_ideas(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GenerateKeywordIdeasSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.ads.googleads.v16.services.KeywordPlanIdeaService/GenerateKeywordHistoricalMetrics" => {
                    #[allow(non_camel_case_types)]
                    struct GenerateKeywordHistoricalMetricsSvc<
                        T: KeywordPlanIdeaService,
                    >(
                        pub Arc<T>,
                    );
                    impl<
                        T: KeywordPlanIdeaService,
                    > tonic::server::UnaryService<
                        super::GenerateKeywordHistoricalMetricsRequest,
                    > for GenerateKeywordHistoricalMetricsSvc<T> {
                        type Response = super::GenerateKeywordHistoricalMetricsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::GenerateKeywordHistoricalMetricsRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as KeywordPlanIdeaService>::generate_keyword_historical_metrics(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GenerateKeywordHistoricalMetricsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.ads.googleads.v16.services.KeywordPlanIdeaService/GenerateAdGroupThemes" => {
                    #[allow(non_camel_case_types)]
                    struct GenerateAdGroupThemesSvc<T: KeywordPlanIdeaService>(
                        pub Arc<T>,
                    );
                    impl<
                        T: KeywordPlanIdeaService,
                    > tonic::server::UnaryService<super::GenerateAdGroupThemesRequest>
                    for GenerateAdGroupThemesSvc<T> {
                        type Response = super::GenerateAdGroupThemesResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GenerateAdGroupThemesRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as KeywordPlanIdeaService>::generate_ad_group_themes(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GenerateAdGroupThemesSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.ads.googleads.v16.services.KeywordPlanIdeaService/GenerateKeywordForecastMetrics" => {
                    #[allow(non_camel_case_types)]
                    struct GenerateKeywordForecastMetricsSvc<T: KeywordPlanIdeaService>(
                        pub Arc<T>,
                    );
                    impl<
                        T: KeywordPlanIdeaService,
                    > tonic::server::UnaryService<
                        super::GenerateKeywordForecastMetricsRequest,
                    > for GenerateKeywordForecastMetricsSvc<T> {
                        type Response = super::GenerateKeywordForecastMetricsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::GenerateKeywordForecastMetricsRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as KeywordPlanIdeaService>::generate_keyword_forecast_metrics(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GenerateKeywordForecastMetricsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for KeywordPlanIdeaServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "google.ads.googleads.v16.services.KeywordPlanIdeaService";
    impl<T> tonic::server::NamedService for KeywordPlanIdeaServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Request message for
/// [KeywordThemeConstantService.SuggestKeywordThemeConstants][google.ads.googleads.v16.services.KeywordThemeConstantService.SuggestKeywordThemeConstants].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SuggestKeywordThemeConstantsRequest {
    /// The query text of a keyword theme that will be used to map to similar
    /// keyword themes. For example, "plumber" or "roofer".
    #[prost(string, tag = "1")]
    pub query_text: ::prost::alloc::string::String,
    /// Upper-case, two-letter country code as defined by ISO-3166. This for
    /// refining the scope of the query, default to 'US' if not set.
    #[prost(string, tag = "2")]
    pub country_code: ::prost::alloc::string::String,
    /// The two letter language code for get corresponding keyword theme for
    /// refining the scope of the query, default to 'en' if not set.
    #[prost(string, tag = "3")]
    pub language_code: ::prost::alloc::string::String,
}
/// Response message for
/// [KeywordThemeConstantService.SuggestKeywordThemeConstants][google.ads.googleads.v16.services.KeywordThemeConstantService.SuggestKeywordThemeConstants].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SuggestKeywordThemeConstantsResponse {
    /// Smart Campaign keyword theme suggestions.
    #[prost(message, repeated, tag = "1")]
    pub keyword_theme_constants: ::prost::alloc::vec::Vec<
        super::resources::KeywordThemeConstant,
    >,
}
/// Generated server implementations.
pub mod keyword_theme_constant_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with KeywordThemeConstantServiceServer.
    #[async_trait]
    pub trait KeywordThemeConstantService: std::marker::Send + std::marker::Sync + 'static {
        /// Returns KeywordThemeConstant suggestions by keyword themes.
        ///
        /// List of thrown errors:
        ///   [AuthenticationError]()
        ///   [AuthorizationError]()
        ///   [HeaderError]()
        ///   [InternalError]()
        ///   [QuotaError]()
        ///   [RequestError]()
        async fn suggest_keyword_theme_constants(
            &self,
            request: tonic::Request<super::SuggestKeywordThemeConstantsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SuggestKeywordThemeConstantsResponse>,
            tonic::Status,
        >;
    }
    /// Service to fetch Smart Campaign keyword themes.
    #[derive(Debug)]
    pub struct KeywordThemeConstantServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> KeywordThemeConstantServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>>
    for KeywordThemeConstantServiceServer<T>
    where
        T: KeywordThemeConstantService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/google.ads.googleads.v16.services.KeywordThemeConstantService/SuggestKeywordThemeConstants" => {
                    #[allow(non_camel_case_types)]
                    struct SuggestKeywordThemeConstantsSvc<
                        T: KeywordThemeConstantService,
                    >(
                        pub Arc<T>,
                    );
                    impl<
                        T: KeywordThemeConstantService,
                    > tonic::server::UnaryService<
                        super::SuggestKeywordThemeConstantsRequest,
                    > for SuggestKeywordThemeConstantsSvc<T> {
                        type Response = super::SuggestKeywordThemeConstantsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::SuggestKeywordThemeConstantsRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as KeywordThemeConstantService>::suggest_keyword_theme_constants(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SuggestKeywordThemeConstantsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for KeywordThemeConstantServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "google.ads.googleads.v16.services.KeywordThemeConstantService";
    impl<T> tonic::server::NamedService for KeywordThemeConstantServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Request message for
/// [OfflineUserDataJobService.CreateOfflineUserDataJob][google.ads.googleads.v16.services.OfflineUserDataJobService.CreateOfflineUserDataJob].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateOfflineUserDataJobRequest {
    /// Required. The ID of the customer for which to create an offline user data
    /// job.
    #[prost(string, tag = "1")]
    pub customer_id: ::prost::alloc::string::String,
    /// Required. The offline user data job to be created.
    #[prost(message, optional, tag = "2")]
    pub job: ::core::option::Option<super::resources::OfflineUserDataJob>,
    /// If true, the request is validated but not executed. Only errors are
    /// returned, not results.
    #[prost(bool, tag = "3")]
    pub validate_only: bool,
    /// If true, match rate range for the offline user data job is calculated and
    /// made available in the resource.
    #[prost(bool, tag = "5")]
    pub enable_match_rate_range_preview: bool,
}
/// Response message for
/// [OfflineUserDataJobService.CreateOfflineUserDataJob][google.ads.googleads.v16.services.OfflineUserDataJobService.CreateOfflineUserDataJob].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateOfflineUserDataJobResponse {
    /// The resource name of the OfflineUserDataJob.
    #[prost(string, tag = "1")]
    pub resource_name: ::prost::alloc::string::String,
}
/// Request message for
/// [OfflineUserDataJobService.RunOfflineUserDataJob][google.ads.googleads.v16.services.OfflineUserDataJobService.RunOfflineUserDataJob].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RunOfflineUserDataJobRequest {
    /// Required. The resource name of the OfflineUserDataJob to run.
    #[prost(string, tag = "1")]
    pub resource_name: ::prost::alloc::string::String,
    /// If true, the request is validated but not executed. Only errors are
    /// returned, not results.
    #[prost(bool, tag = "2")]
    pub validate_only: bool,
}
/// Request message for
/// [OfflineUserDataJobService.AddOfflineUserDataJobOperations][google.ads.googleads.v16.services.OfflineUserDataJobService.AddOfflineUserDataJobOperations].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AddOfflineUserDataJobOperationsRequest {
    /// Required. The resource name of the OfflineUserDataJob.
    #[prost(string, tag = "1")]
    pub resource_name: ::prost::alloc::string::String,
    /// True to enable partial failure for the offline user data job.
    #[prost(bool, optional, tag = "4")]
    pub enable_partial_failure: ::core::option::Option<bool>,
    /// True to enable warnings for the offline user data job. When enabled, a
    /// warning will not block the OfflineUserDataJobOperation, and will also
    /// return warning messages about malformed field values.
    #[prost(bool, optional, tag = "6")]
    pub enable_warnings: ::core::option::Option<bool>,
    /// Required. The list of operations to be done.
    #[prost(message, repeated, tag = "3")]
    pub operations: ::prost::alloc::vec::Vec<OfflineUserDataJobOperation>,
    /// If true, the request is validated but not executed. Only errors are
    /// returned, not results.
    #[prost(bool, tag = "5")]
    pub validate_only: bool,
}
/// Operation to be made for the AddOfflineUserDataJobOperationsRequest.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OfflineUserDataJobOperation {
    /// Operation to be made for the AddOfflineUserDataJobOperationsRequest.
    #[prost(oneof = "offline_user_data_job_operation::Operation", tags = "1, 2, 3")]
    pub operation: ::core::option::Option<offline_user_data_job_operation::Operation>,
}
/// Nested message and enum types in `OfflineUserDataJobOperation`.
pub mod offline_user_data_job_operation {
    /// Operation to be made for the AddOfflineUserDataJobOperationsRequest.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Operation {
        /// Add the provided data to the transaction. Data cannot be retrieved after
        /// being uploaded.
        #[prost(message, tag = "1")]
        Create(super::super::common::UserData),
        /// Remove the provided data from the transaction. Data cannot be retrieved
        /// after being uploaded.
        #[prost(message, tag = "2")]
        Remove(super::super::common::UserData),
        /// Remove all previously provided data. This is only supported for Customer
        /// Match.
        #[prost(bool, tag = "3")]
        RemoveAll(bool),
    }
}
/// Response message for
/// [OfflineUserDataJobService.AddOfflineUserDataJobOperations][google.ads.googleads.v16.services.OfflineUserDataJobService.AddOfflineUserDataJobOperations].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AddOfflineUserDataJobOperationsResponse {
    /// Errors that pertain to operation failures in the partial failure mode.
    /// Returned only when partial_failure = true and all errors occur inside the
    /// operations. If any errors occur outside the operations (for example, auth
    /// errors), we return an RPC level error.
    #[prost(message, optional, tag = "1")]
    pub partial_failure_error: ::core::option::Option<
        super::super::super::super::rpc::Status,
    >,
    /// Non blocking errors that pertain to operation failures in the warnings
    /// mode. Returned only when enable_warnings = true.
    #[prost(message, optional, tag = "2")]
    pub warning: ::core::option::Option<super::super::super::super::rpc::Status>,
}
/// Generated server implementations.
pub mod offline_user_data_job_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with OfflineUserDataJobServiceServer.
    #[async_trait]
    pub trait OfflineUserDataJobService: std::marker::Send + std::marker::Sync + 'static {
        /// Creates an offline user data job.
        ///
        /// List of thrown errors:
        ///   [AuthenticationError]()
        ///   [AuthorizationError]()
        ///   [DatabaseError]()
        ///   [FieldError]()
        ///   [HeaderError]()
        ///   [InternalError]()
        ///   [NotAllowlistedError]()
        ///   [OfflineUserDataJobError]()
        ///   [QuotaError]()
        ///   [RequestError]()
        async fn create_offline_user_data_job(
            &self,
            request: tonic::Request<super::CreateOfflineUserDataJobRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CreateOfflineUserDataJobResponse>,
            tonic::Status,
        >;
        /// Adds operations to the offline user data job.
        ///
        /// List of thrown errors:
        ///   [AuthenticationError]()
        ///   [AuthorizationError]()
        ///   [DatabaseError]()
        ///   [FieldError]()
        ///   [HeaderError]()
        ///   [InternalError]()
        ///   [MutateError]()
        ///   [OfflineUserDataJobError]()
        ///   [QuotaError]()
        ///   [RequestError]()
        async fn add_offline_user_data_job_operations(
            &self,
            request: tonic::Request<super::AddOfflineUserDataJobOperationsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::AddOfflineUserDataJobOperationsResponse>,
            tonic::Status,
        >;
        /// Runs the offline user data job.
        ///
        /// When finished, the long running operation will contain the processing
        /// result or failure information, if any.
        ///
        /// List of thrown errors:
        ///   [AuthenticationError]()
        ///   [AuthorizationError]()
        ///   [DatabaseError]()
        ///   [HeaderError]()
        ///   [InternalError]()
        ///   [OfflineUserDataJobError]()
        ///   [QuotaError]()
        ///   [RequestError]()
        async fn run_offline_user_data_job(
            &self,
            request: tonic::Request<super::RunOfflineUserDataJobRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::super::longrunning::Operation>,
            tonic::Status,
        >;
    }
    /// Service to manage offline user data jobs.
    #[derive(Debug)]
    pub struct OfflineUserDataJobServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> OfflineUserDataJobServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>>
    for OfflineUserDataJobServiceServer<T>
    where
        T: OfflineUserDataJobService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/google.ads.googleads.v16.services.OfflineUserDataJobService/CreateOfflineUserDataJob" => {
                    #[allow(non_camel_case_types)]
                    struct CreateOfflineUserDataJobSvc<T: OfflineUserDataJobService>(
                        pub Arc<T>,
                    );
                    impl<
                        T: OfflineUserDataJobService,
                    > tonic::server::UnaryService<super::CreateOfflineUserDataJobRequest>
                    for CreateOfflineUserDataJobSvc<T> {
                        type Response = super::CreateOfflineUserDataJobResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::CreateOfflineUserDataJobRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as OfflineUserDataJobService>::create_offline_user_data_job(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = CreateOfflineUserDataJobSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.ads.googleads.v16.services.OfflineUserDataJobService/AddOfflineUserDataJobOperations" => {
                    #[allow(non_camel_case_types)]
                    struct AddOfflineUserDataJobOperationsSvc<
                        T: OfflineUserDataJobService,
                    >(
                        pub Arc<T>,
                    );
                    impl<
                        T: OfflineUserDataJobService,
                    > tonic::server::UnaryService<
                        super::AddOfflineUserDataJobOperationsRequest,
                    > for AddOfflineUserDataJobOperationsSvc<T> {
                        type Response = super::AddOfflineUserDataJobOperationsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::AddOfflineUserDataJobOperationsRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as OfflineUserDataJobService>::add_offline_user_data_job_operations(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = AddOfflineUserDataJobOperationsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.ads.googleads.v16.services.OfflineUserDataJobService/RunOfflineUserDataJob" => {
                    #[allow(non_camel_case_types)]
                    struct RunOfflineUserDataJobSvc<T: OfflineUserDataJobService>(
                        pub Arc<T>,
                    );
                    impl<
                        T: OfflineUserDataJobService,
                    > tonic::server::UnaryService<super::RunOfflineUserDataJobRequest>
                    for RunOfflineUserDataJobSvc<T> {
                        type Response = super::super::super::super::super::longrunning::Operation;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::RunOfflineUserDataJobRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as OfflineUserDataJobService>::run_offline_user_data_job(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = RunOfflineUserDataJobSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for OfflineUserDataJobServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "google.ads.googleads.v16.services.OfflineUserDataJobService";
    impl<T> tonic::server::NamedService for OfflineUserDataJobServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Request message for fetching all accessible payments accounts.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListPaymentsAccountsRequest {
    /// Required. The ID of the customer to apply the PaymentsAccount list
    /// operation to.
    #[prost(string, tag = "1")]
    pub customer_id: ::prost::alloc::string::String,
}
/// Response message for
/// [PaymentsAccountService.ListPaymentsAccounts][google.ads.googleads.v16.services.PaymentsAccountService.ListPaymentsAccounts].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListPaymentsAccountsResponse {
    /// The list of accessible payments accounts.
    #[prost(message, repeated, tag = "1")]
    pub payments_accounts: ::prost::alloc::vec::Vec<super::resources::PaymentsAccount>,
}
/// Generated server implementations.
pub mod payments_account_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with PaymentsAccountServiceServer.
    #[async_trait]
    pub trait PaymentsAccountService: std::marker::Send + std::marker::Sync + 'static {
        /// Returns all payments accounts associated with all managers
        /// between the login customer ID and specified serving customer in the
        /// hierarchy, inclusive.
        ///
        /// List of thrown errors:
        ///   [AuthenticationError]()
        ///   [AuthorizationError]()
        ///   [HeaderError]()
        ///   [InternalError]()
        ///   [PaymentsAccountError]()
        ///   [QuotaError]()
        ///   [RequestError]()
        async fn list_payments_accounts(
            &self,
            request: tonic::Request<super::ListPaymentsAccountsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListPaymentsAccountsResponse>,
            tonic::Status,
        >;
    }
    /// Service to provide payments accounts that can be used to set up consolidated
    /// billing.
    #[derive(Debug)]
    pub struct PaymentsAccountServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> PaymentsAccountServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>>
    for PaymentsAccountServiceServer<T>
    where
        T: PaymentsAccountService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/google.ads.googleads.v16.services.PaymentsAccountService/ListPaymentsAccounts" => {
                    #[allow(non_camel_case_types)]
                    struct ListPaymentsAccountsSvc<T: PaymentsAccountService>(
                        pub Arc<T>,
                    );
                    impl<
                        T: PaymentsAccountService,
                    > tonic::server::UnaryService<super::ListPaymentsAccountsRequest>
                    for ListPaymentsAccountsSvc<T> {
                        type Response = super::ListPaymentsAccountsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ListPaymentsAccountsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as PaymentsAccountService>::list_payments_accounts(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ListPaymentsAccountsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for PaymentsAccountServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "google.ads.googleads.v16.services.PaymentsAccountService";
    impl<T> tonic::server::NamedService for PaymentsAccountServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Request message for
/// [ProductLinkInvitationService.CreateProductLinkInvitation][google.ads.googleads.v16.services.ProductLinkInvitationService.CreateProductLinkInvitation].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateProductLinkInvitationRequest {
    /// Required. The ID of the customer being modified.
    #[prost(string, tag = "1")]
    pub customer_id: ::prost::alloc::string::String,
    /// Required. The product link invitation to be created.
    #[prost(message, optional, tag = "2")]
    pub product_link_invitation: ::core::option::Option<
        super::resources::ProductLinkInvitation,
    >,
}
/// Response message for product link invitation create.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateProductLinkInvitationResponse {
    /// Resource name of the product link invitation.
    #[prost(string, tag = "1")]
    pub resource_name: ::prost::alloc::string::String,
}
/// Request message for
/// [ProductLinkInvitationService.UpdateProductLinkInvitation][google.ads.googleads.v16.services.ProductLinkInvitationService.UpdateProductLinkInvitation].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateProductLinkInvitationRequest {
    /// Required. The ID of the customer being modified.
    #[prost(string, tag = "1")]
    pub customer_id: ::prost::alloc::string::String,
    /// Required. The product link invitation to be created.
    #[prost(
        enumeration = "super::enums::product_link_invitation_status_enum::ProductLinkInvitationStatus",
        tag = "2"
    )]
    pub product_link_invitation_status: i32,
    /// Required. Resource name of the product link invitation.
    #[prost(string, tag = "3")]
    pub resource_name: ::prost::alloc::string::String,
}
/// Response message for product link invitation update.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateProductLinkInvitationResponse {
    /// Result of the update.
    #[prost(string, tag = "1")]
    pub resource_name: ::prost::alloc::string::String,
}
/// Request message for
/// [ProductLinkinvitationService.RemoveProductLinkInvitation][].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RemoveProductLinkInvitationRequest {
    /// Required. The ID of the product link invitation being removed.
    #[prost(string, tag = "1")]
    pub customer_id: ::prost::alloc::string::String,
    /// Required. The resource name of the product link invitation being removed.
    /// expected, in this format:
    ///
    /// ` `
    #[prost(string, tag = "2")]
    pub resource_name: ::prost::alloc::string::String,
}
/// Response message for product link invitation removeal.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RemoveProductLinkInvitationResponse {
    /// Result for the remove request.
    #[prost(string, tag = "1")]
    pub resource_name: ::prost::alloc::string::String,
}
/// Generated server implementations.
pub mod product_link_invitation_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with ProductLinkInvitationServiceServer.
    #[async_trait]
    pub trait ProductLinkInvitationService: std::marker::Send + std::marker::Sync + 'static {
        /// Creates a product link invitation.
        async fn create_product_link_invitation(
            &self,
            request: tonic::Request<super::CreateProductLinkInvitationRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CreateProductLinkInvitationResponse>,
            tonic::Status,
        >;
        /// Update a product link invitation.
        async fn update_product_link_invitation(
            &self,
            request: tonic::Request<super::UpdateProductLinkInvitationRequest>,
        ) -> std::result::Result<
            tonic::Response<super::UpdateProductLinkInvitationResponse>,
            tonic::Status,
        >;
        /// Remove a product link invitation.
        async fn remove_product_link_invitation(
            &self,
            request: tonic::Request<super::RemoveProductLinkInvitationRequest>,
        ) -> std::result::Result<
            tonic::Response<super::RemoveProductLinkInvitationResponse>,
            tonic::Status,
        >;
    }
    /// This service allows management of product link invitations from Google Ads
    /// accounts to other accounts.
    #[derive(Debug)]
    pub struct ProductLinkInvitationServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> ProductLinkInvitationServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>>
    for ProductLinkInvitationServiceServer<T>
    where
        T: ProductLinkInvitationService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/google.ads.googleads.v16.services.ProductLinkInvitationService/CreateProductLinkInvitation" => {
                    #[allow(non_camel_case_types)]
                    struct CreateProductLinkInvitationSvc<
                        T: ProductLinkInvitationService,
                    >(
                        pub Arc<T>,
                    );
                    impl<
                        T: ProductLinkInvitationService,
                    > tonic::server::UnaryService<
                        super::CreateProductLinkInvitationRequest,
                    > for CreateProductLinkInvitationSvc<T> {
                        type Response = super::CreateProductLinkInvitationResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::CreateProductLinkInvitationRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProductLinkInvitationService>::create_product_link_invitation(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = CreateProductLinkInvitationSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.ads.googleads.v16.services.ProductLinkInvitationService/UpdateProductLinkInvitation" => {
                    #[allow(non_camel_case_types)]
                    struct UpdateProductLinkInvitationSvc<
                        T: ProductLinkInvitationService,
                    >(
                        pub Arc<T>,
                    );
                    impl<
                        T: ProductLinkInvitationService,
                    > tonic::server::UnaryService<
                        super::UpdateProductLinkInvitationRequest,
                    > for UpdateProductLinkInvitationSvc<T> {
                        type Response = super::UpdateProductLinkInvitationResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::UpdateProductLinkInvitationRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProductLinkInvitationService>::update_product_link_invitation(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = UpdateProductLinkInvitationSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.ads.googleads.v16.services.ProductLinkInvitationService/RemoveProductLinkInvitation" => {
                    #[allow(non_camel_case_types)]
                    struct RemoveProductLinkInvitationSvc<
                        T: ProductLinkInvitationService,
                    >(
                        pub Arc<T>,
                    );
                    impl<
                        T: ProductLinkInvitationService,
                    > tonic::server::UnaryService<
                        super::RemoveProductLinkInvitationRequest,
                    > for RemoveProductLinkInvitationSvc<T> {
                        type Response = super::RemoveProductLinkInvitationResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::RemoveProductLinkInvitationRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProductLinkInvitationService>::remove_product_link_invitation(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = RemoveProductLinkInvitationSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for ProductLinkInvitationServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "google.ads.googleads.v16.services.ProductLinkInvitationService";
    impl<T> tonic::server::NamedService for ProductLinkInvitationServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Request message for
/// [ProductLinkService.CreateProductLink][google.ads.googleads.v16.services.ProductLinkService.CreateProductLink].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateProductLinkRequest {
    /// Required. The ID of the customer for which the product link is created.
    #[prost(string, tag = "1")]
    pub customer_id: ::prost::alloc::string::String,
    /// Required. The product link to be created.
    #[prost(message, optional, tag = "2")]
    pub product_link: ::core::option::Option<super::resources::ProductLink>,
}
/// Response message for
/// [ProductLinkService.CreateProductLink][google.ads.googleads.v16.services.ProductLinkService.CreateProductLink].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateProductLinkResponse {
    /// Returned for successful operations. Resource name of the product link.
    #[prost(string, tag = "1")]
    pub resource_name: ::prost::alloc::string::String,
}
/// Request message for
/// [ProductLinkService.RemoveProductLink][google.ads.googleads.v16.services.ProductLinkService.RemoveProductLink].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RemoveProductLinkRequest {
    /// Required. The ID of the customer being modified.
    #[prost(string, tag = "1")]
    pub customer_id: ::prost::alloc::string::String,
    /// Required. Remove operation: A resource name for the product link to remove
    /// is expected, in this format:
    ///
    /// `customers/{customer_id}/productLinks/{product_link_id} `
    #[prost(string, tag = "2")]
    pub resource_name: ::prost::alloc::string::String,
    /// If true, the request is validated but not executed. Only errors are
    /// returned, not results.
    #[prost(bool, tag = "3")]
    pub validate_only: bool,
}
/// Response message for product link removal.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RemoveProductLinkResponse {
    /// Result for the remove request.
    #[prost(string, tag = "1")]
    pub resource_name: ::prost::alloc::string::String,
}
/// Generated server implementations.
pub mod product_link_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with ProductLinkServiceServer.
    #[async_trait]
    pub trait ProductLinkService: std::marker::Send + std::marker::Sync + 'static {
        /// Creates a product link.
        ///
        /// List of thrown errors:
        ///   [AuthenticationError]()
        ///   [AuthorizationError]()
        ///   [DatabaseError]()
        ///   [FieldError]()
        ///   [HeaderError]()
        ///   [InternalError]()
        ///   [MutateError]()
        ///   [QuotaError]()
        ///   [RequestError]()
        async fn create_product_link(
            &self,
            request: tonic::Request<super::CreateProductLinkRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CreateProductLinkResponse>,
            tonic::Status,
        >;
        /// Removes a product link.
        ///
        /// List of thrown errors:
        ///   [AuthenticationError]()
        ///   [AuthorizationError]()
        ///   [FieldMaskError]()
        ///   [HeaderError]()
        ///   [InternalError]()
        ///   [MutateError]()
        ///   [QuotaError]()
        ///   [RequestError]()
        async fn remove_product_link(
            &self,
            request: tonic::Request<super::RemoveProductLinkRequest>,
        ) -> std::result::Result<
            tonic::Response<super::RemoveProductLinkResponse>,
            tonic::Status,
        >;
    }
    /// This service allows management of links between  a Google
    /// Ads customer and another product.
    #[derive(Debug)]
    pub struct ProductLinkServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> ProductLinkServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for ProductLinkServiceServer<T>
    where
        T: ProductLinkService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/google.ads.googleads.v16.services.ProductLinkService/CreateProductLink" => {
                    #[allow(non_camel_case_types)]
                    struct CreateProductLinkSvc<T: ProductLinkService>(pub Arc<T>);
                    impl<
                        T: ProductLinkService,
                    > tonic::server::UnaryService<super::CreateProductLinkRequest>
                    for CreateProductLinkSvc<T> {
                        type Response = super::CreateProductLinkResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::CreateProductLinkRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProductLinkService>::create_product_link(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = CreateProductLinkSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.ads.googleads.v16.services.ProductLinkService/RemoveProductLink" => {
                    #[allow(non_camel_case_types)]
                    struct RemoveProductLinkSvc<T: ProductLinkService>(pub Arc<T>);
                    impl<
                        T: ProductLinkService,
                    > tonic::server::UnaryService<super::RemoveProductLinkRequest>
                    for RemoveProductLinkSvc<T> {
                        type Response = super::RemoveProductLinkResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::RemoveProductLinkRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProductLinkService>::remove_product_link(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = RemoveProductLinkSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for ProductLinkServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "google.ads.googleads.v16.services.ProductLinkService";
    impl<T> tonic::server::NamedService for ProductLinkServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Request message for
/// [ReachPlanService.ListPlannableLocations][google.ads.googleads.v16.services.ReachPlanService.ListPlannableLocations].
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ListPlannableLocationsRequest {}
/// The list of plannable locations.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListPlannableLocationsResponse {
    /// The list of locations available for planning.
    /// See
    /// <https://developers.google.com/google-ads/api/reference/data/geotargets>
    /// for sample locations.
    #[prost(message, repeated, tag = "1")]
    pub plannable_locations: ::prost::alloc::vec::Vec<PlannableLocation>,
}
/// A plannable location: country, metro region, province, etc.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlannableLocation {
    /// The location identifier.
    #[prost(string, optional, tag = "4")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
    /// The unique location name in English.
    #[prost(string, optional, tag = "5")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    /// The parent country (not present if location is a country).
    /// If present, will always be a GeoTargetConstant ID. Additional information
    /// such as country name is provided by
    /// [ReachPlanService.ListPlannableLocations][google.ads.googleads.v16.services.ReachPlanService.ListPlannableLocations]
    /// or GoogleAdsService.Search/SearchStream.
    #[prost(int64, optional, tag = "6")]
    pub parent_country_id: ::core::option::Option<i64>,
    /// The ISO-3166-1 alpha-2 country code that is associated with the location.
    #[prost(string, optional, tag = "7")]
    pub country_code: ::core::option::Option<::prost::alloc::string::String>,
    /// The location's type. Location types correspond to target_type returned by
    /// searching location type in GoogleAdsService.Search/SearchStream.
    #[prost(string, optional, tag = "8")]
    pub location_type: ::core::option::Option<::prost::alloc::string::String>,
}
/// Request to list available products in a given location.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListPlannableProductsRequest {
    /// Required. The ID of the selected location for planning. To list the
    /// available plannable location IDs use
    /// [ReachPlanService.ListPlannableLocations][google.ads.googleads.v16.services.ReachPlanService.ListPlannableLocations].
    #[prost(string, tag = "2")]
    pub plannable_location_id: ::prost::alloc::string::String,
}
/// A response with all available products.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListPlannableProductsResponse {
    /// The list of products available for planning and related targeting metadata.
    #[prost(message, repeated, tag = "1")]
    pub product_metadata: ::prost::alloc::vec::Vec<ProductMetadata>,
}
/// The metadata associated with an available plannable product.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProductMetadata {
    /// The code associated with the ad product (for example: BUMPER,
    /// TRUEVIEW_IN_STREAM).
    /// To list the available plannable product codes use
    /// [ReachPlanService.ListPlannableProducts][google.ads.googleads.v16.services.ReachPlanService.ListPlannableProducts].
    #[prost(string, optional, tag = "4")]
    pub plannable_product_code: ::core::option::Option<::prost::alloc::string::String>,
    /// The name associated with the ad product.
    #[prost(string, tag = "3")]
    pub plannable_product_name: ::prost::alloc::string::String,
    /// The allowed plannable targeting for this product.
    #[prost(message, optional, tag = "2")]
    pub plannable_targeting: ::core::option::Option<PlannableTargeting>,
}
/// The targeting for which traffic metrics will be reported.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlannableTargeting {
    /// Allowed plannable age ranges for the product for which metrics will be
    /// reported. Actual targeting is computed by mapping this age range onto
    /// standard Google common.AgeRangeInfo values.
    #[prost(
        enumeration = "super::enums::reach_plan_age_range_enum::ReachPlanAgeRange",
        repeated,
        tag = "1"
    )]
    pub age_ranges: ::prost::alloc::vec::Vec<i32>,
    /// Targetable genders for the ad product.
    #[prost(message, repeated, tag = "2")]
    pub genders: ::prost::alloc::vec::Vec<super::common::GenderInfo>,
    /// Targetable devices for the ad product.
    /// TABLET device targeting is automatically applied to reported metrics
    /// when MOBILE targeting is selected for CPM_MASTHEAD,
    /// GOOGLE_PREFERRED_BUMPER, and GOOGLE_PREFERRED_SHORT products.
    #[prost(message, repeated, tag = "3")]
    pub devices: ::prost::alloc::vec::Vec<super::common::DeviceInfo>,
    /// Targetable networks for the ad product.
    #[prost(
        enumeration = "super::enums::reach_plan_network_enum::ReachPlanNetwork",
        repeated,
        tag = "4"
    )]
    pub networks: ::prost::alloc::vec::Vec<i32>,
    /// Targetable YouTube Select Lineups for the ad product.
    #[prost(message, repeated, tag = "5")]
    pub youtube_select_lineups: ::prost::alloc::vec::Vec<YouTubeSelectLineUp>,
    /// Targetable surface combinations for the ad product.
    #[prost(message, optional, tag = "6")]
    pub surface_targeting: ::core::option::Option<SurfaceTargetingCombinations>,
}
/// Request message for
/// [ReachPlanService.GenerateReachForecast][google.ads.googleads.v16.services.ReachPlanService.GenerateReachForecast].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenerateReachForecastRequest {
    /// Required. The ID of the customer.
    #[prost(string, tag = "1")]
    pub customer_id: ::prost::alloc::string::String,
    /// The currency code.
    /// Three-character ISO 4217 currency code.
    #[prost(string, optional, tag = "9")]
    pub currency_code: ::core::option::Option<::prost::alloc::string::String>,
    /// Required. Campaign duration.
    #[prost(message, optional, tag = "3")]
    pub campaign_duration: ::core::option::Option<CampaignDuration>,
    /// Chosen cookie frequency cap to be applied to each planned product.
    /// This is equivalent to the frequency cap exposed in Google Ads when creating
    /// a campaign, it represents the maximum number of times an ad can be shown to
    /// the same user.
    /// If not specified, no cap is applied.
    ///
    /// This field is deprecated in v4 and will eventually be removed.
    /// Use cookie_frequency_cap_setting instead.
    #[prost(int32, optional, tag = "10")]
    pub cookie_frequency_cap: ::core::option::Option<i32>,
    /// Chosen cookie frequency cap to be applied to each planned product.
    /// This is equivalent to the frequency cap exposed in Google Ads when creating
    /// a campaign, it represents the maximum number of times an ad can be shown to
    /// the same user during a specified time interval.
    /// If not specified, a default of 0 (no cap) is applied.
    ///
    /// This field replaces the deprecated cookie_frequency_cap field.
    #[prost(message, optional, tag = "8")]
    pub cookie_frequency_cap_setting: ::core::option::Option<FrequencyCap>,
    /// Chosen minimum effective frequency (the number of times a person was
    /// exposed to the ad) for the reported reach metrics \[1-10\].
    /// This won't affect the targeting, but just the reporting.
    /// If not specified, a default of 1 is applied.
    ///
    /// This field cannot be combined with the effective_frequency_limit field.
    #[prost(int32, optional, tag = "11")]
    pub min_effective_frequency: ::core::option::Option<i32>,
    /// The highest minimum effective frequency (the number of times a person was
    /// exposed to the ad) value \[1-10\] to include in
    /// Forecast.effective_frequency_breakdowns.
    /// If not specified, Forecast.effective_frequency_breakdowns will not be
    /// provided.
    ///
    /// The effective frequency value provided here will also be used as the
    /// minimum effective frequency for the reported reach metrics.
    ///
    /// This field cannot be combined with the min_effective_frequency field.
    #[prost(message, optional, tag = "12")]
    pub effective_frequency_limit: ::core::option::Option<EffectiveFrequencyLimit>,
    /// The targeting to be applied to all products selected in the product mix.
    ///
    /// This is planned targeting: execution details might vary based on the
    /// advertising product, consult an implementation specialist.
    ///
    /// See specific metrics for details on how targeting affects them.
    #[prost(message, optional, tag = "6")]
    pub targeting: ::core::option::Option<Targeting>,
    /// Required. The products to be forecast.
    /// The max number of allowed planned products is 15.
    #[prost(message, repeated, tag = "7")]
    pub planned_products: ::prost::alloc::vec::Vec<PlannedProduct>,
    /// Controls the forecast metrics returned in the response.
    #[prost(message, optional, tag = "13")]
    pub forecast_metric_options: ::core::option::Option<ForecastMetricOptions>,
    /// The name of the customer being planned for. This is a user-defined value.
    #[prost(string, optional, tag = "14")]
    pub customer_reach_group: ::core::option::Option<::prost::alloc::string::String>,
}
/// Effective frequency limit.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EffectiveFrequencyLimit {
    /// The highest effective frequency value to include in
    /// Forecast.effective_frequency_breakdowns.
    /// This field supports frequencies 1-10, inclusive.
    #[prost(int32, tag = "1")]
    pub effective_frequency_breakdown_limit: i32,
}
/// A rule specifying the maximum number of times an ad can be shown to a user
/// over a particular time period.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FrequencyCap {
    /// Required. The number of impressions, inclusive.
    #[prost(int32, tag = "3")]
    pub impressions: i32,
    /// Required. The type of time unit.
    #[prost(
        enumeration = "super::enums::frequency_cap_time_unit_enum::FrequencyCapTimeUnit",
        tag = "2"
    )]
    pub time_unit: i32,
}
/// The targeting for which traffic metrics will be reported.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Targeting {
    /// The ID of the selected location. Plannable location IDs can be
    /// obtained from
    /// [ReachPlanService.ListPlannableLocations][google.ads.googleads.v16.services.ReachPlanService.ListPlannableLocations].
    ///
    /// Requests must set either this field or `plannable_location_ids`.
    ///
    /// This field is deprecated as of V12 and will be removed in a future release.
    /// Use `plannable_location_ids` instead.
    #[prost(string, optional, tag = "6")]
    pub plannable_location_id: ::core::option::Option<::prost::alloc::string::String>,
    /// The list of plannable location IDs to target with this forecast.
    ///
    /// If more than one ID is provided, all IDs must have the same
    /// `parent_country_id`. Planning for more than `parent_county` is not
    /// supported. Plannable location IDs and their `parent_country_id` can be
    /// obtained from
    /// [ReachPlanService.ListPlannableLocations][google.ads.googleads.v16.services.ReachPlanService.ListPlannableLocations].
    ///
    /// Requests must set either this field or `plannable_location_id`.
    #[prost(string, repeated, tag = "8")]
    pub plannable_location_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Targeted age range.
    /// An unset value is equivalent to targeting all ages.
    #[prost(
        enumeration = "super::enums::reach_plan_age_range_enum::ReachPlanAgeRange",
        tag = "2"
    )]
    pub age_range: i32,
    /// Targeted genders.
    /// An unset value is equivalent to targeting MALE and FEMALE.
    #[prost(message, repeated, tag = "3")]
    pub genders: ::prost::alloc::vec::Vec<super::common::GenderInfo>,
    /// Targeted devices.
    /// If not specified, targets all applicable devices. Applicable devices vary
    /// by product and region and can be obtained from
    /// [ReachPlanService.ListPlannableProducts][google.ads.googleads.v16.services.ReachPlanService.ListPlannableProducts].
    #[prost(message, repeated, tag = "4")]
    pub devices: ::prost::alloc::vec::Vec<super::common::DeviceInfo>,
    /// Targetable network for the ad product.
    /// If not specified, targets all applicable networks. Applicable networks vary
    /// by product and region and can be obtained from
    /// [ReachPlanService.ListPlannableProducts][google.ads.googleads.v16.services.ReachPlanService.ListPlannableProducts].
    #[prost(
        enumeration = "super::enums::reach_plan_network_enum::ReachPlanNetwork",
        tag = "5"
    )]
    pub network: i32,
    /// Targeted audiences.
    /// If not specified, does not target any specific audience.
    #[prost(message, optional, tag = "7")]
    pub audience_targeting: ::core::option::Option<AudienceTargeting>,
}
/// The duration of a planned campaign.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CampaignDuration {
    /// The duration value in days.
    ///
    /// This field cannot be combined with the date_range field.
    #[prost(int32, optional, tag = "2")]
    pub duration_in_days: ::core::option::Option<i32>,
    /// Date range of the campaign.
    /// Dates are in the yyyy-mm-dd format and inclusive.
    /// The end date must be < 1 year in the future and the
    /// date range must be <= 92 days long.
    ///
    /// This field cannot be combined with the duration_in_days field.
    #[prost(message, optional, tag = "3")]
    pub date_range: ::core::option::Option<super::common::DateRange>,
}
/// A product being planned for reach.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlannedProduct {
    /// Required. Selected product for planning.
    /// The code associated with the ad product (for example: Trueview, Bumper).
    /// To list the available plannable product codes use
    /// [ReachPlanService.ListPlannableProducts][google.ads.googleads.v16.services.ReachPlanService.ListPlannableProducts].
    #[prost(string, optional, tag = "3")]
    pub plannable_product_code: ::core::option::Option<::prost::alloc::string::String>,
    /// Required. Maximum budget allocation in micros for the selected product.
    /// The value is specified in the selected planning currency_code.
    /// For example: 1 000 000$ = 1 000 000 000 000 micros.
    #[prost(int64, optional, tag = "4")]
    pub budget_micros: ::core::option::Option<i64>,
    /// Targeting settings for the selected product.
    /// To list the available targeting for each product use
    /// [ReachPlanService.ListPlannableProducts][google.ads.googleads.v16.services.ReachPlanService.ListPlannableProducts].
    #[prost(message, optional, tag = "5")]
    pub advanced_product_targeting: ::core::option::Option<AdvancedProductTargeting>,
}
/// Response message containing the generated reach curve.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenerateReachForecastResponse {
    /// Reference on target audiences for this curve.
    #[prost(message, optional, tag = "1")]
    pub on_target_audience_metrics: ::core::option::Option<OnTargetAudienceMetrics>,
    /// The generated reach curve for the planned product mix.
    #[prost(message, optional, tag = "2")]
    pub reach_curve: ::core::option::Option<ReachCurve>,
}
/// The reach curve for the planned products.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReachCurve {
    /// All points on the reach curve.
    #[prost(message, repeated, tag = "1")]
    pub reach_forecasts: ::prost::alloc::vec::Vec<ReachForecast>,
}
/// A point on reach curve.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReachForecast {
    /// The cost in micros.
    #[prost(int64, tag = "5")]
    pub cost_micros: i64,
    /// Forecasted traffic metrics for this point.
    #[prost(message, optional, tag = "2")]
    pub forecast: ::core::option::Option<Forecast>,
    /// The forecasted allocation and traffic metrics for each planned product
    /// at this point on the reach curve.
    #[prost(message, repeated, tag = "4")]
    pub planned_product_reach_forecasts: ::prost::alloc::vec::Vec<
        PlannedProductReachForecast,
    >,
}
/// Forecasted traffic metrics for the planned products and targeting.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Forecast {
    /// Number of unique people reached at least
    /// GenerateReachForecastRequest.min_effective_frequency or
    /// GenerateReachForecastRequest.effective_frequency_limit times that exactly
    /// matches the Targeting.
    ///
    /// Note that a minimum number of unique people must be reached in order for
    /// data to be reported. If the minimum number is not met, the on_target_reach
    /// value will be rounded to 0.
    #[prost(int64, optional, tag = "5")]
    pub on_target_reach: ::core::option::Option<i64>,
    /// Total number of unique people reached at least
    /// GenerateReachForecastRequest.min_effective_frequency or
    /// GenerateReachForecastRequest.effective_frequency_limit times. This includes
    /// people that may fall outside the specified Targeting.
    ///
    /// Note that a minimum number of unique people must be reached in order for
    /// data to be reported. If the minimum number is not met, the total_reach
    /// value will be rounded to 0.
    #[prost(int64, optional, tag = "6")]
    pub total_reach: ::core::option::Option<i64>,
    /// Number of ad impressions that exactly matches the Targeting.
    #[prost(int64, optional, tag = "7")]
    pub on_target_impressions: ::core::option::Option<i64>,
    /// Total number of ad impressions. This includes impressions that may fall
    /// outside the specified Targeting, due to insufficient information on
    /// signed-in users.
    #[prost(int64, optional, tag = "8")]
    pub total_impressions: ::core::option::Option<i64>,
    /// Number of times the ad's impressions were considered viewable.
    /// See <https://support.google.com/google-ads/answer/7029393> for
    /// more information about what makes an ad viewable and how
    /// viewability is measured.
    #[prost(int64, optional, tag = "9")]
    pub viewable_impressions: ::core::option::Option<i64>,
    /// A list of effective frequency forecasts. The list is ordered starting with
    /// 1+ and ending with the value set in
    /// GenerateReachForecastRequest.effective_frequency_limit. If no
    /// effective_frequency_limit was set, this list will be empty.
    #[prost(message, repeated, tag = "10")]
    pub effective_frequency_breakdowns: ::prost::alloc::vec::Vec<
        EffectiveFrequencyBreakdown,
    >,
    /// Number of unique people reached that exactly matches the Targeting
    /// including co-viewers.
    #[prost(int64, optional, tag = "11")]
    pub on_target_coview_reach: ::core::option::Option<i64>,
    /// Number of unique people reached including co-viewers. This includes
    /// people that may fall outside the specified Targeting.
    #[prost(int64, optional, tag = "12")]
    pub total_coview_reach: ::core::option::Option<i64>,
    /// Number of ad impressions that exactly matches the Targeting including
    /// co-viewers.
    #[prost(int64, optional, tag = "13")]
    pub on_target_coview_impressions: ::core::option::Option<i64>,
    /// Total number of ad impressions including co-viewers. This includes
    /// impressions that may fall outside the specified Targeting, due to
    /// insufficient information on signed-in users.
    #[prost(int64, optional, tag = "14")]
    pub total_coview_impressions: ::core::option::Option<i64>,
    /// Number of ad views forecasted for the specified product and targeting.
    /// A view is counted when a viewer views a larger portion or the entirety of
    /// an ad beyond an impression.
    ///
    /// See <https://support.google.com/google-ads/answer/2375431> for
    /// more information on views.
    #[prost(int64, optional, tag = "15")]
    pub views: ::core::option::Option<i64>,
}
/// The forecasted allocation and traffic metrics for a specific product
/// at a point on the reach curve.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlannedProductReachForecast {
    /// Selected product for planning. The product codes returned are within the
    /// set of the ones returned by ListPlannableProducts when using the same
    /// location ID.
    #[prost(string, tag = "1")]
    pub plannable_product_code: ::prost::alloc::string::String,
    /// The cost in micros. This may differ from the product's input allocation
    /// if one or more planned products cannot fulfill the budget because of
    /// limited inventory.
    #[prost(int64, tag = "2")]
    pub cost_micros: i64,
    /// Forecasted traffic metrics for this product.
    #[prost(message, optional, tag = "3")]
    pub planned_product_forecast: ::core::option::Option<PlannedProductForecast>,
}
/// Forecasted traffic metrics for a planned product.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PlannedProductForecast {
    /// Number of unique people reached that exactly matches the Targeting.
    ///
    /// Note that a minimum number of unique people must be reached in order for
    /// data to be reported. If the minimum number is not met, the on_target_reach
    /// value will be rounded to 0.
    #[prost(int64, tag = "1")]
    pub on_target_reach: i64,
    /// Number of unique people reached. This includes people that may fall
    /// outside the specified Targeting.
    ///
    /// Note that a minimum number of unique people must be reached in order for
    /// data to be reported. If the minimum number is not met, the total_reach
    /// value will be rounded to 0.
    #[prost(int64, tag = "2")]
    pub total_reach: i64,
    /// Number of ad impressions that exactly matches the Targeting.
    #[prost(int64, tag = "3")]
    pub on_target_impressions: i64,
    /// Total number of ad impressions. This includes impressions that may fall
    /// outside the specified Targeting, due to insufficient information on
    /// signed-in users.
    #[prost(int64, tag = "4")]
    pub total_impressions: i64,
    /// Number of times the ad's impressions were considered viewable.
    /// See <https://support.google.com/google-ads/answer/7029393> for
    /// more information about what makes an ad viewable and how
    /// viewability is measured.
    #[prost(int64, optional, tag = "5")]
    pub viewable_impressions: ::core::option::Option<i64>,
    /// Number of unique people reached that exactly matches the Targeting
    /// including co-viewers.
    #[prost(int64, optional, tag = "6")]
    pub on_target_coview_reach: ::core::option::Option<i64>,
    /// Number of unique people reached including co-viewers. This includes
    /// people that may fall outside the specified Targeting.
    #[prost(int64, optional, tag = "7")]
    pub total_coview_reach: ::core::option::Option<i64>,
    /// Number of ad impressions that exactly matches the Targeting including
    /// co-viewers.
    #[prost(int64, optional, tag = "8")]
    pub on_target_coview_impressions: ::core::option::Option<i64>,
    /// Total number of ad impressions including co-viewers. This includes
    /// impressions that may fall outside the specified Targeting, due to
    /// insufficient information on signed-in users.
    #[prost(int64, optional, tag = "9")]
    pub total_coview_impressions: ::core::option::Option<i64>,
    /// The number of times per selected time unit a user will see an ad, averaged
    /// over the number of time units in the forecast length. This field will only
    /// be populated for a Target Frequency campaign.
    ///
    /// See <https://support.google.com/google-ads/answer/12400225> for more
    /// information about Target Frequency campaigns.
    #[prost(double, optional, tag = "10")]
    pub average_frequency: ::core::option::Option<f64>,
    /// Number of ad views forecasted for the specified product and targeting.
    /// A view is counted when a viewer views a larger portion or the entirety of
    /// an ad beyond an impression.
    ///
    /// See <https://support.google.com/google-ads/answer/2375431> for
    /// more information on views.
    #[prost(int64, optional, tag = "11")]
    pub views: ::core::option::Option<i64>,
}
/// Audience metrics for the planned products.
/// These metrics consider the following targeting dimensions:
///
/// - Location
/// - PlannableAgeRange
/// - Gender
/// - AudienceTargeting (only for youtube_audience_size)
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct OnTargetAudienceMetrics {
    /// Reference audience size matching the considered targeting for YouTube.
    #[prost(int64, optional, tag = "3")]
    pub youtube_audience_size: ::core::option::Option<i64>,
    /// Reference audience size matching the considered targeting for Census.
    #[prost(int64, optional, tag = "4")]
    pub census_audience_size: ::core::option::Option<i64>,
}
/// A breakdown of the number of unique people reached at a given effective
/// frequency.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EffectiveFrequencyBreakdown {
    /// The effective frequency \[1-10\].
    #[prost(int32, tag = "1")]
    pub effective_frequency: i32,
    /// The number of unique people reached at least effective_frequency times that
    /// exactly matches the Targeting.
    ///
    /// Note that a minimum number of unique people must be reached in order for
    /// data to be reported. If the minimum number is not met, the on_target_reach
    /// value will be rounded to 0.
    #[prost(int64, tag = "2")]
    pub on_target_reach: i64,
    /// Total number of unique people reached at least effective_frequency times.
    /// This includes people that may fall outside the specified Targeting.
    ///
    /// Note that a minimum number of unique people must be reached in order for
    /// data to be reported. If the minimum number is not met, the total_reach
    /// value will be rounded to 0.
    #[prost(int64, tag = "3")]
    pub total_reach: i64,
    /// The number of users (including co-viewing users) reached for the associated
    /// effective_frequency value.
    #[prost(int64, optional, tag = "4")]
    pub effective_coview_reach: ::core::option::Option<i64>,
    /// The number of users (including co-viewing users) reached for the associated
    /// effective_frequency value within the specified plan demographic.
    #[prost(int64, optional, tag = "5")]
    pub on_target_effective_coview_reach: ::core::option::Option<i64>,
}
/// Controls forecast metrics to return.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ForecastMetricOptions {
    /// Indicates whether to include co-view metrics in the response forecast.
    #[prost(bool, tag = "1")]
    pub include_coview: bool,
}
/// Audience targeting for reach forecast.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AudienceTargeting {
    /// List of audiences based on user interests to be targeted.
    #[prost(message, repeated, tag = "1")]
    pub user_interest: ::prost::alloc::vec::Vec<super::common::UserInterestInfo>,
}
/// Advanced targeting settings for products.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AdvancedProductTargeting {
    /// Surface targeting settings for this product.
    #[prost(message, optional, tag = "2")]
    pub surface_targeting_settings: ::core::option::Option<SurfaceTargeting>,
    /// Settings for a Target frequency campaign. Must be set when selecting the
    /// TARGET_FREQUENCY product.
    ///
    /// See <https://support.google.com/google-ads/answer/12400225> for more
    /// information about Target Frequency campaigns.
    #[prost(message, optional, tag = "3")]
    pub target_frequency_settings: ::core::option::Option<TargetFrequencySettings>,
    /// Targeting options for this product.
    #[prost(oneof = "advanced_product_targeting::AdvancedTargeting", tags = "1")]
    pub advanced_targeting: ::core::option::Option<
        advanced_product_targeting::AdvancedTargeting,
    >,
}
/// Nested message and enum types in `AdvancedProductTargeting`.
pub mod advanced_product_targeting {
    /// Targeting options for this product.
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum AdvancedTargeting {
        /// Settings for YouTube Select targeting.
        #[prost(message, tag = "1")]
        YoutubeSelectSettings(super::YouTubeSelectSettings),
    }
}
/// Request settings for YouTube Select Lineups
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct YouTubeSelectSettings {
    /// Lineup for YouTube Select Targeting.
    #[prost(int64, tag = "1")]
    pub lineup_id: i64,
}
/// A Plannable YouTube Select Lineup for product targeting.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct YouTubeSelectLineUp {
    /// The ID of the YouTube Select Lineup.
    #[prost(int64, tag = "1")]
    pub lineup_id: i64,
    /// The unique name of the YouTube Select Lineup.
    #[prost(string, tag = "2")]
    pub lineup_name: ::prost::alloc::string::String,
}
/// The surface targeting combinations available for an ad product.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SurfaceTargetingCombinations {
    /// Default surface targeting applied to the ad product.
    #[prost(message, optional, tag = "1")]
    pub default_targeting: ::core::option::Option<SurfaceTargeting>,
    /// Available surface target combinations for the ad product.
    #[prost(message, repeated, tag = "2")]
    pub available_targeting_combinations: ::prost::alloc::vec::Vec<SurfaceTargeting>,
}
/// Container for surfaces for a product. Surfaces refer to the available types
/// of ad inventories such as In-Feed, In-Stream, and Shorts.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SurfaceTargeting {
    /// List of surfaces available to target.
    #[prost(
        enumeration = "super::enums::reach_plan_surface_enum::ReachPlanSurface",
        repeated,
        tag = "1"
    )]
    pub surfaces: ::prost::alloc::vec::Vec<i32>,
}
/// Target Frequency settings for a supported product.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TargetFrequencySettings {
    /// Required. The time unit used to describe the time frame for
    /// target_frequency.
    #[prost(
        enumeration = "super::enums::target_frequency_time_unit_enum::TargetFrequencyTimeUnit",
        tag = "1"
    )]
    pub time_unit: i32,
    /// Required. The target frequency goal per selected time unit.
    #[prost(int32, tag = "2")]
    pub target_frequency: i32,
}
/// Generated server implementations.
pub mod reach_plan_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with ReachPlanServiceServer.
    #[async_trait]
    pub trait ReachPlanService: std::marker::Send + std::marker::Sync + 'static {
        /// Returns the list of plannable locations (for example, countries).
        ///
        /// List of thrown errors:
        ///   [AuthenticationError]()
        ///   [AuthorizationError]()
        ///   [HeaderError]()
        ///   [InternalError]()
        ///   [QuotaError]()
        ///   [RequestError]()
        async fn list_plannable_locations(
            &self,
            request: tonic::Request<super::ListPlannableLocationsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListPlannableLocationsResponse>,
            tonic::Status,
        >;
        /// Returns the list of per-location plannable YouTube ad formats with allowed
        /// targeting.
        ///
        /// List of thrown errors:
        ///   [AuthenticationError]()
        ///   [AuthorizationError]()
        ///   [HeaderError]()
        ///   [InternalError]()
        ///   [QuotaError]()
        ///   [RequestError]()
        async fn list_plannable_products(
            &self,
            request: tonic::Request<super::ListPlannableProductsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListPlannableProductsResponse>,
            tonic::Status,
        >;
        /// Generates a reach forecast for a given targeting / product mix.
        ///
        /// List of thrown errors:
        ///   [AuthenticationError]()
        ///   [AuthorizationError]()
        ///   [FieldError]()
        ///   [HeaderError]()
        ///   [InternalError]()
        ///   [QuotaError]()
        ///   [RangeError]()
        ///   [ReachPlanError]()
        ///   [RequestError]()
        async fn generate_reach_forecast(
            &self,
            request: tonic::Request<super::GenerateReachForecastRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GenerateReachForecastResponse>,
            tonic::Status,
        >;
    }
    /// Reach Plan Service gives users information about audience size that can
    /// be reached through advertisement on YouTube. In particular,
    /// GenerateReachForecast provides estimated number of people of specified
    /// demographics that can be reached by an ad in a given market by a campaign of
    /// certain duration with a defined budget.
    #[derive(Debug)]
    pub struct ReachPlanServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> ReachPlanServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for ReachPlanServiceServer<T>
    where
        T: ReachPlanService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/google.ads.googleads.v16.services.ReachPlanService/ListPlannableLocations" => {
                    #[allow(non_camel_case_types)]
                    struct ListPlannableLocationsSvc<T: ReachPlanService>(pub Arc<T>);
                    impl<
                        T: ReachPlanService,
                    > tonic::server::UnaryService<super::ListPlannableLocationsRequest>
                    for ListPlannableLocationsSvc<T> {
                        type Response = super::ListPlannableLocationsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ListPlannableLocationsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ReachPlanService>::list_plannable_locations(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ListPlannableLocationsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.ads.googleads.v16.services.ReachPlanService/ListPlannableProducts" => {
                    #[allow(non_camel_case_types)]
                    struct ListPlannableProductsSvc<T: ReachPlanService>(pub Arc<T>);
                    impl<
                        T: ReachPlanService,
                    > tonic::server::UnaryService<super::ListPlannableProductsRequest>
                    for ListPlannableProductsSvc<T> {
                        type Response = super::ListPlannableProductsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ListPlannableProductsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ReachPlanService>::list_plannable_products(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ListPlannableProductsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.ads.googleads.v16.services.ReachPlanService/GenerateReachForecast" => {
                    #[allow(non_camel_case_types)]
                    struct GenerateReachForecastSvc<T: ReachPlanService>(pub Arc<T>);
                    impl<
                        T: ReachPlanService,
                    > tonic::server::UnaryService<super::GenerateReachForecastRequest>
                    for GenerateReachForecastSvc<T> {
                        type Response = super::GenerateReachForecastResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GenerateReachForecastRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ReachPlanService>::generate_reach_forecast(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GenerateReachForecastSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for ReachPlanServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "google.ads.googleads.v16.services.ReachPlanService";
    impl<T> tonic::server::NamedService for ReachPlanServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Request message for
/// [RecommendationService.ApplyRecommendation][google.ads.googleads.v16.services.RecommendationService.ApplyRecommendation].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ApplyRecommendationRequest {
    /// Required. The ID of the customer with the recommendation.
    #[prost(string, tag = "1")]
    pub customer_id: ::prost::alloc::string::String,
    /// Required. The list of operations to apply recommendations.
    /// If partial_failure=false all recommendations should be of the same type
    /// There is a limit of 100 operations per request.
    #[prost(message, repeated, tag = "2")]
    pub operations: ::prost::alloc::vec::Vec<ApplyRecommendationOperation>,
    /// If true, successful operations will be carried out and invalid
    /// operations will return errors. If false, operations will be carried
    /// out as a transaction if and only if they are all valid.
    /// Default is false.
    #[prost(bool, tag = "3")]
    pub partial_failure: bool,
}
/// Information about the operation to apply a recommendation and any parameters
/// to customize it.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ApplyRecommendationOperation {
    /// The resource name of the recommendation to apply.
    #[prost(string, tag = "1")]
    pub resource_name: ::prost::alloc::string::String,
    /// Parameters to use when applying the recommendation.
    #[prost(
        oneof = "apply_recommendation_operation::ApplyParameters",
        tags = "2, 3, 4, 5, 10, 6, 7, 8, 9, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25"
    )]
    pub apply_parameters: ::core::option::Option<
        apply_recommendation_operation::ApplyParameters,
    >,
}
/// Nested message and enum types in `ApplyRecommendationOperation`.
pub mod apply_recommendation_operation {
    /// Parameters to use when applying a campaign budget recommendation.
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct CampaignBudgetParameters {
        /// New budget amount to set for target budget resource. This is a required
        /// field.
        #[prost(int64, optional, tag = "2")]
        pub new_budget_amount_micros: ::core::option::Option<i64>,
    }
    /// Parameters to use when applying a forecasting set target roas
    /// recommendation.
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct ForecastingSetTargetRoasParameters {
        /// New target ROAS (revenue per unit of spend) to set for a campaign
        /// resource.
        /// The value is between 0.01 and 1000.0, inclusive.
        #[prost(double, optional, tag = "1")]
        pub target_roas: ::core::option::Option<f64>,
        /// New campaign budget amount to set for a campaign resource.
        #[prost(int64, optional, tag = "2")]
        pub campaign_budget_amount_micros: ::core::option::Option<i64>,
    }
    /// Parameters to use when applying a text ad recommendation.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct TextAdParameters {
        /// New ad to add to recommended ad group. All necessary fields need to be
        /// set in this message. This is a required field.
        #[prost(message, optional, tag = "1")]
        pub ad: ::core::option::Option<super::super::resources::Ad>,
    }
    /// Parameters to use when applying keyword recommendation.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct KeywordParameters {
        /// The ad group resource to add keyword to. This is a required field.
        #[prost(string, optional, tag = "4")]
        pub ad_group: ::core::option::Option<::prost::alloc::string::String>,
        /// The match type of the keyword. This is a required field.
        #[prost(
            enumeration = "super::super::enums::keyword_match_type_enum::KeywordMatchType",
            tag = "2"
        )]
        pub match_type: i32,
        /// Optional, CPC bid to set for the keyword. If not set, keyword will use
        /// bid based on bidding strategy used by target ad group.
        #[prost(int64, optional, tag = "5")]
        pub cpc_bid_micros: ::core::option::Option<i64>,
    }
    /// Parameters to use when applying Target CPA recommendation.
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct TargetCpaOptInParameters {
        /// Average CPA to use for Target CPA bidding strategy. This is a required
        /// field.
        #[prost(int64, optional, tag = "3")]
        pub target_cpa_micros: ::core::option::Option<i64>,
        /// Optional, budget amount to set for the campaign.
        #[prost(int64, optional, tag = "4")]
        pub new_campaign_budget_amount_micros: ::core::option::Option<i64>,
    }
    /// Parameters to use when applying a Target ROAS opt-in recommendation.
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct TargetRoasOptInParameters {
        /// Average ROAS (revenue per unit of spend) to use for Target ROAS bidding
        /// strategy. The value is between 0.01 and 1000.0, inclusive. This is a
        /// required field, unless new_campaign_budget_amount_micros is set.
        #[prost(double, optional, tag = "1")]
        pub target_roas: ::core::option::Option<f64>,
        /// Optional, budget amount to set for the campaign.
        #[prost(int64, optional, tag = "2")]
        pub new_campaign_budget_amount_micros: ::core::option::Option<i64>,
    }
    /// Parameters to use when applying callout extension recommendation.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct CalloutExtensionParameters {
        /// Callout extensions to be added. This is a required field.
        #[prost(message, repeated, tag = "1")]
        pub callout_extensions: ::prost::alloc::vec::Vec<
            super::super::common::CalloutFeedItem,
        >,
    }
    /// Parameters to use when applying call extension recommendation.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct CallExtensionParameters {
        /// Call extensions to be added. This is a required field.
        #[prost(message, repeated, tag = "1")]
        pub call_extensions: ::prost::alloc::vec::Vec<
            super::super::common::CallFeedItem,
        >,
    }
    /// Parameters to use when applying sitelink recommendation.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SitelinkExtensionParameters {
        /// Sitelinks to be added. This is a required field.
        #[prost(message, repeated, tag = "1")]
        pub sitelink_extensions: ::prost::alloc::vec::Vec<
            super::super::common::SitelinkFeedItem,
        >,
    }
    /// Parameters to use when applying callout asset recommendations.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct CalloutAssetParameters {
        /// Required. Callout assets to be added. This is a required field.
        #[prost(message, optional, tag = "1")]
        pub ad_asset_apply_parameters: ::core::option::Option<AdAssetApplyParameters>,
    }
    /// Parameters to use when applying call asset recommendations.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct CallAssetParameters {
        /// Required. Call assets to be added. This is a required field.
        #[prost(message, optional, tag = "1")]
        pub ad_asset_apply_parameters: ::core::option::Option<AdAssetApplyParameters>,
    }
    /// Parameters to use when applying sitelink asset recommendations.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SitelinkAssetParameters {
        /// Required. Sitelink assets to be added. This is a required field.
        #[prost(message, optional, tag = "1")]
        pub ad_asset_apply_parameters: ::core::option::Option<AdAssetApplyParameters>,
    }
    /// Parameters to use when applying raise Target CPA recommendations.
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct RaiseTargetCpaParameters {
        /// Required. Target to set CPA multiplier to. This is a required field.
        #[prost(double, tag = "1")]
        pub target_cpa_multiplier: f64,
    }
    /// Parameters to use when applying lower Target ROAS recommendations.
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct LowerTargetRoasParameters {
        /// Required. Target to set ROAS multiplier to. This is a required field.
        #[prost(double, tag = "1")]
        pub target_roas_multiplier: f64,
    }
    /// Common parameters used when applying ad asset recommendations.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct AdAssetApplyParameters {
        /// The assets to create and attach to a scope. This may be combined with
        /// existing_assets in the same call.
        #[prost(message, repeated, tag = "1")]
        pub new_assets: ::prost::alloc::vec::Vec<super::super::resources::Asset>,
        /// The resource names of existing assets to attach to a scope. This may be
        /// combined with new_assets in the same call.
        #[prost(string, repeated, tag = "2")]
        pub existing_assets: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        /// Required. The scope at which to apply the assets. Assets at the campaign
        /// scope level will be applied to the campaign associated with the
        /// recommendation. Assets at the customer scope will apply to the entire
        /// account. Assets at the campaign scope will override any attached at the
        /// customer scope.
        #[prost(enumeration = "ad_asset_apply_parameters::ApplyScope", tag = "3")]
        pub scope: i32,
    }
    /// Nested message and enum types in `AdAssetApplyParameters`.
    pub mod ad_asset_apply_parameters {
        /// Scope to apply the assets to.
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum ApplyScope {
            /// The apply scope has not been specified.
            Unspecified = 0,
            /// Unknown.
            Unknown = 1,
            /// Apply at the customer scope.
            Customer = 2,
            /// Apply at the campaign scope.
            Campaign = 3,
        }
        impl ApplyScope {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "UNSPECIFIED",
                    Self::Unknown => "UNKNOWN",
                    Self::Customer => "CUSTOMER",
                    Self::Campaign => "CAMPAIGN",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "UNSPECIFIED" => Some(Self::Unspecified),
                    "UNKNOWN" => Some(Self::Unknown),
                    "CUSTOMER" => Some(Self::Customer),
                    "CAMPAIGN" => Some(Self::Campaign),
                    _ => None,
                }
            }
        }
    }
    /// Parameters to use when applying move unused budget recommendation.
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct MoveUnusedBudgetParameters {
        /// Budget amount to move from excess budget to constrained budget. This is
        /// a required field.
        #[prost(int64, optional, tag = "2")]
        pub budget_micros_to_move: ::core::option::Option<i64>,
    }
    /// Parameters to use when applying a responsive search ad asset
    /// recommendation.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ResponsiveSearchAdAssetParameters {
        /// Updated ad. The current ad's content will be replaced.
        #[prost(message, optional, tag = "1")]
        pub updated_ad: ::core::option::Option<super::super::resources::Ad>,
    }
    /// Parameters to use when applying a responsive search ad improve ad strength
    /// recommendation.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ResponsiveSearchAdImproveAdStrengthParameters {
        /// Updated ad. The current ad's content will be replaced.
        #[prost(message, optional, tag = "1")]
        pub updated_ad: ::core::option::Option<super::super::resources::Ad>,
    }
    /// Parameters to use when applying a responsive search ad recommendation.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ResponsiveSearchAdParameters {
        /// Required. New ad to add to recommended ad group.
        #[prost(message, optional, tag = "1")]
        pub ad: ::core::option::Option<super::super::resources::Ad>,
    }
    /// Parameters to use when applying a raise target CPA bid too low
    /// recommendation. The apply is asynchronous and can take minutes depending on
    /// the number of ad groups there is in the related campaign..
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct RaiseTargetCpaBidTooLowParameters {
        /// Required. A number greater than 1.0 indicating the factor by which to
        /// increase the target CPA. This is a required field.
        #[prost(double, tag = "1")]
        pub target_multiplier: f64,
    }
    /// Parameters to use when applying a use broad match keyword recommendation.
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct UseBroadMatchKeywordParameters {
        /// New budget amount to set for target budget resource.
        #[prost(int64, optional, tag = "1")]
        pub new_budget_amount_micros: ::core::option::Option<i64>,
    }
    /// Parameters to use when applying a set target CPA recommendation.
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct ForecastingSetTargetCpaParameters {
        /// Average CPA to use for Target CPA bidding strategy.
        #[prost(int64, optional, tag = "1")]
        pub target_cpa_micros: ::core::option::Option<i64>,
        /// New campaign budget amount to set for a campaign resource.
        #[prost(int64, optional, tag = "2")]
        pub campaign_budget_amount_micros: ::core::option::Option<i64>,
    }
    /// Parameters to use when applying a lead form asset recommendation.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct LeadFormAssetParameters {
        /// Required. Lead form assets to be added. This is a required field.
        #[prost(message, optional, tag = "1")]
        pub ad_asset_apply_parameters: ::core::option::Option<AdAssetApplyParameters>,
        /// If true, the "Submit Lead Form" goal will be set on the target campaign.
        /// As a result, ads will be shown as lead form creative ads. If false,
        /// the "Submit Lead Form" goal will not be set on the campaign and ads will
        /// contain lead form assets.
        #[prost(bool, optional, tag = "2")]
        pub set_submit_lead_form_asset_campaign_goal: ::core::option::Option<bool>,
    }
    /// Parameters to use when applying the recommendation.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum ApplyParameters {
        /// Optional parameters to use when applying a campaign budget
        /// recommendation.
        #[prost(message, tag = "2")]
        CampaignBudget(CampaignBudgetParameters),
        /// Optional parameters to use when applying a text ad recommendation.
        #[prost(message, tag = "3")]
        TextAd(TextAdParameters),
        /// Optional parameters to use when applying keyword recommendation.
        #[prost(message, tag = "4")]
        Keyword(KeywordParameters),
        /// Optional parameters to use when applying target CPA opt-in
        /// recommendation.
        #[prost(message, tag = "5")]
        TargetCpaOptIn(TargetCpaOptInParameters),
        /// Optional parameters to use when applying target ROAS opt-in
        /// recommendation.
        #[prost(message, tag = "10")]
        TargetRoasOptIn(TargetRoasOptInParameters),
        /// Parameters to use when applying callout extension recommendation.
        #[prost(message, tag = "6")]
        CalloutExtension(CalloutExtensionParameters),
        /// Parameters to use when applying call extension recommendation.
        #[prost(message, tag = "7")]
        CallExtension(CallExtensionParameters),
        /// Parameters to use when applying sitelink recommendation.
        #[prost(message, tag = "8")]
        SitelinkExtension(SitelinkExtensionParameters),
        /// Parameters to use when applying move unused budget recommendation.
        #[prost(message, tag = "9")]
        MoveUnusedBudget(MoveUnusedBudgetParameters),
        /// Parameters to use when applying a responsive search ad recommendation.
        #[prost(message, tag = "11")]
        ResponsiveSearchAd(ResponsiveSearchAdParameters),
        /// Parameters to use when applying a use broad match keyword recommendation.
        #[prost(message, tag = "12")]
        UseBroadMatchKeyword(UseBroadMatchKeywordParameters),
        /// Parameters to use when applying a responsive search ad asset
        /// recommendation.
        #[prost(message, tag = "13")]
        ResponsiveSearchAdAsset(ResponsiveSearchAdAssetParameters),
        /// Parameters to use when applying a responsive search ad improve ad
        /// strength recommendation.
        #[prost(message, tag = "14")]
        ResponsiveSearchAdImproveAdStrength(
            ResponsiveSearchAdImproveAdStrengthParameters,
        ),
        /// Parameters to use when applying a raise target CPA bid too low
        /// recommendation. The apply is asynchronous and can take minutes depending
        /// on the number of ad groups there is in the related campaign.
        #[prost(message, tag = "15")]
        RaiseTargetCpaBidTooLow(RaiseTargetCpaBidTooLowParameters),
        /// Parameters to use when applying a forecasting set target ROAS
        /// recommendation.
        #[prost(message, tag = "16")]
        ForecastingSetTargetRoas(ForecastingSetTargetRoasParameters),
        /// Parameters to use when applying callout asset recommendation.
        #[prost(message, tag = "17")]
        CalloutAsset(CalloutAssetParameters),
        /// Parameters to use when applying call asset recommendation.
        #[prost(message, tag = "18")]
        CallAsset(CallAssetParameters),
        /// Parameters to use when applying sitelink asset recommendation.
        #[prost(message, tag = "19")]
        SitelinkAsset(SitelinkAssetParameters),
        /// Parameters to use when applying raise Target CPA recommendation.
        #[prost(message, tag = "20")]
        RaiseTargetCpa(RaiseTargetCpaParameters),
        /// Parameters to use when applying lower Target ROAS recommendation.
        #[prost(message, tag = "21")]
        LowerTargetRoas(LowerTargetRoasParameters),
        /// Parameters to use when applying forecasting set target CPA
        /// recommendation.
        #[prost(message, tag = "22")]
        ForecastingSetTargetCpa(ForecastingSetTargetCpaParameters),
        /// Parameters to use when applying set target CPA
        /// recommendation.
        #[prost(message, tag = "23")]
        SetTargetCpa(ForecastingSetTargetCpaParameters),
        /// Parameters to use when applying set target ROAS
        /// recommendation.
        #[prost(message, tag = "24")]
        SetTargetRoas(ForecastingSetTargetRoasParameters),
        /// Parameters to use when applying lead form asset recommendation.
        #[prost(message, tag = "25")]
        LeadFormAsset(LeadFormAssetParameters),
    }
}
/// Response message for
/// [RecommendationService.ApplyRecommendation][google.ads.googleads.v16.services.RecommendationService.ApplyRecommendation].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ApplyRecommendationResponse {
    /// Results of operations to apply recommendations.
    #[prost(message, repeated, tag = "1")]
    pub results: ::prost::alloc::vec::Vec<ApplyRecommendationResult>,
    /// Errors that pertain to operation failures in the partial failure mode.
    /// Returned only when partial_failure = true and all errors occur inside the
    /// operations. If any errors occur outside the operations (for example, auth
    /// errors) we return the RPC level error.
    #[prost(message, optional, tag = "2")]
    pub partial_failure_error: ::core::option::Option<
        super::super::super::super::rpc::Status,
    >,
}
/// The result of applying a recommendation.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ApplyRecommendationResult {
    /// Returned for successful applies.
    #[prost(string, tag = "1")]
    pub resource_name: ::prost::alloc::string::String,
}
/// Request message for
/// [RecommendationService.DismissRecommendation][google.ads.googleads.v16.services.RecommendationService.DismissRecommendation].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DismissRecommendationRequest {
    /// Required. The ID of the customer with the recommendation.
    #[prost(string, tag = "1")]
    pub customer_id: ::prost::alloc::string::String,
    /// Required. The list of operations to dismiss recommendations.
    /// If partial_failure=false all recommendations should be of the same type
    /// There is a limit of 100 operations per request.
    #[prost(message, repeated, tag = "3")]
    pub operations: ::prost::alloc::vec::Vec<
        dismiss_recommendation_request::DismissRecommendationOperation,
    >,
    /// If true, successful operations will be carried out and invalid
    /// operations will return errors. If false, operations will be carried in a
    /// single transaction if and only if they are all valid.
    /// Default is false.
    #[prost(bool, tag = "2")]
    pub partial_failure: bool,
}
/// Nested message and enum types in `DismissRecommendationRequest`.
pub mod dismiss_recommendation_request {
    /// Operation to dismiss a single recommendation identified by resource_name.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct DismissRecommendationOperation {
        /// The resource name of the recommendation to dismiss.
        #[prost(string, tag = "1")]
        pub resource_name: ::prost::alloc::string::String,
    }
}
/// Response message for
/// [RecommendationService.DismissRecommendation][google.ads.googleads.v16.services.RecommendationService.DismissRecommendation].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DismissRecommendationResponse {
    /// Results of operations to dismiss recommendations.
    #[prost(message, repeated, tag = "1")]
    pub results: ::prost::alloc::vec::Vec<
        dismiss_recommendation_response::DismissRecommendationResult,
    >,
    /// Errors that pertain to operation failures in the partial failure mode.
    /// Returned only when partial_failure = true and all errors occur inside the
    /// operations. If any errors occur outside the operations (for example, auth
    /// errors) we return the RPC level error.
    #[prost(message, optional, tag = "2")]
    pub partial_failure_error: ::core::option::Option<
        super::super::super::super::rpc::Status,
    >,
}
/// Nested message and enum types in `DismissRecommendationResponse`.
pub mod dismiss_recommendation_response {
    /// The result of dismissing a recommendation.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct DismissRecommendationResult {
        /// Returned for successful dismissals.
        #[prost(string, tag = "1")]
        pub resource_name: ::prost::alloc::string::String,
    }
}
/// Request message for
/// [RecommendationService.GenerateRecommendations][google.ads.googleads.v16.services.RecommendationService.GenerateRecommendations].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenerateRecommendationsRequest {
    /// Required. The ID of the customer generating recommendations.
    #[prost(string, tag = "1")]
    pub customer_id: ::prost::alloc::string::String,
    /// Required. List of eligible recommendation_types to generate. If the
    /// uploaded criteria isn't sufficient to make a recommendation, or the
    /// campaign is already in the recommended state, no recommendation will be
    /// returned for that type. Generally, a recommendation is returned if all
    /// required fields for that recommendation_type are uploaded, but there are
    /// cases where this is still not sufficient.
    ///
    /// The following recommendation_types are supported for recommendation
    /// generation:
    /// KEYWORD, MAXIMIZE_CLICKS_OPT_IN, MAXIMIZE_CONVERSIONS_OPT_IN,
    /// MAXIMIZE_CONVERSION_VALUE_OPT_IN, SET_TARGET_CPA, SET_TARGET_ROAS,
    /// SITELINK_ASSET, TARGET_CPA_OPT_IN, TARGET_ROAS_OPT_IN
    #[prost(
        enumeration = "super::enums::recommendation_type_enum::RecommendationType",
        repeated,
        packed = "false",
        tag = "2"
    )]
    pub recommendation_types: ::prost::alloc::vec::Vec<i32>,
    /// Required. Advertising channel type of the campaign.
    /// The following advertising_channel_types are supported for recommendation
    /// generation:
    /// PERFORMANCE_MAX and SEARCH
    #[prost(
        enumeration = "super::enums::advertising_channel_type_enum::AdvertisingChannelType",
        tag = "3"
    )]
    pub advertising_channel_type: i32,
    /// Optional. Number of sitelinks on the campaign.
    /// This field is necessary for the following recommendation_types:
    /// SITELINK_ASSET
    #[prost(int32, optional, tag = "4")]
    pub campaign_sitelink_count: ::core::option::Option<i32>,
    /// Optional. Current conversion tracking status.
    /// This field is necessary for the following recommendation_types:
    /// MAXIMIZE_CLICKS_OPT_IN, MAXIMIZE_CONVERSIONS_OPT_IN,
    /// MAXIMIZE_CONVERSION_VALUE_OPT_IN, SET_TARGET_CPA, SET_TARGET_ROAS,
    /// TARGET_CPA_OPT_IN, TARGET_ROAS_OPT_IN
    #[prost(
        enumeration = "super::enums::conversion_tracking_status_enum::ConversionTrackingStatus",
        optional,
        tag = "5"
    )]
    pub conversion_tracking_status: ::core::option::Option<i32>,
    /// Optional. Current bidding information of the campaign.
    /// This field is necessary for the following recommendation_types:
    /// MAXIMIZE_CLICKS_OPT_IN, MAXIMIZE_CONVERSIONS_OPT_IN,
    /// MAXIMIZE_CONVERSION_VALUE_OPT_IN, SET_TARGET_CPA, SET_TARGET_ROAS,
    /// TARGET_CPA_OPT_IN, TARGET_ROAS_OPT_IN
    #[prost(message, optional, tag = "6")]
    pub bidding_info: ::core::option::Option<
        generate_recommendations_request::BiddingInfo,
    >,
    /// Optional. Current AdGroup Information.
    /// Supports information from a single AdGroup.
    /// This field is optional for the following recommendation_types:
    /// KEYWORD
    #[prost(message, repeated, tag = "7")]
    pub ad_group_info: ::prost::alloc::vec::Vec<
        generate_recommendations_request::AdGroupInfo,
    >,
    /// Optional. Seed information for Keywords.
    /// This field is necessary for the following recommendation_types:
    /// KEYWORD
    #[prost(message, optional, tag = "8")]
    pub seed_info: ::core::option::Option<generate_recommendations_request::SeedInfo>,
}
/// Nested message and enum types in `GenerateRecommendationsRequest`.
pub mod generate_recommendations_request {
    /// Current bidding information of the campaign. Provides a wrapper for
    /// bidding-related signals that inform recommendations.
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct BiddingInfo {
        /// Current bidding strategy.
        /// This field is necessary for the following recommendation_types:
        /// MAXIMIZE_CLICKS_OPT_IN, MAXIMIZE_CONVERSIONS_OPT_IN,
        /// MAXIMIZE_CONVERSION_VALUE_OPT_IN, SET_TARGET_CPA, SET_TARGET_ROAS,
        /// TARGET_CPA_OPT_IN, TARGET_ROAS_OPT_IN
        #[prost(
            enumeration = "super::super::enums::bidding_strategy_type_enum::BiddingStrategyType",
            optional,
            tag = "1"
        )]
        pub bidding_strategy_type: ::core::option::Option<i32>,
        /// Optional details related to the bidding_strategy_type.
        #[prost(oneof = "bidding_info::BiddingStrategyTargetInfo", tags = "2, 3")]
        pub bidding_strategy_target_info: ::core::option::Option<
            bidding_info::BiddingStrategyTargetInfo,
        >,
    }
    /// Nested message and enum types in `BiddingInfo`.
    pub mod bidding_info {
        /// Optional details related to the bidding_strategy_type.
        #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
        pub enum BiddingStrategyTargetInfo {
            /// Current target_cpa in micros.
            /// This can be populated for campaigns with a bidding strategy type of
            /// TARGET_CPA or MAXIMIZE_CONVERSIONS.
            #[prost(int64, tag = "2")]
            TargetCpaMicros(i64),
            /// Current target_roas.
            /// This can be populated for campaigns with a bidding strategy type of
            /// TARGET_ROAS or MAXIMIZE_CONVERSION_VALUE.
            #[prost(double, tag = "3")]
            TargetRoas(f64),
        }
    }
    /// Current AdGroup Information of the campaign.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct AdGroupInfo {
        /// Optional. AdGroup Type of the AdGroup.
        /// This field is necessary for the following recommendation_types if
        /// ad_group_info is set:
        /// KEYWORD
        #[prost(
            enumeration = "super::super::enums::ad_group_type_enum::AdGroupType",
            optional,
            tag = "1"
        )]
        pub ad_group_type: ::core::option::Option<i32>,
        /// Optional. Current keywords.
        /// This field is optional for the following recommendation_types if
        /// ad_group_info is set:
        /// KEYWORD
        #[prost(message, repeated, tag = "2")]
        pub keywords: ::prost::alloc::vec::Vec<super::super::common::KeywordInfo>,
    }
    /// A keyword seed and a specific url to generate keywords from.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SeedInfo {
        /// A specific url to generate ideas from, for example: www.example.com/cars.
        #[prost(string, optional, tag = "2")]
        pub url_seed: ::core::option::Option<::prost::alloc::string::String>,
        /// Optional. Keywords or phrases to generate ideas from, for example: cars
        /// or "car dealership near me".
        #[prost(string, repeated, tag = "3")]
        pub keyword_seeds: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    }
}
/// Response message for
/// [RecommendationService.GenerateRecommendations][google.ads.googleads.v16.services.RecommendationService.GenerateRecommendations].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenerateRecommendationsResponse {
    /// List of generated recommendations from the passed in set of requested
    /// recommendation_types. If there isn't sufficient data to generate a
    /// recommendation for the requested recommendation_types, the result set won't
    /// contain a recommendation for that type.
    #[prost(message, repeated, tag = "1")]
    pub recommendations: ::prost::alloc::vec::Vec<super::resources::Recommendation>,
}
/// Generated server implementations.
pub mod recommendation_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with RecommendationServiceServer.
    #[async_trait]
    pub trait RecommendationService: std::marker::Send + std::marker::Sync + 'static {
        /// Applies given recommendations with corresponding apply parameters.
        ///
        /// List of thrown errors:
        ///   [AuthenticationError]()
        ///   [AuthorizationError]()
        ///   [DatabaseError]()
        ///   [FieldError]()
        ///   [HeaderError]()
        ///   [InternalError]()
        ///   [MutateError]()
        ///   [QuotaError]()
        ///   [RecommendationError]()
        ///   [RequestError]()
        ///   [UrlFieldError]()
        async fn apply_recommendation(
            &self,
            request: tonic::Request<super::ApplyRecommendationRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ApplyRecommendationResponse>,
            tonic::Status,
        >;
        /// Dismisses given recommendations.
        ///
        /// List of thrown errors:
        ///   [AuthenticationError]()
        ///   [AuthorizationError]()
        ///   [HeaderError]()
        ///   [InternalError]()
        ///   [QuotaError]()
        ///   [RecommendationError]()
        ///   [RequestError]()
        async fn dismiss_recommendation(
            &self,
            request: tonic::Request<super::DismissRecommendationRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DismissRecommendationResponse>,
            tonic::Status,
        >;
        /// Generates Recommendations based off the requested recommendation_types.
        ///
        /// List of thrown errors:
        ///   [AuthenticationError]()
        ///   [AuthorizationError]()
        ///   [HeaderError]()
        ///   [InternalError]()
        ///   [QuotaError]()
        ///   [RecommendationError]()
        ///   [RequestError]()
        async fn generate_recommendations(
            &self,
            request: tonic::Request<super::GenerateRecommendationsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GenerateRecommendationsResponse>,
            tonic::Status,
        >;
    }
    /// Service to manage recommendations.
    #[derive(Debug)]
    pub struct RecommendationServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> RecommendationServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>>
    for RecommendationServiceServer<T>
    where
        T: RecommendationService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/google.ads.googleads.v16.services.RecommendationService/ApplyRecommendation" => {
                    #[allow(non_camel_case_types)]
                    struct ApplyRecommendationSvc<T: RecommendationService>(pub Arc<T>);
                    impl<
                        T: RecommendationService,
                    > tonic::server::UnaryService<super::ApplyRecommendationRequest>
                    for ApplyRecommendationSvc<T> {
                        type Response = super::ApplyRecommendationResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ApplyRecommendationRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RecommendationService>::apply_recommendation(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ApplyRecommendationSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.ads.googleads.v16.services.RecommendationService/DismissRecommendation" => {
                    #[allow(non_camel_case_types)]
                    struct DismissRecommendationSvc<T: RecommendationService>(
                        pub Arc<T>,
                    );
                    impl<
                        T: RecommendationService,
                    > tonic::server::UnaryService<super::DismissRecommendationRequest>
                    for DismissRecommendationSvc<T> {
                        type Response = super::DismissRecommendationResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DismissRecommendationRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RecommendationService>::dismiss_recommendation(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = DismissRecommendationSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.ads.googleads.v16.services.RecommendationService/GenerateRecommendations" => {
                    #[allow(non_camel_case_types)]
                    struct GenerateRecommendationsSvc<T: RecommendationService>(
                        pub Arc<T>,
                    );
                    impl<
                        T: RecommendationService,
                    > tonic::server::UnaryService<super::GenerateRecommendationsRequest>
                    for GenerateRecommendationsSvc<T> {
                        type Response = super::GenerateRecommendationsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::GenerateRecommendationsRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RecommendationService>::generate_recommendations(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GenerateRecommendationsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for RecommendationServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "google.ads.googleads.v16.services.RecommendationService";
    impl<T> tonic::server::NamedService for RecommendationServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Request message for
/// [SmartCampaignSuggestService.SuggestSmartCampaignBudgetOptions][google.ads.googleads.v16.services.SmartCampaignSuggestService.SuggestSmartCampaignBudgetOptions].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SuggestSmartCampaignBudgetOptionsRequest {
    /// Required. The ID of the customer whose budget options are to be suggested.
    #[prost(string, tag = "1")]
    pub customer_id: ::prost::alloc::string::String,
    /// Required. For first time campaign creation use SuggestionInfo, for
    /// subsequent updates on BudgetOptions based on an already created campaign
    /// use that campaign.
    #[prost(
        oneof = "suggest_smart_campaign_budget_options_request::SuggestionData",
        tags = "2, 3"
    )]
    pub suggestion_data: ::core::option::Option<
        suggest_smart_campaign_budget_options_request::SuggestionData,
    >,
}
/// Nested message and enum types in `SuggestSmartCampaignBudgetOptionsRequest`.
pub mod suggest_smart_campaign_budget_options_request {
    /// Required. For first time campaign creation use SuggestionInfo, for
    /// subsequent updates on BudgetOptions based on an already created campaign
    /// use that campaign.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum SuggestionData {
        /// Required. The resource name of the campaign to get suggestion for.
        #[prost(string, tag = "2")]
        Campaign(::prost::alloc::string::String),
        /// Required. Information needed to get budget options
        #[prost(message, tag = "3")]
        SuggestionInfo(super::SmartCampaignSuggestionInfo),
    }
}
/// Information needed to get suggestion for Smart Campaign. More information
/// provided will help the system to derive better suggestions.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SmartCampaignSuggestionInfo {
    /// Optional. Landing page URL of the campaign.
    #[prost(string, tag = "1")]
    pub final_url: ::prost::alloc::string::String,
    /// Optional. The two letter advertising language for the Smart campaign to be
    /// constructed, default to 'en' if not set.
    #[prost(string, tag = "3")]
    pub language_code: ::prost::alloc::string::String,
    /// Optional. The business ad schedule.
    #[prost(message, repeated, tag = "6")]
    pub ad_schedules: ::prost::alloc::vec::Vec<super::common::AdScheduleInfo>,
    /// Optional. Smart campaign keyword themes. This field may greatly improve
    /// suggestion accuracy and we recommend always setting it if possible.
    #[prost(message, repeated, tag = "7")]
    pub keyword_themes: ::prost::alloc::vec::Vec<super::common::KeywordThemeInfo>,
    /// The business settings to consider when generating suggestions.
    /// Settings are automatically extracted from the business when provided.
    /// Otherwise, these settings must be specified explicitly.
    #[prost(oneof = "smart_campaign_suggestion_info::BusinessSetting", tags = "8, 9")]
    pub business_setting: ::core::option::Option<
        smart_campaign_suggestion_info::BusinessSetting,
    >,
    /// The geo target of the campaign, either a list of locations or
    /// a single proximity shall be specified.
    #[prost(oneof = "smart_campaign_suggestion_info::GeoTarget", tags = "4, 5")]
    pub geo_target: ::core::option::Option<smart_campaign_suggestion_info::GeoTarget>,
}
/// Nested message and enum types in `SmartCampaignSuggestionInfo`.
pub mod smart_campaign_suggestion_info {
    /// A list of locations.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct LocationList {
        /// Required. Locations.
        #[prost(message, repeated, tag = "1")]
        pub locations: ::prost::alloc::vec::Vec<super::super::common::LocationInfo>,
    }
    /// A context that describes a business.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct BusinessContext {
        /// Optional. The name of the business.
        #[prost(string, tag = "1")]
        pub business_name: ::prost::alloc::string::String,
    }
    /// The business settings to consider when generating suggestions.
    /// Settings are automatically extracted from the business when provided.
    /// Otherwise, these settings must be specified explicitly.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum BusinessSetting {
        /// Optional. Context describing the business to advertise.
        #[prost(message, tag = "8")]
        BusinessContext(BusinessContext),
        /// Optional. The resource name of a Business Profile location.
        /// Business Profile location resource names can be fetched through the
        /// Business Profile API and adhere to the following format:
        /// `locations/{locationId}`.
        ///
        /// See the \[Business Profile API\]
        /// (<https://developers.google.com/my-business/reference/businessinformation/rest/v1/accounts.locations>)
        /// for additional details.
        #[prost(string, tag = "9")]
        BusinessProfileLocation(::prost::alloc::string::String),
    }
    /// The geo target of the campaign, either a list of locations or
    /// a single proximity shall be specified.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum GeoTarget {
        /// Optional. The targeting geo location by locations.
        #[prost(message, tag = "4")]
        LocationList(LocationList),
        /// Optional. The targeting geo location by proximity.
        #[prost(message, tag = "5")]
        Proximity(super::super::common::ProximityInfo),
    }
}
/// Response message for
/// [SmartCampaignSuggestService.SuggestSmartCampaignBudgetOptions][google.ads.googleads.v16.services.SmartCampaignSuggestService.SuggestSmartCampaignBudgetOptions].
/// Depending on whether the system could suggest the options, either all of the
/// options or none of them might be returned.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SuggestSmartCampaignBudgetOptionsResponse {
    /// Optional. The lowest budget option.
    #[prost(message, optional, tag = "1")]
    pub low: ::core::option::Option<
        suggest_smart_campaign_budget_options_response::BudgetOption,
    >,
    /// Optional. The recommended budget option.
    #[prost(message, optional, tag = "2")]
    pub recommended: ::core::option::Option<
        suggest_smart_campaign_budget_options_response::BudgetOption,
    >,
    /// Optional. The highest budget option.
    #[prost(message, optional, tag = "3")]
    pub high: ::core::option::Option<
        suggest_smart_campaign_budget_options_response::BudgetOption,
    >,
}
/// Nested message and enum types in `SuggestSmartCampaignBudgetOptionsResponse`.
pub mod suggest_smart_campaign_budget_options_response {
    /// Performance metrics for a given budget option.
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Metrics {
        /// The estimated min daily clicks.
        #[prost(int64, tag = "1")]
        pub min_daily_clicks: i64,
        /// The estimated max daily clicks.
        #[prost(int64, tag = "2")]
        pub max_daily_clicks: i64,
    }
    /// Smart Campaign budget option.
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct BudgetOption {
        /// The amount of the budget, in the local currency for the account.
        /// Amount is specified in micros, where one million is equivalent to one
        /// currency unit.
        #[prost(int64, tag = "1")]
        pub daily_amount_micros: i64,
        /// Metrics pertaining to the suggested budget, could be empty if there is
        /// not enough information to derive the estimates.
        #[prost(message, optional, tag = "2")]
        pub metrics: ::core::option::Option<Metrics>,
    }
}
/// Request message for
/// [SmartCampaignSuggestService.SuggestSmartCampaignAd][google.ads.googleads.v16.services.SmartCampaignSuggestService.SuggestSmartCampaignAd].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SuggestSmartCampaignAdRequest {
    /// Required. The ID of the customer.
    #[prost(string, tag = "1")]
    pub customer_id: ::prost::alloc::string::String,
    /// Required. Inputs used to suggest a Smart campaign ad.
    /// Required fields: final_url, language_code, keyword_themes.
    /// Optional but recommended fields to improve the quality of the suggestion:
    /// business_setting and geo_target.
    #[prost(message, optional, tag = "2")]
    pub suggestion_info: ::core::option::Option<SmartCampaignSuggestionInfo>,
}
/// Response message for
/// [SmartCampaignSuggestService.SuggestSmartCampaignAd][google.ads.googleads.v16.services.SmartCampaignSuggestService.SuggestSmartCampaignAd].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SuggestSmartCampaignAdResponse {
    /// Optional. Ad info includes 3 creative headlines and 2 creative
    /// descriptions.
    #[prost(message, optional, tag = "1")]
    pub ad_info: ::core::option::Option<super::common::SmartCampaignAdInfo>,
}
/// Request message for
/// [SmartCampaignSuggestService.SuggestKeywordThemes][google.ads.googleads.v16.services.SmartCampaignSuggestService.SuggestKeywordThemes].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SuggestKeywordThemesRequest {
    /// Required. The ID of the customer.
    #[prost(string, tag = "1")]
    pub customer_id: ::prost::alloc::string::String,
    /// Required. Information to get keyword theme suggestions.
    /// Required fields:
    ///
    /// * suggestion_info.final_url
    /// * suggestion_info.language_code
    /// * suggestion_info.geo_target
    ///
    /// Recommended fields:
    ///
    /// * suggestion_info.business_setting
    #[prost(message, optional, tag = "2")]
    pub suggestion_info: ::core::option::Option<SmartCampaignSuggestionInfo>,
}
/// Response message for
/// [SmartCampaignSuggestService.SuggestKeywordThemes][google.ads.googleads.v16.services.SmartCampaignSuggestService.SuggestKeywordThemes].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SuggestKeywordThemesResponse {
    /// Smart campaign keyword theme suggestions.
    #[prost(message, repeated, tag = "2")]
    pub keyword_themes: ::prost::alloc::vec::Vec<
        suggest_keyword_themes_response::KeywordTheme,
    >,
}
/// Nested message and enum types in `SuggestKeywordThemesResponse`.
pub mod suggest_keyword_themes_response {
    /// A Smart campaign keyword theme suggestion.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct KeywordTheme {
        /// A keyword theme.
        #[prost(oneof = "keyword_theme::KeywordTheme", tags = "1, 2")]
        pub keyword_theme: ::core::option::Option<keyword_theme::KeywordTheme>,
    }
    /// Nested message and enum types in `KeywordTheme`.
    pub mod keyword_theme {
        /// A keyword theme.
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum KeywordTheme {
            /// A Smart campaign keyword theme constant.
            #[prost(message, tag = "1")]
            KeywordThemeConstant(super::super::super::resources::KeywordThemeConstant),
            /// A free-form text keyword theme.
            #[prost(string, tag = "2")]
            FreeFormKeywordTheme(::prost::alloc::string::String),
        }
    }
}
/// Generated server implementations.
pub mod smart_campaign_suggest_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with SmartCampaignSuggestServiceServer.
    #[async_trait]
    pub trait SmartCampaignSuggestService: std::marker::Send + std::marker::Sync + 'static {
        /// Returns BudgetOption suggestions.
        async fn suggest_smart_campaign_budget_options(
            &self,
            request: tonic::Request<super::SuggestSmartCampaignBudgetOptionsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SuggestSmartCampaignBudgetOptionsResponse>,
            tonic::Status,
        >;
        /// Suggests a Smart campaign ad compatible with the Ad family of resources,
        /// based on data points such as targeting and the business to advertise.
        async fn suggest_smart_campaign_ad(
            &self,
            request: tonic::Request<super::SuggestSmartCampaignAdRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SuggestSmartCampaignAdResponse>,
            tonic::Status,
        >;
        /// Suggests keyword themes to advertise on.
        async fn suggest_keyword_themes(
            &self,
            request: tonic::Request<super::SuggestKeywordThemesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SuggestKeywordThemesResponse>,
            tonic::Status,
        >;
    }
    /// Service to get suggestions for Smart Campaigns.
    #[derive(Debug)]
    pub struct SmartCampaignSuggestServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> SmartCampaignSuggestServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>>
    for SmartCampaignSuggestServiceServer<T>
    where
        T: SmartCampaignSuggestService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/google.ads.googleads.v16.services.SmartCampaignSuggestService/SuggestSmartCampaignBudgetOptions" => {
                    #[allow(non_camel_case_types)]
                    struct SuggestSmartCampaignBudgetOptionsSvc<
                        T: SmartCampaignSuggestService,
                    >(
                        pub Arc<T>,
                    );
                    impl<
                        T: SmartCampaignSuggestService,
                    > tonic::server::UnaryService<
                        super::SuggestSmartCampaignBudgetOptionsRequest,
                    > for SuggestSmartCampaignBudgetOptionsSvc<T> {
                        type Response = super::SuggestSmartCampaignBudgetOptionsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::SuggestSmartCampaignBudgetOptionsRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as SmartCampaignSuggestService>::suggest_smart_campaign_budget_options(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SuggestSmartCampaignBudgetOptionsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.ads.googleads.v16.services.SmartCampaignSuggestService/SuggestSmartCampaignAd" => {
                    #[allow(non_camel_case_types)]
                    struct SuggestSmartCampaignAdSvc<T: SmartCampaignSuggestService>(
                        pub Arc<T>,
                    );
                    impl<
                        T: SmartCampaignSuggestService,
                    > tonic::server::UnaryService<super::SuggestSmartCampaignAdRequest>
                    for SuggestSmartCampaignAdSvc<T> {
                        type Response = super::SuggestSmartCampaignAdResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::SuggestSmartCampaignAdRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as SmartCampaignSuggestService>::suggest_smart_campaign_ad(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SuggestSmartCampaignAdSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.ads.googleads.v16.services.SmartCampaignSuggestService/SuggestKeywordThemes" => {
                    #[allow(non_camel_case_types)]
                    struct SuggestKeywordThemesSvc<T: SmartCampaignSuggestService>(
                        pub Arc<T>,
                    );
                    impl<
                        T: SmartCampaignSuggestService,
                    > tonic::server::UnaryService<super::SuggestKeywordThemesRequest>
                    for SuggestKeywordThemesSvc<T> {
                        type Response = super::SuggestKeywordThemesResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::SuggestKeywordThemesRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as SmartCampaignSuggestService>::suggest_keyword_themes(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SuggestKeywordThemesSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for SmartCampaignSuggestServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "google.ads.googleads.v16.services.SmartCampaignSuggestService";
    impl<T> tonic::server::NamedService for SmartCampaignSuggestServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Request message for
/// [ThirdPartyAppAnalyticsLinkService.RegenerateShareableLinkId][google.ads.googleads.v16.services.ThirdPartyAppAnalyticsLinkService.RegenerateShareableLinkId].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RegenerateShareableLinkIdRequest {
    /// Resource name of the third party app analytics link.
    #[prost(string, tag = "1")]
    pub resource_name: ::prost::alloc::string::String,
}
/// Response message for
/// [ThirdPartyAppAnalyticsLinkService.RegenerateShareableLinkId][google.ads.googleads.v16.services.ThirdPartyAppAnalyticsLinkService.RegenerateShareableLinkId].
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RegenerateShareableLinkIdResponse {}
/// Generated server implementations.
pub mod third_party_app_analytics_link_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with ThirdPartyAppAnalyticsLinkServiceServer.
    #[async_trait]
    pub trait ThirdPartyAppAnalyticsLinkService: std::marker::Send + std::marker::Sync + 'static {
        /// Regenerate ThirdPartyAppAnalyticsLink.shareable_link_id that should be
        /// provided to the third party when setting up app analytics.
        ///
        /// List of thrown errors:
        ///   [AuthenticationError]()
        ///   [AuthorizationError]()
        ///   [HeaderError]()
        ///   [InternalError]()
        ///   [QuotaError]()
        ///   [RequestError]()
        async fn regenerate_shareable_link_id(
            &self,
            request: tonic::Request<super::RegenerateShareableLinkIdRequest>,
        ) -> std::result::Result<
            tonic::Response<super::RegenerateShareableLinkIdResponse>,
            tonic::Status,
        >;
    }
    /// This service allows management of links between Google Ads and third party
    /// app analytics.
    #[derive(Debug)]
    pub struct ThirdPartyAppAnalyticsLinkServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> ThirdPartyAppAnalyticsLinkServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>>
    for ThirdPartyAppAnalyticsLinkServiceServer<T>
    where
        T: ThirdPartyAppAnalyticsLinkService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/google.ads.googleads.v16.services.ThirdPartyAppAnalyticsLinkService/RegenerateShareableLinkId" => {
                    #[allow(non_camel_case_types)]
                    struct RegenerateShareableLinkIdSvc<
                        T: ThirdPartyAppAnalyticsLinkService,
                    >(
                        pub Arc<T>,
                    );
                    impl<
                        T: ThirdPartyAppAnalyticsLinkService,
                    > tonic::server::UnaryService<
                        super::RegenerateShareableLinkIdRequest,
                    > for RegenerateShareableLinkIdSvc<T> {
                        type Response = super::RegenerateShareableLinkIdResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::RegenerateShareableLinkIdRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ThirdPartyAppAnalyticsLinkService>::regenerate_shareable_link_id(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = RegenerateShareableLinkIdSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for ThirdPartyAppAnalyticsLinkServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "google.ads.googleads.v16.services.ThirdPartyAppAnalyticsLinkService";
    impl<T> tonic::server::NamedService for ThirdPartyAppAnalyticsLinkServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Request message for
/// [TravelAssetSuggestionService.SuggestTravelAssets][google.ads.googleads.v16.services.TravelAssetSuggestionService.SuggestTravelAssets].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SuggestTravelAssetsRequest {
    /// Required. The ID of the customer.
    #[prost(string, tag = "1")]
    pub customer_id: ::prost::alloc::string::String,
    /// Required. The language specifications in BCP 47 format (for example, en-US,
    /// zh-CN, etc.) for the asset suggestions. Text will be in this language.
    /// Usually matches one of the campaign target languages.
    #[prost(string, tag = "2")]
    pub language_option: ::prost::alloc::string::String,
    /// The Google Maps Place IDs of hotels for which assets are requested. See
    /// <https://developers.google.com/places/web-service/place-id> for more
    /// information.
    #[prost(string, repeated, tag = "4")]
    pub place_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Response message for
/// [TravelAssetSuggestionService.SuggestTravelAssets][google.ads.googleads.v16.services.TravelAssetSuggestionService.SuggestTravelAssets].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SuggestTravelAssetsResponse {
    /// Asset suggestions for each place ID submitted in the request.
    #[prost(message, repeated, tag = "1")]
    pub hotel_asset_suggestions: ::prost::alloc::vec::Vec<HotelAssetSuggestion>,
}
/// Message containing the asset suggestions for a hotel.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HotelAssetSuggestion {
    /// Google Places ID of the hotel.
    #[prost(string, tag = "1")]
    pub place_id: ::prost::alloc::string::String,
    /// Suggested final URL for an AssetGroup.
    #[prost(string, tag = "2")]
    pub final_url: ::prost::alloc::string::String,
    /// Hotel name in requested language.
    #[prost(string, tag = "3")]
    pub hotel_name: ::prost::alloc::string::String,
    /// Call to action type.
    #[prost(
        enumeration = "super::enums::call_to_action_type_enum::CallToActionType",
        tag = "4"
    )]
    pub call_to_action: i32,
    /// Text assets such as headline, description, etc.
    #[prost(message, repeated, tag = "5")]
    pub text_assets: ::prost::alloc::vec::Vec<HotelTextAsset>,
    /// Image assets such as landscape/portrait/square, etc.
    #[prost(message, repeated, tag = "6")]
    pub image_assets: ::prost::alloc::vec::Vec<HotelImageAsset>,
    /// The status of the hotel asset suggestion.
    #[prost(
        enumeration = "super::enums::hotel_asset_suggestion_status_enum::HotelAssetSuggestionStatus",
        tag = "7"
    )]
    pub status: i32,
}
/// A single text asset suggestion for a hotel.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HotelTextAsset {
    /// Asset text in requested language.
    #[prost(string, tag = "1")]
    pub text: ::prost::alloc::string::String,
    /// The text asset type. For example, HEADLINE, DESCRIPTION, etc.
    #[prost(
        enumeration = "super::enums::asset_field_type_enum::AssetFieldType",
        tag = "2"
    )]
    pub asset_field_type: i32,
}
/// A single image asset suggestion for a hotel.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HotelImageAsset {
    /// URI for the image.
    #[prost(string, tag = "1")]
    pub uri: ::prost::alloc::string::String,
    /// The Image asset type. For example, MARKETING_IMAGE,
    /// PORTRAIT_MARKETING_IMAGE, etc.
    #[prost(
        enumeration = "super::enums::asset_field_type_enum::AssetFieldType",
        tag = "2"
    )]
    pub asset_field_type: i32,
}
/// Generated server implementations.
pub mod travel_asset_suggestion_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with TravelAssetSuggestionServiceServer.
    #[async_trait]
    pub trait TravelAssetSuggestionService: std::marker::Send + std::marker::Sync + 'static {
        /// Returns Travel Asset suggestions. Asset
        /// suggestions are returned on a best-effort basis. There are no guarantees
        /// that all possible asset types will be returned for any given hotel
        /// property.
        async fn suggest_travel_assets(
            &self,
            request: tonic::Request<super::SuggestTravelAssetsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SuggestTravelAssetsResponse>,
            tonic::Status,
        >;
    }
    /// Service to retrieve Travel asset suggestions.
    #[derive(Debug)]
    pub struct TravelAssetSuggestionServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> TravelAssetSuggestionServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>>
    for TravelAssetSuggestionServiceServer<T>
    where
        T: TravelAssetSuggestionService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/google.ads.googleads.v16.services.TravelAssetSuggestionService/SuggestTravelAssets" => {
                    #[allow(non_camel_case_types)]
                    struct SuggestTravelAssetsSvc<T: TravelAssetSuggestionService>(
                        pub Arc<T>,
                    );
                    impl<
                        T: TravelAssetSuggestionService,
                    > tonic::server::UnaryService<super::SuggestTravelAssetsRequest>
                    for SuggestTravelAssetsSvc<T> {
                        type Response = super::SuggestTravelAssetsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::SuggestTravelAssetsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as TravelAssetSuggestionService>::suggest_travel_assets(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SuggestTravelAssetsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for TravelAssetSuggestionServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "google.ads.googleads.v16.services.TravelAssetSuggestionService";
    impl<T> tonic::server::NamedService for TravelAssetSuggestionServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Request message for
/// [UserDataService.UploadUserData][google.ads.googleads.v16.services.UserDataService.UploadUserData]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UploadUserDataRequest {
    /// Required. The ID of the customer for which to update the user data.
    #[prost(string, tag = "1")]
    pub customer_id: ::prost::alloc::string::String,
    /// Required. The list of operations to be done.
    #[prost(message, repeated, tag = "3")]
    pub operations: ::prost::alloc::vec::Vec<UserDataOperation>,
    /// Metadata of the request.
    #[prost(oneof = "upload_user_data_request::Metadata", tags = "2")]
    pub metadata: ::core::option::Option<upload_user_data_request::Metadata>,
}
/// Nested message and enum types in `UploadUserDataRequest`.
pub mod upload_user_data_request {
    /// Metadata of the request.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Metadata {
        /// Metadata for data updates to a Customer Match user list.
        #[prost(message, tag = "2")]
        CustomerMatchUserListMetadata(
            super::super::common::CustomerMatchUserListMetadata,
        ),
    }
}
/// Operation to be made for the UploadUserDataRequest.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UserDataOperation {
    /// Operation to be made for the UploadUserDataRequest.
    #[prost(oneof = "user_data_operation::Operation", tags = "1, 2")]
    pub operation: ::core::option::Option<user_data_operation::Operation>,
}
/// Nested message and enum types in `UserDataOperation`.
pub mod user_data_operation {
    /// Operation to be made for the UploadUserDataRequest.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Operation {
        /// The list of user data to be appended to the user list.
        #[prost(message, tag = "1")]
        Create(super::super::common::UserData),
        /// The list of user data to be removed from the user list.
        #[prost(message, tag = "2")]
        Remove(super::super::common::UserData),
    }
}
/// Response message for
/// [UserDataService.UploadUserData][google.ads.googleads.v16.services.UserDataService.UploadUserData]
/// Uploads made through this service will not be visible under the 'Segment
/// members' section for the Customer Match List in the Google Ads UI.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UploadUserDataResponse {
    /// The date time at which the request was received by API, formatted as
    /// "yyyy-mm-dd hh:mm:ss+|-hh:mm", for example, "2019-01-01 12:32:45-08:00".
    #[prost(string, optional, tag = "3")]
    pub upload_date_time: ::core::option::Option<::prost::alloc::string::String>,
    /// Number of upload data operations received by API.
    #[prost(int32, optional, tag = "4")]
    pub received_operations_count: ::core::option::Option<i32>,
}
/// Generated server implementations.
pub mod user_data_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with UserDataServiceServer.
    #[async_trait]
    pub trait UserDataService: std::marker::Send + std::marker::Sync + 'static {
        /// Uploads the given user data.
        ///
        /// List of thrown errors:
        ///   [AuthenticationError]()
        ///   [AuthorizationError]()
        ///   [CollectionSizeError]()
        ///   [FieldError]()
        ///   [HeaderError]()
        ///   [InternalError]()
        ///   [MutateError]()
        ///   [OfflineUserDataJobError]()
        ///   [QuotaError]()
        ///   [RequestError]()
        ///   [UserDataError]()
        async fn upload_user_data(
            &self,
            request: tonic::Request<super::UploadUserDataRequest>,
        ) -> std::result::Result<
            tonic::Response<super::UploadUserDataResponse>,
            tonic::Status,
        >;
    }
    /// Service to manage user data uploads.
    /// Any uploads made to a Customer Match list through this service will be
    /// eligible for matching as per the customer matching process. See
    /// https://support.google.com/google-ads/answer/7474263. However, the uploads
    /// made through this service will not be visible under the 'Segment members'
    /// section for the Customer Match List in the Google Ads UI.
    #[derive(Debug)]
    pub struct UserDataServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> UserDataServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for UserDataServiceServer<T>
    where
        T: UserDataService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/google.ads.googleads.v16.services.UserDataService/UploadUserData" => {
                    #[allow(non_camel_case_types)]
                    struct UploadUserDataSvc<T: UserDataService>(pub Arc<T>);
                    impl<
                        T: UserDataService,
                    > tonic::server::UnaryService<super::UploadUserDataRequest>
                    for UploadUserDataSvc<T> {
                        type Response = super::UploadUserDataResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::UploadUserDataRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as UserDataService>::upload_user_data(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = UploadUserDataSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for UserDataServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "google.ads.googleads.v16.services.UserDataService";
    impl<T> tonic::server::NamedService for UserDataServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
