// This file is @generated by prost-build.
/// The values associated with a key of an attribute.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AttributeValues {
    /// The list of values associated with a key.
    #[prost(bytes = "vec", repeated, tag = "1")]
    pub values: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
}
/// A message that is published by publishers and delivered to subscribers.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PubSubMessage {
    /// The key used for routing messages to partitions or for compaction (e.g.,
    /// keep the last N messages per key). If the key is empty, the message is
    /// routed to an arbitrary partition.
    #[prost(bytes = "vec", tag = "1")]
    pub key: ::prost::alloc::vec::Vec<u8>,
    /// The payload of the message.
    #[prost(bytes = "vec", tag = "2")]
    pub data: ::prost::alloc::vec::Vec<u8>,
    /// Optional attributes that can be used for message metadata/headers.
    #[prost(map = "string, message", tag = "3")]
    pub attributes: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        AttributeValues,
    >,
    /// An optional, user-specified event time.
    #[prost(message, optional, tag = "4")]
    pub event_time: ::core::option::Option<::prost_types::Timestamp>,
}
/// A cursor that describes the position of a message within a topic partition.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Cursor {
    /// The offset of a message within a topic partition. Must be greater than or
    /// equal 0.
    #[prost(int64, tag = "1")]
    pub offset: i64,
}
/// A message that has been stored and sequenced by the Pub/Sub Lite system.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SequencedMessage {
    /// The position of a message within the partition where it is stored.
    #[prost(message, optional, tag = "1")]
    pub cursor: ::core::option::Option<Cursor>,
    /// The time when the message was received by the server when it was first
    /// published.
    #[prost(message, optional, tag = "2")]
    pub publish_time: ::core::option::Option<::prost_types::Timestamp>,
    /// The user message.
    #[prost(message, optional, tag = "3")]
    pub message: ::core::option::Option<PubSubMessage>,
    /// The size in bytes of this message for flow control and quota purposes.
    #[prost(int64, tag = "4")]
    pub size_bytes: i64,
}
/// Metadata about a reservation resource.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Reservation {
    /// The name of the reservation.
    /// Structured like:
    /// projects/{project_number}/locations/{location}/reservations/{reservation_id}
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// The reserved throughput capacity. Every unit of throughput capacity is
    /// equivalent to 1 MiB/s of published messages or 2 MiB/s of subscribed
    /// messages.
    ///
    /// Any topics which are declared as using capacity from a Reservation will
    /// consume resources from this reservation instead of being charged
    /// individually.
    #[prost(int64, tag = "2")]
    pub throughput_capacity: i64,
}
/// Metadata about a topic resource.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Topic {
    /// The name of the topic.
    /// Structured like:
    /// projects/{project_number}/locations/{location}/topics/{topic_id}
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// The settings for this topic's partitions.
    #[prost(message, optional, tag = "2")]
    pub partition_config: ::core::option::Option<topic::PartitionConfig>,
    /// The settings for this topic's message retention.
    #[prost(message, optional, tag = "3")]
    pub retention_config: ::core::option::Option<topic::RetentionConfig>,
    /// The settings for this topic's Reservation usage.
    #[prost(message, optional, tag = "4")]
    pub reservation_config: ::core::option::Option<topic::ReservationConfig>,
}
/// Nested message and enum types in `Topic`.
pub mod topic {
    /// The settings for a topic's partitions.
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PartitionConfig {
        /// The number of partitions in the topic. Must be at least 1.
        ///
        /// Once a topic has been created the number of partitions can be increased
        /// but not decreased. Message ordering is not guaranteed across a topic
        /// resize. For more information see
        /// <https://cloud.google.com/pubsub/lite/docs/topics#scaling_capacity>
        #[prost(int64, tag = "1")]
        pub count: i64,
        /// The throughput dimension of this topic.
        #[prost(oneof = "partition_config::Dimension", tags = "2, 3")]
        pub dimension: ::core::option::Option<partition_config::Dimension>,
    }
    /// Nested message and enum types in `PartitionConfig`.
    pub mod partition_config {
        /// The throughput capacity configuration for each partition.
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Capacity {
            /// Publish throughput capacity per partition in MiB/s.
            /// Must be >= 4 and <= 16.
            #[prost(int32, tag = "1")]
            pub publish_mib_per_sec: i32,
            /// Subscribe throughput capacity per partition in MiB/s.
            /// Must be >= 4 and <= 32.
            #[prost(int32, tag = "2")]
            pub subscribe_mib_per_sec: i32,
        }
        /// The throughput dimension of this topic.
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Dimension {
            /// DEPRECATED: Use capacity instead which can express a superset of
            /// configurations.
            ///
            /// Every partition in the topic is allocated throughput equivalent to
            /// `scale` times the standard partition throughput (4 MiB/s). This is also
            /// reflected in the cost of this topic; a topic with `scale` of 2 and
            /// count of 10 is charged for 20 partitions. This value must be in the
            /// range \[1,4\].
            #[prost(int32, tag = "2")]
            Scale(i32),
            /// The capacity configuration.
            #[prost(message, tag = "3")]
            Capacity(Capacity),
        }
    }
    /// The settings for a topic's message retention.
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct RetentionConfig {
        /// The provisioned storage, in bytes, per partition. If the number of bytes
        /// stored in any of the topic's partitions grows beyond this value, older
        /// messages will be dropped to make room for newer ones, regardless of the
        /// value of `period`.
        #[prost(int64, tag = "1")]
        pub per_partition_bytes: i64,
        /// How long a published message is retained. If unset, messages will be
        /// retained as long as the bytes retained for each partition is below
        /// `per_partition_bytes`.
        #[prost(message, optional, tag = "2")]
        pub period: ::core::option::Option<::prost_types::Duration>,
    }
    /// The settings for this topic's Reservation usage.
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ReservationConfig {
        /// The Reservation to use for this topic's throughput capacity.
        /// Structured like:
        /// projects/{project_number}/locations/{location}/reservations/{reservation_id}
        #[prost(string, tag = "1")]
        pub throughput_reservation: ::prost::alloc::string::String,
    }
}
/// Metadata about a subscription resource.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Subscription {
    /// The name of the subscription.
    /// Structured like:
    /// projects/{project_number}/locations/{location}/subscriptions/{subscription_id}
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// The name of the topic this subscription is attached to.
    /// Structured like:
    /// projects/{project_number}/locations/{location}/topics/{topic_id}
    #[prost(string, tag = "2")]
    pub topic: ::prost::alloc::string::String,
    /// The settings for this subscription's message delivery.
    #[prost(message, optional, tag = "3")]
    pub delivery_config: ::core::option::Option<subscription::DeliveryConfig>,
    /// If present, messages are automatically written from the Pub/Sub Lite topic
    /// associated with this subscription to a destination.
    #[prost(message, optional, tag = "4")]
    pub export_config: ::core::option::Option<ExportConfig>,
}
/// Nested message and enum types in `Subscription`.
pub mod subscription {
    /// The settings for a subscription's message delivery.
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct DeliveryConfig {
        /// The DeliveryRequirement for this subscription.
        #[prost(enumeration = "delivery_config::DeliveryRequirement", tag = "3")]
        pub delivery_requirement: i32,
    }
    /// Nested message and enum types in `DeliveryConfig`.
    pub mod delivery_config {
        /// When this subscription should send messages to subscribers relative to
        /// messages persistence in storage. For details, see [Creating Lite
        /// subscriptions](<https://cloud.google.com/pubsub/lite/docs/subscriptions#creating_lite_subscriptions>).
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum DeliveryRequirement {
            /// Default value. This value is unused.
            Unspecified = 0,
            /// The server does not wait for a published message to be successfully
            /// written to storage before delivering it to subscribers.
            DeliverImmediately = 1,
            /// The server will not deliver a published message to subscribers until
            /// the message has been successfully written to storage. This will result
            /// in higher end-to-end latency, but consistent delivery.
            DeliverAfterStored = 2,
        }
        impl DeliveryRequirement {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    DeliveryRequirement::Unspecified => {
                        "DELIVERY_REQUIREMENT_UNSPECIFIED"
                    }
                    DeliveryRequirement::DeliverImmediately => "DELIVER_IMMEDIATELY",
                    DeliveryRequirement::DeliverAfterStored => "DELIVER_AFTER_STORED",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "DELIVERY_REQUIREMENT_UNSPECIFIED" => Some(Self::Unspecified),
                    "DELIVER_IMMEDIATELY" => Some(Self::DeliverImmediately),
                    "DELIVER_AFTER_STORED" => Some(Self::DeliverAfterStored),
                    _ => None,
                }
            }
        }
    }
}
/// Configuration for a Pub/Sub Lite subscription that writes messages to a
/// destination. User subscriber clients must not connect to this subscription.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExportConfig {
    /// The desired state of this export. Setting this to values other than
    /// `ACTIVE` and `PAUSED` will result in an error.
    #[prost(enumeration = "export_config::State", tag = "1")]
    pub desired_state: i32,
    /// Output only. The current state of the export, which may be different to the
    /// desired state due to errors. This field is output only.
    #[prost(enumeration = "export_config::State", tag = "6")]
    pub current_state: i32,
    /// Optional. The name of an optional Pub/Sub Lite topic to publish messages
    /// that can not be exported to the destination. For example, the message can
    /// not be published to the Pub/Sub service because it does not satisfy the
    /// constraints documented at <https://cloud.google.com/pubsub/docs/publisher.>
    ///
    /// Structured like:
    /// projects/{project_number}/locations/{location}/topics/{topic_id}.
    /// Must be within the same project and location as the subscription. The topic
    /// may be changed or removed.
    #[prost(string, tag = "5")]
    pub dead_letter_topic: ::prost::alloc::string::String,
    /// The destination to export to. Required.
    #[prost(oneof = "export_config::Destination", tags = "3")]
    pub destination: ::core::option::Option<export_config::Destination>,
}
/// Nested message and enum types in `ExportConfig`.
pub mod export_config {
    /// Configuration for exporting to a Pub/Sub topic.
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PubSubConfig {
        /// The name of the Pub/Sub topic.
        /// Structured like: projects/{project_number}/topics/{topic_id}.
        /// The topic may be changed.
        #[prost(string, tag = "1")]
        pub topic: ::prost::alloc::string::String,
    }
    /// The desired export state.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        /// Default value. This value is unused.
        Unspecified = 0,
        /// Messages are being exported.
        Active = 1,
        /// Exporting messages is suspended.
        Paused = 2,
        /// Messages cannot be exported due to permission denied errors. Output only.
        PermissionDenied = 3,
        /// Messages cannot be exported due to missing resources. Output only.
        NotFound = 4,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                State::Unspecified => "STATE_UNSPECIFIED",
                State::Active => "ACTIVE",
                State::Paused => "PAUSED",
                State::PermissionDenied => "PERMISSION_DENIED",
                State::NotFound => "NOT_FOUND",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "ACTIVE" => Some(Self::Active),
                "PAUSED" => Some(Self::Paused),
                "PERMISSION_DENIED" => Some(Self::PermissionDenied),
                "NOT_FOUND" => Some(Self::NotFound),
                _ => None,
            }
        }
    }
    /// The destination to export to. Required.
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Destination {
        /// Messages are automatically written from the Pub/Sub Lite topic associated
        /// with this subscription to a Pub/Sub topic.
        #[prost(message, tag = "3")]
        PubsubConfig(PubSubConfig),
    }
}
/// A target publish or event time. Can be used for seeking to or retrieving the
/// corresponding cursor.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TimeTarget {
    /// The type of message time to query.
    #[prost(oneof = "time_target::Time", tags = "1, 2")]
    pub time: ::core::option::Option<time_target::Time>,
}
/// Nested message and enum types in `TimeTarget`.
pub mod time_target {
    /// The type of message time to query.
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Time {
        /// Request the cursor of the first message with publish time greater than or
        /// equal to `publish_time`. All messages thereafter are guaranteed to have
        /// publish times >= `publish_time`.
        #[prost(message, tag = "1")]
        PublishTime(::prost_types::Timestamp),
        /// Request the cursor of the first message with event time greater than or
        /// equal to `event_time`. If messages are missing an event time, the publish
        /// time is used as a fallback. As event times are user supplied, subsequent
        /// messages may have event times less than `event_time` and should be
        /// filtered by the client, if necessary.
        #[prost(message, tag = "2")]
        EventTime(::prost_types::Timestamp),
    }
}
/// Request for CreateTopic.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateTopicRequest {
    /// Required. The parent location in which to create the topic.
    /// Structured like `projects/{project_number}/locations/{location}`.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. Configuration of the topic to create. Its `name` field is
    /// ignored.
    #[prost(message, optional, tag = "2")]
    pub topic: ::core::option::Option<Topic>,
    /// Required. The ID to use for the topic, which will become the final
    /// component of the topic's name.
    ///
    /// This value is structured like: `my-topic-name`.
    #[prost(string, tag = "3")]
    pub topic_id: ::prost::alloc::string::String,
}
/// Request for GetTopic.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetTopicRequest {
    /// Required. The name of the topic whose configuration to return.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request for GetTopicPartitions.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetTopicPartitionsRequest {
    /// Required. The topic whose partition information to return.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Response for GetTopicPartitions.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TopicPartitions {
    /// The number of partitions in the topic.
    #[prost(int64, tag = "1")]
    pub partition_count: i64,
}
/// Request for ListTopics.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListTopicsRequest {
    /// Required. The parent whose topics are to be listed.
    /// Structured like `projects/{project_number}/locations/{location}`.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// The maximum number of topics to return. The service may return fewer than
    /// this value.
    /// If unset or zero, all topics for the parent will be returned.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// A page token, received from a previous `ListTopics` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to `ListTopics` must match
    /// the call that provided the page token.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
/// Response for ListTopics.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListTopicsResponse {
    /// The list of topic in the requested parent. The order of the topics is
    /// unspecified.
    #[prost(message, repeated, tag = "1")]
    pub topics: ::prost::alloc::vec::Vec<Topic>,
    /// A token that can be sent as `page_token` to retrieve the next page of
    /// results. If this field is omitted, there are no more results.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// Request for UpdateTopic.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateTopicRequest {
    /// Required. The topic to update. Its `name` field must be populated.
    #[prost(message, optional, tag = "1")]
    pub topic: ::core::option::Option<Topic>,
    /// Required. A mask specifying the topic fields to change.
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
/// Request for DeleteTopic.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteTopicRequest {
    /// Required. The name of the topic to delete.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request for ListTopicSubscriptions.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListTopicSubscriptionsRequest {
    /// Required. The name of the topic whose subscriptions to list.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// The maximum number of subscriptions to return. The service may return fewer
    /// than this value.
    /// If unset or zero, all subscriptions for the given topic will be returned.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// A page token, received from a previous `ListTopicSubscriptions` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to `ListTopicSubscriptions`
    /// must match the call that provided the page token.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
/// Response for ListTopicSubscriptions.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListTopicSubscriptionsResponse {
    /// The names of subscriptions attached to the topic. The order of the
    /// subscriptions is unspecified.
    #[prost(string, repeated, tag = "1")]
    pub subscriptions: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// A token that can be sent as `page_token` to retrieve the next page of
    /// results. If this field is omitted, there are no more results.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// Request for CreateSubscription.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateSubscriptionRequest {
    /// Required. The parent location in which to create the subscription.
    /// Structured like `projects/{project_number}/locations/{location}`.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. Configuration of the subscription to create. Its `name` field is
    /// ignored.
    #[prost(message, optional, tag = "2")]
    pub subscription: ::core::option::Option<Subscription>,
    /// Required. The ID to use for the subscription, which will become the final
    /// component of the subscription's name.
    ///
    /// This value is structured like: `my-sub-name`.
    #[prost(string, tag = "3")]
    pub subscription_id: ::prost::alloc::string::String,
    /// If true, the newly created subscription will only receive messages
    /// published after the subscription was created. Otherwise, the entire
    /// message backlog will be received on the subscription. Defaults to false.
    #[prost(bool, tag = "4")]
    pub skip_backlog: bool,
}
/// Request for GetSubscription.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSubscriptionRequest {
    /// Required. The name of the subscription whose configuration to return.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request for ListSubscriptions.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSubscriptionsRequest {
    /// Required. The parent whose subscriptions are to be listed.
    /// Structured like `projects/{project_number}/locations/{location}`.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// The maximum number of subscriptions to return. The service may return fewer
    /// than this value.
    /// If unset or zero, all subscriptions for the parent will be returned.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// A page token, received from a previous `ListSubscriptions` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to `ListSubscriptions` must
    /// match the call that provided the page token.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
/// Response for ListSubscriptions.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSubscriptionsResponse {
    /// The list of subscriptions in the requested parent. The order of the
    /// subscriptions is unspecified.
    #[prost(message, repeated, tag = "1")]
    pub subscriptions: ::prost::alloc::vec::Vec<Subscription>,
    /// A token that can be sent as `page_token` to retrieve the next page of
    /// results. If this field is omitted, there are no more results.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// Request for UpdateSubscription.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateSubscriptionRequest {
    /// Required. The subscription to update. Its `name` field must be populated.
    /// Topic field must not be populated.
    #[prost(message, optional, tag = "1")]
    pub subscription: ::core::option::Option<Subscription>,
    /// Required. A mask specifying the subscription fields to change.
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
/// Request for DeleteSubscription.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteSubscriptionRequest {
    /// Required. The name of the subscription to delete.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request for SeekSubscription.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SeekSubscriptionRequest {
    /// Required. The name of the subscription to seek.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// The target to seek to. Must be set.
    #[prost(oneof = "seek_subscription_request::Target", tags = "2, 3")]
    pub target: ::core::option::Option<seek_subscription_request::Target>,
}
/// Nested message and enum types in `SeekSubscriptionRequest`.
pub mod seek_subscription_request {
    /// A named position with respect to the message backlog.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum NamedTarget {
        /// Unspecified named target. Do not use.
        Unspecified = 0,
        /// Seek to the oldest retained message.
        Tail = 1,
        /// Seek past all recently published messages, skipping the entire message
        /// backlog.
        Head = 2,
    }
    impl NamedTarget {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                NamedTarget::Unspecified => "NAMED_TARGET_UNSPECIFIED",
                NamedTarget::Tail => "TAIL",
                NamedTarget::Head => "HEAD",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "NAMED_TARGET_UNSPECIFIED" => Some(Self::Unspecified),
                "TAIL" => Some(Self::Tail),
                "HEAD" => Some(Self::Head),
                _ => None,
            }
        }
    }
    /// The target to seek to. Must be set.
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Target {
        /// Seek to a named position with respect to the message backlog.
        #[prost(enumeration = "NamedTarget", tag = "2")]
        NamedTarget(i32),
        /// Seek to the first message whose publish or event time is greater than or
        /// equal to the specified query time. If no such message can be located,
        /// will seek to the end of the message backlog.
        #[prost(message, tag = "3")]
        TimeTarget(super::TimeTarget),
    }
}
/// Response for SeekSubscription long running operation.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SeekSubscriptionResponse {}
/// Metadata for long running operations.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OperationMetadata {
    /// The time the operation was created.
    #[prost(message, optional, tag = "1")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// The time the operation finished running. Not set if the operation has not
    /// completed.
    #[prost(message, optional, tag = "2")]
    pub end_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Resource path for the target of the operation. For example, targets of
    /// seeks are subscription resources, structured like:
    /// projects/{project_number}/locations/{location}/subscriptions/{subscription_id}
    #[prost(string, tag = "3")]
    pub target: ::prost::alloc::string::String,
    /// Name of the verb executed by the operation.
    #[prost(string, tag = "4")]
    pub verb: ::prost::alloc::string::String,
}
/// Request for CreateReservation.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateReservationRequest {
    /// Required. The parent location in which to create the reservation.
    /// Structured like `projects/{project_number}/locations/{location}`.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. Configuration of the reservation to create. Its `name` field is
    /// ignored.
    #[prost(message, optional, tag = "2")]
    pub reservation: ::core::option::Option<Reservation>,
    /// Required. The ID to use for the reservation, which will become the final
    /// component of the reservation's name.
    ///
    /// This value is structured like: `my-reservation-name`.
    #[prost(string, tag = "3")]
    pub reservation_id: ::prost::alloc::string::String,
}
/// Request for GetReservation.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetReservationRequest {
    /// Required. The name of the reservation whose configuration to return.
    /// Structured like:
    /// projects/{project_number}/locations/{location}/reservations/{reservation_id}
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request for ListReservations.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListReservationsRequest {
    /// Required. The parent whose reservations are to be listed.
    /// Structured like `projects/{project_number}/locations/{location}`.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// The maximum number of reservations to return. The service may return fewer
    /// than this value. If unset or zero, all reservations for the parent will be
    /// returned.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// A page token, received from a previous `ListReservations` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to `ListReservations` must
    /// match the call that provided the page token.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
/// Response for ListReservations.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListReservationsResponse {
    /// The list of reservation in the requested parent. The order of the
    /// reservations is unspecified.
    #[prost(message, repeated, tag = "1")]
    pub reservations: ::prost::alloc::vec::Vec<Reservation>,
    /// A token that can be sent as `page_token` to retrieve the next page of
    /// results. If this field is omitted, there are no more results.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// Request for UpdateReservation.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateReservationRequest {
    /// Required. The reservation to update. Its `name` field must be populated.
    #[prost(message, optional, tag = "1")]
    pub reservation: ::core::option::Option<Reservation>,
    /// Required. A mask specifying the reservation fields to change.
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
/// Request for DeleteReservation.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteReservationRequest {
    /// Required. The name of the reservation to delete.
    /// Structured like:
    /// projects/{project_number}/locations/{location}/reservations/{reservation_id}
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request for ListReservationTopics.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListReservationTopicsRequest {
    /// Required. The name of the reservation whose topics to list.
    /// Structured like:
    /// projects/{project_number}/locations/{location}/reservations/{reservation_id}
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// The maximum number of topics to return. The service may return fewer
    /// than this value.
    /// If unset or zero, all topics for the given reservation will be returned.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// A page token, received from a previous `ListReservationTopics` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to `ListReservationTopics`
    /// must match the call that provided the page token.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
/// Response for ListReservationTopics.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListReservationTopicsResponse {
    /// The names of topics attached to the reservation. The order of the
    /// topics is unspecified.
    #[prost(string, repeated, tag = "1")]
    pub topics: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// A token that can be sent as `page_token` to retrieve the next page of
    /// results. If this field is omitted, there are no more results.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// Generated server implementations.
pub mod admin_service_server {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with AdminServiceServer.
    #[async_trait]
    pub trait AdminService: Send + Sync + 'static {
        /// Creates a new topic.
        async fn create_topic(
            &self,
            request: tonic::Request<super::CreateTopicRequest>,
        ) -> std::result::Result<tonic::Response<super::Topic>, tonic::Status>;
        /// Returns the topic configuration.
        async fn get_topic(
            &self,
            request: tonic::Request<super::GetTopicRequest>,
        ) -> std::result::Result<tonic::Response<super::Topic>, tonic::Status>;
        /// Returns the partition information for the requested topic.
        async fn get_topic_partitions(
            &self,
            request: tonic::Request<super::GetTopicPartitionsRequest>,
        ) -> std::result::Result<tonic::Response<super::TopicPartitions>, tonic::Status>;
        /// Returns the list of topics for the given project.
        async fn list_topics(
            &self,
            request: tonic::Request<super::ListTopicsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListTopicsResponse>,
            tonic::Status,
        >;
        /// Updates properties of the specified topic.
        async fn update_topic(
            &self,
            request: tonic::Request<super::UpdateTopicRequest>,
        ) -> std::result::Result<tonic::Response<super::Topic>, tonic::Status>;
        /// Deletes the specified topic.
        async fn delete_topic(
            &self,
            request: tonic::Request<super::DeleteTopicRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status>;
        /// Lists the subscriptions attached to the specified topic.
        async fn list_topic_subscriptions(
            &self,
            request: tonic::Request<super::ListTopicSubscriptionsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListTopicSubscriptionsResponse>,
            tonic::Status,
        >;
        /// Creates a new subscription.
        async fn create_subscription(
            &self,
            request: tonic::Request<super::CreateSubscriptionRequest>,
        ) -> std::result::Result<tonic::Response<super::Subscription>, tonic::Status>;
        /// Returns the subscription configuration.
        async fn get_subscription(
            &self,
            request: tonic::Request<super::GetSubscriptionRequest>,
        ) -> std::result::Result<tonic::Response<super::Subscription>, tonic::Status>;
        /// Returns the list of subscriptions for the given project.
        async fn list_subscriptions(
            &self,
            request: tonic::Request<super::ListSubscriptionsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListSubscriptionsResponse>,
            tonic::Status,
        >;
        /// Updates properties of the specified subscription.
        async fn update_subscription(
            &self,
            request: tonic::Request<super::UpdateSubscriptionRequest>,
        ) -> std::result::Result<tonic::Response<super::Subscription>, tonic::Status>;
        /// Deletes the specified subscription.
        async fn delete_subscription(
            &self,
            request: tonic::Request<super::DeleteSubscriptionRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status>;
        /// Performs an out-of-band seek for a subscription to a specified target,
        /// which may be timestamps or named positions within the message backlog.
        /// Seek translates these targets to cursors for each partition and
        /// orchestrates subscribers to start consuming messages from these seek
        /// cursors.
        ///
        /// If an operation is returned, the seek has been registered and subscribers
        /// will eventually receive messages from the seek cursors (i.e. eventual
        /// consistency), as long as they are using a minimum supported client library
        /// version and not a system that tracks cursors independently of Pub/Sub Lite
        /// (e.g. Apache Beam, Dataflow, Spark). The seek operation will fail for
        /// unsupported clients.
        ///
        /// If clients would like to know when subscribers react to the seek (or not),
        /// they can poll the operation. The seek operation will succeed and complete
        /// once subscribers are ready to receive messages from the seek cursors for
        /// all partitions of the topic. This means that the seek operation will not
        /// complete until all subscribers come online.
        ///
        /// If the previous seek operation has not yet completed, it will be aborted
        /// and the new invocation of seek will supersede it.
        async fn seek_subscription(
            &self,
            request: tonic::Request<super::SeekSubscriptionRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        >;
        /// Creates a new reservation.
        async fn create_reservation(
            &self,
            request: tonic::Request<super::CreateReservationRequest>,
        ) -> std::result::Result<tonic::Response<super::Reservation>, tonic::Status>;
        /// Returns the reservation configuration.
        async fn get_reservation(
            &self,
            request: tonic::Request<super::GetReservationRequest>,
        ) -> std::result::Result<tonic::Response<super::Reservation>, tonic::Status>;
        /// Returns the list of reservations for the given project.
        async fn list_reservations(
            &self,
            request: tonic::Request<super::ListReservationsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListReservationsResponse>,
            tonic::Status,
        >;
        /// Updates properties of the specified reservation.
        async fn update_reservation(
            &self,
            request: tonic::Request<super::UpdateReservationRequest>,
        ) -> std::result::Result<tonic::Response<super::Reservation>, tonic::Status>;
        /// Deletes the specified reservation.
        async fn delete_reservation(
            &self,
            request: tonic::Request<super::DeleteReservationRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status>;
        /// Lists the topics attached to the specified reservation.
        async fn list_reservation_topics(
            &self,
            request: tonic::Request<super::ListReservationTopicsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListReservationTopicsResponse>,
            tonic::Status,
        >;
    }
    /// The service that a client application uses to manage topics and
    /// subscriptions, such creating, listing, and deleting topics and subscriptions.
    #[derive(Debug)]
    pub struct AdminServiceServer<T: AdminService> {
        inner: _Inner<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    struct _Inner<T>(Arc<T>);
    impl<T: AdminService> AdminServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            let inner = _Inner(inner);
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for AdminServiceServer<T>
    where
        T: AdminService,
        B: Body + Send + 'static,
        B::Error: Into<StdError> + Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            let inner = self.inner.clone();
            match req.uri().path() {
                "/google.cloud.pubsublite.v1.AdminService/CreateTopic" => {
                    #[allow(non_camel_case_types)]
                    struct CreateTopicSvc<T: AdminService>(pub Arc<T>);
                    impl<
                        T: AdminService,
                    > tonic::server::UnaryService<super::CreateTopicRequest>
                    for CreateTopicSvc<T> {
                        type Response = super::Topic;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::CreateTopicRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as AdminService>::create_topic(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = CreateTopicSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.pubsublite.v1.AdminService/GetTopic" => {
                    #[allow(non_camel_case_types)]
                    struct GetTopicSvc<T: AdminService>(pub Arc<T>);
                    impl<
                        T: AdminService,
                    > tonic::server::UnaryService<super::GetTopicRequest>
                    for GetTopicSvc<T> {
                        type Response = super::Topic;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetTopicRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as AdminService>::get_topic(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = GetTopicSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.pubsublite.v1.AdminService/GetTopicPartitions" => {
                    #[allow(non_camel_case_types)]
                    struct GetTopicPartitionsSvc<T: AdminService>(pub Arc<T>);
                    impl<
                        T: AdminService,
                    > tonic::server::UnaryService<super::GetTopicPartitionsRequest>
                    for GetTopicPartitionsSvc<T> {
                        type Response = super::TopicPartitions;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetTopicPartitionsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as AdminService>::get_topic_partitions(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = GetTopicPartitionsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.pubsublite.v1.AdminService/ListTopics" => {
                    #[allow(non_camel_case_types)]
                    struct ListTopicsSvc<T: AdminService>(pub Arc<T>);
                    impl<
                        T: AdminService,
                    > tonic::server::UnaryService<super::ListTopicsRequest>
                    for ListTopicsSvc<T> {
                        type Response = super::ListTopicsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ListTopicsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as AdminService>::list_topics(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = ListTopicsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.pubsublite.v1.AdminService/UpdateTopic" => {
                    #[allow(non_camel_case_types)]
                    struct UpdateTopicSvc<T: AdminService>(pub Arc<T>);
                    impl<
                        T: AdminService,
                    > tonic::server::UnaryService<super::UpdateTopicRequest>
                    for UpdateTopicSvc<T> {
                        type Response = super::Topic;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::UpdateTopicRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as AdminService>::update_topic(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = UpdateTopicSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.pubsublite.v1.AdminService/DeleteTopic" => {
                    #[allow(non_camel_case_types)]
                    struct DeleteTopicSvc<T: AdminService>(pub Arc<T>);
                    impl<
                        T: AdminService,
                    > tonic::server::UnaryService<super::DeleteTopicRequest>
                    for DeleteTopicSvc<T> {
                        type Response = ();
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DeleteTopicRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as AdminService>::delete_topic(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = DeleteTopicSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.pubsublite.v1.AdminService/ListTopicSubscriptions" => {
                    #[allow(non_camel_case_types)]
                    struct ListTopicSubscriptionsSvc<T: AdminService>(pub Arc<T>);
                    impl<
                        T: AdminService,
                    > tonic::server::UnaryService<super::ListTopicSubscriptionsRequest>
                    for ListTopicSubscriptionsSvc<T> {
                        type Response = super::ListTopicSubscriptionsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ListTopicSubscriptionsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as AdminService>::list_topic_subscriptions(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = ListTopicSubscriptionsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.pubsublite.v1.AdminService/CreateSubscription" => {
                    #[allow(non_camel_case_types)]
                    struct CreateSubscriptionSvc<T: AdminService>(pub Arc<T>);
                    impl<
                        T: AdminService,
                    > tonic::server::UnaryService<super::CreateSubscriptionRequest>
                    for CreateSubscriptionSvc<T> {
                        type Response = super::Subscription;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::CreateSubscriptionRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as AdminService>::create_subscription(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = CreateSubscriptionSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.pubsublite.v1.AdminService/GetSubscription" => {
                    #[allow(non_camel_case_types)]
                    struct GetSubscriptionSvc<T: AdminService>(pub Arc<T>);
                    impl<
                        T: AdminService,
                    > tonic::server::UnaryService<super::GetSubscriptionRequest>
                    for GetSubscriptionSvc<T> {
                        type Response = super::Subscription;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetSubscriptionRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as AdminService>::get_subscription(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = GetSubscriptionSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.pubsublite.v1.AdminService/ListSubscriptions" => {
                    #[allow(non_camel_case_types)]
                    struct ListSubscriptionsSvc<T: AdminService>(pub Arc<T>);
                    impl<
                        T: AdminService,
                    > tonic::server::UnaryService<super::ListSubscriptionsRequest>
                    for ListSubscriptionsSvc<T> {
                        type Response = super::ListSubscriptionsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ListSubscriptionsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as AdminService>::list_subscriptions(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = ListSubscriptionsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.pubsublite.v1.AdminService/UpdateSubscription" => {
                    #[allow(non_camel_case_types)]
                    struct UpdateSubscriptionSvc<T: AdminService>(pub Arc<T>);
                    impl<
                        T: AdminService,
                    > tonic::server::UnaryService<super::UpdateSubscriptionRequest>
                    for UpdateSubscriptionSvc<T> {
                        type Response = super::Subscription;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::UpdateSubscriptionRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as AdminService>::update_subscription(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = UpdateSubscriptionSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.pubsublite.v1.AdminService/DeleteSubscription" => {
                    #[allow(non_camel_case_types)]
                    struct DeleteSubscriptionSvc<T: AdminService>(pub Arc<T>);
                    impl<
                        T: AdminService,
                    > tonic::server::UnaryService<super::DeleteSubscriptionRequest>
                    for DeleteSubscriptionSvc<T> {
                        type Response = ();
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DeleteSubscriptionRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as AdminService>::delete_subscription(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = DeleteSubscriptionSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.pubsublite.v1.AdminService/SeekSubscription" => {
                    #[allow(non_camel_case_types)]
                    struct SeekSubscriptionSvc<T: AdminService>(pub Arc<T>);
                    impl<
                        T: AdminService,
                    > tonic::server::UnaryService<super::SeekSubscriptionRequest>
                    for SeekSubscriptionSvc<T> {
                        type Response = super::super::super::super::longrunning::Operation;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::SeekSubscriptionRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as AdminService>::seek_subscription(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = SeekSubscriptionSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.pubsublite.v1.AdminService/CreateReservation" => {
                    #[allow(non_camel_case_types)]
                    struct CreateReservationSvc<T: AdminService>(pub Arc<T>);
                    impl<
                        T: AdminService,
                    > tonic::server::UnaryService<super::CreateReservationRequest>
                    for CreateReservationSvc<T> {
                        type Response = super::Reservation;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::CreateReservationRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as AdminService>::create_reservation(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = CreateReservationSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.pubsublite.v1.AdminService/GetReservation" => {
                    #[allow(non_camel_case_types)]
                    struct GetReservationSvc<T: AdminService>(pub Arc<T>);
                    impl<
                        T: AdminService,
                    > tonic::server::UnaryService<super::GetReservationRequest>
                    for GetReservationSvc<T> {
                        type Response = super::Reservation;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetReservationRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as AdminService>::get_reservation(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = GetReservationSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.pubsublite.v1.AdminService/ListReservations" => {
                    #[allow(non_camel_case_types)]
                    struct ListReservationsSvc<T: AdminService>(pub Arc<T>);
                    impl<
                        T: AdminService,
                    > tonic::server::UnaryService<super::ListReservationsRequest>
                    for ListReservationsSvc<T> {
                        type Response = super::ListReservationsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ListReservationsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as AdminService>::list_reservations(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = ListReservationsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.pubsublite.v1.AdminService/UpdateReservation" => {
                    #[allow(non_camel_case_types)]
                    struct UpdateReservationSvc<T: AdminService>(pub Arc<T>);
                    impl<
                        T: AdminService,
                    > tonic::server::UnaryService<super::UpdateReservationRequest>
                    for UpdateReservationSvc<T> {
                        type Response = super::Reservation;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::UpdateReservationRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as AdminService>::update_reservation(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = UpdateReservationSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.pubsublite.v1.AdminService/DeleteReservation" => {
                    #[allow(non_camel_case_types)]
                    struct DeleteReservationSvc<T: AdminService>(pub Arc<T>);
                    impl<
                        T: AdminService,
                    > tonic::server::UnaryService<super::DeleteReservationRequest>
                    for DeleteReservationSvc<T> {
                        type Response = ();
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DeleteReservationRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as AdminService>::delete_reservation(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = DeleteReservationSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.pubsublite.v1.AdminService/ListReservationTopics" => {
                    #[allow(non_camel_case_types)]
                    struct ListReservationTopicsSvc<T: AdminService>(pub Arc<T>);
                    impl<
                        T: AdminService,
                    > tonic::server::UnaryService<super::ListReservationTopicsRequest>
                    for ListReservationTopicsSvc<T> {
                        type Response = super::ListReservationTopicsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ListReservationTopicsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as AdminService>::list_reservation_topics(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = ListReservationTopicsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        Ok(
                            http::Response::builder()
                                .status(200)
                                .header("grpc-status", "12")
                                .header("content-type", "application/grpc")
                                .body(empty_body())
                                .unwrap(),
                        )
                    })
                }
            }
        }
    }
    impl<T: AdminService> Clone for AdminServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    impl<T: AdminService> Clone for _Inner<T> {
        fn clone(&self) -> Self {
            Self(Arc::clone(&self.0))
        }
    }
    impl<T: std::fmt::Debug> std::fmt::Debug for _Inner<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{:?}", self.0)
        }
    }
    impl<T: AdminService> tonic::server::NamedService for AdminServiceServer<T> {
        const NAME: &'static str = "google.cloud.pubsublite.v1.AdminService";
    }
}
/// The first streaming request that must be sent on a newly-opened stream. The
/// client must wait for the response before sending subsequent requests on the
/// stream.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InitialCommitCursorRequest {
    /// The subscription for which to manage committed cursors.
    #[prost(string, tag = "1")]
    pub subscription: ::prost::alloc::string::String,
    /// The partition for which to manage committed cursors. Partitions are zero
    /// indexed, so `partition` must be in the range [0, topic.num_partitions).
    #[prost(int64, tag = "2")]
    pub partition: i64,
}
/// Response to an InitialCommitCursorRequest.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InitialCommitCursorResponse {}
/// Streaming request to update the committed cursor. Subsequent
/// SequencedCommitCursorRequests override outstanding ones.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SequencedCommitCursorRequest {
    /// The new value for the committed cursor.
    #[prost(message, optional, tag = "1")]
    pub cursor: ::core::option::Option<Cursor>,
}
/// Response to a SequencedCommitCursorRequest.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SequencedCommitCursorResponse {
    /// The number of outstanding SequencedCommitCursorRequests acknowledged by
    /// this response. Note that SequencedCommitCursorRequests are acknowledged in
    /// the order that they are received.
    #[prost(int64, tag = "1")]
    pub acknowledged_commits: i64,
}
/// A request sent from the client to the server on a stream.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StreamingCommitCursorRequest {
    /// The type of request this is.
    #[prost(oneof = "streaming_commit_cursor_request::Request", tags = "1, 2")]
    pub request: ::core::option::Option<streaming_commit_cursor_request::Request>,
}
/// Nested message and enum types in `StreamingCommitCursorRequest`.
pub mod streaming_commit_cursor_request {
    /// The type of request this is.
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Request {
        /// Initial request on the stream.
        #[prost(message, tag = "1")]
        Initial(super::InitialCommitCursorRequest),
        /// Request to commit a new cursor value.
        #[prost(message, tag = "2")]
        Commit(super::SequencedCommitCursorRequest),
    }
}
/// Response to a StreamingCommitCursorRequest.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StreamingCommitCursorResponse {
    /// The type of request this is.
    #[prost(oneof = "streaming_commit_cursor_response::Request", tags = "1, 2")]
    pub request: ::core::option::Option<streaming_commit_cursor_response::Request>,
}
/// Nested message and enum types in `StreamingCommitCursorResponse`.
pub mod streaming_commit_cursor_response {
    /// The type of request this is.
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Request {
        /// Initial response on the stream.
        #[prost(message, tag = "1")]
        Initial(super::InitialCommitCursorResponse),
        /// Response to committing a new cursor value.
        #[prost(message, tag = "2")]
        Commit(super::SequencedCommitCursorResponse),
    }
}
/// Request for CommitCursor.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CommitCursorRequest {
    /// The subscription for which to update the cursor.
    #[prost(string, tag = "1")]
    pub subscription: ::prost::alloc::string::String,
    /// The partition for which to update the cursor. Partitions are zero indexed,
    /// so `partition` must be in the range [0, topic.num_partitions).
    #[prost(int64, tag = "2")]
    pub partition: i64,
    /// The new value for the committed cursor.
    #[prost(message, optional, tag = "3")]
    pub cursor: ::core::option::Option<Cursor>,
}
/// Response for CommitCursor.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CommitCursorResponse {}
/// Request for ListPartitionCursors.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListPartitionCursorsRequest {
    /// Required. The subscription for which to retrieve cursors.
    /// Structured like
    /// `projects/{project_number}/locations/{location}/subscriptions/{subscription_id}`.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// The maximum number of cursors to return. The service may return fewer than
    /// this value.
    /// If unset or zero, all cursors for the parent will be returned.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// A page token, received from a previous `ListPartitionCursors` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to `ListPartitionCursors`
    /// must match the call that provided the page token.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
/// A pair of a Cursor and the partition it is for.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PartitionCursor {
    /// The partition this is for.
    #[prost(int64, tag = "1")]
    pub partition: i64,
    /// The value of the cursor.
    #[prost(message, optional, tag = "2")]
    pub cursor: ::core::option::Option<Cursor>,
}
/// Response for ListPartitionCursors
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListPartitionCursorsResponse {
    /// The partition cursors from this request.
    #[prost(message, repeated, tag = "1")]
    pub partition_cursors: ::prost::alloc::vec::Vec<PartitionCursor>,
    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// Generated server implementations.
pub mod cursor_service_server {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with CursorServiceServer.
    #[async_trait]
    pub trait CursorService: Send + Sync + 'static {
        /// Server streaming response type for the StreamingCommitCursor method.
        type StreamingCommitCursorStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<
                    super::StreamingCommitCursorResponse,
                    tonic::Status,
                >,
            >
            + Send
            + 'static;
        /// Establishes a stream with the server for managing committed cursors.
        async fn streaming_commit_cursor(
            &self,
            request: tonic::Request<
                tonic::Streaming<super::StreamingCommitCursorRequest>,
            >,
        ) -> std::result::Result<
            tonic::Response<Self::StreamingCommitCursorStream>,
            tonic::Status,
        >;
        /// Updates the committed cursor.
        async fn commit_cursor(
            &self,
            request: tonic::Request<super::CommitCursorRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CommitCursorResponse>,
            tonic::Status,
        >;
        /// Returns all committed cursor information for a subscription.
        async fn list_partition_cursors(
            &self,
            request: tonic::Request<super::ListPartitionCursorsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListPartitionCursorsResponse>,
            tonic::Status,
        >;
    }
    /// The service that a subscriber client application uses to manage committed
    /// cursors while receiving messsages. A cursor represents a subscriber's
    /// progress within a topic partition for a given subscription.
    #[derive(Debug)]
    pub struct CursorServiceServer<T: CursorService> {
        inner: _Inner<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    struct _Inner<T>(Arc<T>);
    impl<T: CursorService> CursorServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            let inner = _Inner(inner);
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for CursorServiceServer<T>
    where
        T: CursorService,
        B: Body + Send + 'static,
        B::Error: Into<StdError> + Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            let inner = self.inner.clone();
            match req.uri().path() {
                "/google.cloud.pubsublite.v1.CursorService/StreamingCommitCursor" => {
                    #[allow(non_camel_case_types)]
                    struct StreamingCommitCursorSvc<T: CursorService>(pub Arc<T>);
                    impl<
                        T: CursorService,
                    > tonic::server::StreamingService<
                        super::StreamingCommitCursorRequest,
                    > for StreamingCommitCursorSvc<T> {
                        type Response = super::StreamingCommitCursorResponse;
                        type ResponseStream = T::StreamingCommitCursorStream;
                        type Future = BoxFuture<
                            tonic::Response<Self::ResponseStream>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                tonic::Streaming<super::StreamingCommitCursorRequest>,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as CursorService>::streaming_commit_cursor(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = StreamingCommitCursorSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.pubsublite.v1.CursorService/CommitCursor" => {
                    #[allow(non_camel_case_types)]
                    struct CommitCursorSvc<T: CursorService>(pub Arc<T>);
                    impl<
                        T: CursorService,
                    > tonic::server::UnaryService<super::CommitCursorRequest>
                    for CommitCursorSvc<T> {
                        type Response = super::CommitCursorResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::CommitCursorRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as CursorService>::commit_cursor(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = CommitCursorSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.pubsublite.v1.CursorService/ListPartitionCursors" => {
                    #[allow(non_camel_case_types)]
                    struct ListPartitionCursorsSvc<T: CursorService>(pub Arc<T>);
                    impl<
                        T: CursorService,
                    > tonic::server::UnaryService<super::ListPartitionCursorsRequest>
                    for ListPartitionCursorsSvc<T> {
                        type Response = super::ListPartitionCursorsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ListPartitionCursorsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as CursorService>::list_partition_cursors(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = ListPartitionCursorsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        Ok(
                            http::Response::builder()
                                .status(200)
                                .header("grpc-status", "12")
                                .header("content-type", "application/grpc")
                                .body(empty_body())
                                .unwrap(),
                        )
                    })
                }
            }
        }
    }
    impl<T: CursorService> Clone for CursorServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    impl<T: CursorService> Clone for _Inner<T> {
        fn clone(&self) -> Self {
            Self(Arc::clone(&self.0))
        }
    }
    impl<T: std::fmt::Debug> std::fmt::Debug for _Inner<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{:?}", self.0)
        }
    }
    impl<T: CursorService> tonic::server::NamedService for CursorServiceServer<T> {
        const NAME: &'static str = "google.cloud.pubsublite.v1.CursorService";
    }
}
/// The first request that must be sent on a newly-opened stream.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InitialPublishRequest {
    /// The topic to which messages will be written.
    #[prost(string, tag = "1")]
    pub topic: ::prost::alloc::string::String,
    /// The partition within the topic to which messages will be written.
    /// Partitions are zero indexed, so `partition` must be in the range [0,
    /// topic.num_partitions).
    #[prost(int64, tag = "2")]
    pub partition: i64,
    /// Unique identifier for a publisher client. If set, enables publish
    /// idempotency within a publisher client session.
    ///
    /// The length of this field must be exactly 16 bytes long and should be
    /// populated with a 128 bit uuid, generated by standard uuid algorithms like
    /// uuid1 or uuid4. The same identifier should be reused following
    /// disconnections with retryable stream errors.
    #[prost(bytes = "vec", tag = "3")]
    pub client_id: ::prost::alloc::vec::Vec<u8>,
}
/// Response to an InitialPublishRequest.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InitialPublishResponse {}
/// Request to publish messages to the topic.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MessagePublishRequest {
    /// The messages to publish.
    #[prost(message, repeated, tag = "1")]
    pub messages: ::prost::alloc::vec::Vec<PubSubMessage>,
    /// The sequence number corresponding to the first message in `messages`.
    /// Messages within a batch are ordered and the sequence numbers of all
    /// subsequent messages in the batch are assumed to be incremental.
    ///
    /// Sequence numbers are assigned at the message level and the first message
    /// published in a publisher client session must have a sequence number of 0.
    /// All messages must have contiguous sequence numbers, which uniquely identify
    /// the messages accepted by the publisher client. Since messages are ordered,
    /// the client only needs to specify the sequence number of the first message
    /// in a published batch. The server deduplicates messages with the same
    /// sequence number from the same publisher `client_id`.
    #[prost(int64, tag = "2")]
    pub first_sequence_number: i64,
}
/// Response to a MessagePublishRequest.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MessagePublishResponse {
    /// The cursor of the first published message in the batch. The cursors for any
    /// remaining messages in the batch are guaranteed to be sequential.
    #[prost(message, optional, tag = "1")]
    pub start_cursor: ::core::option::Option<Cursor>,
    /// Cursors for messages published in the batch. There will exist multiple
    /// ranges when cursors are not contiguous within the batch.
    ///
    /// The cursor ranges may not account for all messages in the batch when
    /// publish idempotency is enabled. A missing range indicates that cursors
    /// could not be determined for messages within the range, as they were
    /// deduplicated and the necessary data was not available at publish time.
    /// These messages will have offsets when received by a subscriber.
    #[prost(message, repeated, tag = "2")]
    pub cursor_ranges: ::prost::alloc::vec::Vec<message_publish_response::CursorRange>,
}
/// Nested message and enum types in `MessagePublishResponse`.
pub mod message_publish_response {
    /// Cursors for a subrange of published messages.
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct CursorRange {
        /// The cursor of the message at the start index. The cursors for remaining
        /// messages up to the end index (exclusive) are sequential.
        #[prost(message, optional, tag = "1")]
        pub start_cursor: ::core::option::Option<super::Cursor>,
        /// Index of the message in the published batch that corresponds to the
        /// start cursor. Inclusive.
        #[prost(int32, tag = "2")]
        pub start_index: i32,
        /// Index of the last message in this range. Exclusive.
        #[prost(int32, tag = "3")]
        pub end_index: i32,
    }
}
/// Request sent from the client to the server on a stream.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PublishRequest {
    /// The type of request this is.
    #[prost(oneof = "publish_request::RequestType", tags = "1, 2")]
    pub request_type: ::core::option::Option<publish_request::RequestType>,
}
/// Nested message and enum types in `PublishRequest`.
pub mod publish_request {
    /// The type of request this is.
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum RequestType {
        /// Initial request on the stream.
        #[prost(message, tag = "1")]
        InitialRequest(super::InitialPublishRequest),
        /// Request to publish messages.
        #[prost(message, tag = "2")]
        MessagePublishRequest(super::MessagePublishRequest),
    }
}
/// Response to a PublishRequest.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PublishResponse {
    /// The type of response this is.
    #[prost(oneof = "publish_response::ResponseType", tags = "1, 2")]
    pub response_type: ::core::option::Option<publish_response::ResponseType>,
}
/// Nested message and enum types in `PublishResponse`.
pub mod publish_response {
    /// The type of response this is.
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum ResponseType {
        /// Initial response on the stream.
        #[prost(message, tag = "1")]
        InitialResponse(super::InitialPublishResponse),
        /// Response to publishing messages.
        #[prost(message, tag = "2")]
        MessageResponse(super::MessagePublishResponse),
    }
}
/// Generated server implementations.
pub mod publisher_service_server {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with PublisherServiceServer.
    #[async_trait]
    pub trait PublisherService: Send + Sync + 'static {
        /// Server streaming response type for the Publish method.
        type PublishStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<super::PublishResponse, tonic::Status>,
            >
            + Send
            + 'static;
        /// Establishes a stream with the server for publishing messages. Once the
        /// stream is initialized, the client publishes messages by sending publish
        /// requests on the stream. The server responds with a PublishResponse for each
        /// PublishRequest sent by the client, in the same order that the requests
        /// were sent. Note that multiple PublishRequests can be in flight
        /// simultaneously, but they will be processed by the server in the order that
        /// they are sent by the client on a given stream.
        async fn publish(
            &self,
            request: tonic::Request<tonic::Streaming<super::PublishRequest>>,
        ) -> std::result::Result<tonic::Response<Self::PublishStream>, tonic::Status>;
    }
    /// The service that a publisher client application uses to publish messages to
    /// topics. Published messages are retained by the service for the duration of
    /// the retention period configured for the respective topic, and are delivered
    /// to subscriber clients upon request (via the `SubscriberService`).
    #[derive(Debug)]
    pub struct PublisherServiceServer<T: PublisherService> {
        inner: _Inner<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    struct _Inner<T>(Arc<T>);
    impl<T: PublisherService> PublisherServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            let inner = _Inner(inner);
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for PublisherServiceServer<T>
    where
        T: PublisherService,
        B: Body + Send + 'static,
        B::Error: Into<StdError> + Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            let inner = self.inner.clone();
            match req.uri().path() {
                "/google.cloud.pubsublite.v1.PublisherService/Publish" => {
                    #[allow(non_camel_case_types)]
                    struct PublishSvc<T: PublisherService>(pub Arc<T>);
                    impl<
                        T: PublisherService,
                    > tonic::server::StreamingService<super::PublishRequest>
                    for PublishSvc<T> {
                        type Response = super::PublishResponse;
                        type ResponseStream = T::PublishStream;
                        type Future = BoxFuture<
                            tonic::Response<Self::ResponseStream>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                tonic::Streaming<super::PublishRequest>,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as PublisherService>::publish(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = PublishSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        Ok(
                            http::Response::builder()
                                .status(200)
                                .header("grpc-status", "12")
                                .header("content-type", "application/grpc")
                                .body(empty_body())
                                .unwrap(),
                        )
                    })
                }
            }
        }
    }
    impl<T: PublisherService> Clone for PublisherServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    impl<T: PublisherService> Clone for _Inner<T> {
        fn clone(&self) -> Self {
            Self(Arc::clone(&self.0))
        }
    }
    impl<T: std::fmt::Debug> std::fmt::Debug for _Inner<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{:?}", self.0)
        }
    }
    impl<T: PublisherService> tonic::server::NamedService for PublisherServiceServer<T> {
        const NAME: &'static str = "google.cloud.pubsublite.v1.PublisherService";
    }
}
/// The first request that must be sent on a newly-opened stream. The client must
/// wait for the response before sending subsequent requests on the stream.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InitialSubscribeRequest {
    /// The subscription from which to receive messages.
    #[prost(string, tag = "1")]
    pub subscription: ::prost::alloc::string::String,
    /// The partition from which to receive messages. Partitions are zero indexed,
    /// so `partition` must be in the range [0, topic.num_partitions).
    #[prost(int64, tag = "2")]
    pub partition: i64,
    /// Optional. Initial target location within the message backlog. If not set,
    /// messages will be delivered from the commit cursor for the given
    /// subscription and partition.
    #[prost(message, optional, tag = "4")]
    pub initial_location: ::core::option::Option<SeekRequest>,
}
/// Response to an InitialSubscribeRequest.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InitialSubscribeResponse {
    /// The cursor from which the subscriber will start receiving messages once
    /// flow control tokens become available.
    #[prost(message, optional, tag = "1")]
    pub cursor: ::core::option::Option<Cursor>,
}
/// Request to update the stream's delivery cursor based on the given target.
/// Resets the server available tokens to 0. SeekRequests past head result in
/// stream breakage.
///
/// SeekRequests may not be sent while another SeekRequest is outstanding (i.e.,
/// has not received a SeekResponse) on the same stream.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SeekRequest {
    /// The target to seek to. Must be set.
    #[prost(oneof = "seek_request::Target", tags = "1, 2")]
    pub target: ::core::option::Option<seek_request::Target>,
}
/// Nested message and enum types in `SeekRequest`.
pub mod seek_request {
    /// A special target in the partition that takes no other parameters.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum NamedTarget {
        /// Default value. This value is unused.
        Unspecified = 0,
        /// A target corresponding to the most recently published message in the
        /// partition.
        Head = 1,
        /// A target corresponding to the committed cursor for the given subscription
        /// and topic partition.
        CommittedCursor = 2,
    }
    impl NamedTarget {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                NamedTarget::Unspecified => "NAMED_TARGET_UNSPECIFIED",
                NamedTarget::Head => "HEAD",
                NamedTarget::CommittedCursor => "COMMITTED_CURSOR",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "NAMED_TARGET_UNSPECIFIED" => Some(Self::Unspecified),
                "HEAD" => Some(Self::Head),
                "COMMITTED_CURSOR" => Some(Self::CommittedCursor),
                _ => None,
            }
        }
    }
    /// The target to seek to. Must be set.
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Target {
        /// A named target.
        #[prost(enumeration = "NamedTarget", tag = "1")]
        NamedTarget(i32),
        /// A target corresponding to the cursor, pointing to anywhere in the
        /// topic partition.
        #[prost(message, tag = "2")]
        Cursor(super::Cursor),
    }
}
/// Response to a SeekRequest.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SeekResponse {
    /// The new delivery cursor for the current stream.
    #[prost(message, optional, tag = "1")]
    pub cursor: ::core::option::Option<Cursor>,
}
/// Request to grant tokens to the server, requesting delivery of messages when
/// they become available.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FlowControlRequest {
    /// The number of message tokens to grant. Must be greater than or equal to 0.
    #[prost(int64, tag = "1")]
    pub allowed_messages: i64,
    /// The number of byte tokens to grant. Must be greater than or equal to 0.
    #[prost(int64, tag = "2")]
    pub allowed_bytes: i64,
}
/// A request sent from the client to the server on a stream.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubscribeRequest {
    /// The type of request this is.
    #[prost(oneof = "subscribe_request::Request", tags = "1, 2, 3")]
    pub request: ::core::option::Option<subscribe_request::Request>,
}
/// Nested message and enum types in `SubscribeRequest`.
pub mod subscribe_request {
    /// The type of request this is.
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Request {
        /// Initial request on the stream.
        #[prost(message, tag = "1")]
        Initial(super::InitialSubscribeRequest),
        /// Request to update the stream's delivery cursor.
        #[prost(message, tag = "2")]
        Seek(super::SeekRequest),
        /// Request to grant tokens to the server,
        #[prost(message, tag = "3")]
        FlowControl(super::FlowControlRequest),
    }
}
/// Response containing a list of messages. Upon delivering a MessageResponse to
/// the client, the server:
/// *  Updates the stream's delivery cursor to one greater than the cursor of the
///     last message in the list.
/// *  Subtracts the total number of bytes and messages from the tokens available
///     to the server.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MessageResponse {
    /// Messages from the topic partition.
    #[prost(message, repeated, tag = "1")]
    pub messages: ::prost::alloc::vec::Vec<SequencedMessage>,
}
/// Response to SubscribeRequest.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubscribeResponse {
    /// The type of response this is.
    #[prost(oneof = "subscribe_response::Response", tags = "1, 2, 3")]
    pub response: ::core::option::Option<subscribe_response::Response>,
}
/// Nested message and enum types in `SubscribeResponse`.
pub mod subscribe_response {
    /// The type of response this is.
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Response {
        /// Initial response on the stream.
        #[prost(message, tag = "1")]
        Initial(super::InitialSubscribeResponse),
        /// Response to a Seek operation.
        #[prost(message, tag = "2")]
        Seek(super::SeekResponse),
        /// Response containing messages from the topic partition.
        #[prost(message, tag = "3")]
        Messages(super::MessageResponse),
    }
}
/// The first request that must be sent on a newly-opened stream. The client must
/// wait for the response before sending subsequent requests on the stream.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InitialPartitionAssignmentRequest {
    /// The subscription name. Structured like:
    /// projects/<project number>/locations/<zone name>/subscriptions/<subscription
    /// id>
    #[prost(string, tag = "1")]
    pub subscription: ::prost::alloc::string::String,
    /// An opaque, unique client identifier. This field must be exactly 16 bytes
    /// long and is interpreted as an unsigned 128 bit integer. Other size values
    /// will be rejected and the stream will be failed with a non-retryable error.
    ///
    /// This field is large enough to fit a uuid from standard uuid algorithms like
    /// uuid1 or uuid4, which should be used to generate this number. The same
    /// identifier should be reused following disconnections with retryable stream
    /// errors.
    #[prost(bytes = "vec", tag = "2")]
    pub client_id: ::prost::alloc::vec::Vec<u8>,
}
/// PartitionAssignments should not race with acknowledgements. There
/// should be exactly one unacknowledged PartitionAssignment at a time. If not,
/// the client must break the stream.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PartitionAssignment {
    /// The list of partition numbers this subscriber is assigned to.
    #[prost(int64, repeated, tag = "1")]
    pub partitions: ::prost::alloc::vec::Vec<i64>,
}
/// Acknowledge receipt and handling of the previous assignment.
/// If not sent within a short period after receiving the assignment,
/// partitions may remain unassigned for a period of time until the
/// client is known to be inactive, after which time the server will break the
/// stream.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PartitionAssignmentAck {}
/// A request on the PartitionAssignment stream.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PartitionAssignmentRequest {
    /// The type of request this is.
    #[prost(oneof = "partition_assignment_request::Request", tags = "1, 2")]
    pub request: ::core::option::Option<partition_assignment_request::Request>,
}
/// Nested message and enum types in `PartitionAssignmentRequest`.
pub mod partition_assignment_request {
    /// The type of request this is.
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Request {
        /// Initial request on the stream.
        #[prost(message, tag = "1")]
        Initial(super::InitialPartitionAssignmentRequest),
        /// Acknowledgement of a partition assignment.
        #[prost(message, tag = "2")]
        Ack(super::PartitionAssignmentAck),
    }
}
/// Generated server implementations.
pub mod subscriber_service_server {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with SubscriberServiceServer.
    #[async_trait]
    pub trait SubscriberService: Send + Sync + 'static {
        /// Server streaming response type for the Subscribe method.
        type SubscribeStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<super::SubscribeResponse, tonic::Status>,
            >
            + Send
            + 'static;
        /// Establishes a stream with the server for receiving messages.
        async fn subscribe(
            &self,
            request: tonic::Request<tonic::Streaming<super::SubscribeRequest>>,
        ) -> std::result::Result<tonic::Response<Self::SubscribeStream>, tonic::Status>;
    }
    /// The service that a subscriber client application uses to receive messages
    /// from subscriptions.
    #[derive(Debug)]
    pub struct SubscriberServiceServer<T: SubscriberService> {
        inner: _Inner<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    struct _Inner<T>(Arc<T>);
    impl<T: SubscriberService> SubscriberServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            let inner = _Inner(inner);
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for SubscriberServiceServer<T>
    where
        T: SubscriberService,
        B: Body + Send + 'static,
        B::Error: Into<StdError> + Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            let inner = self.inner.clone();
            match req.uri().path() {
                "/google.cloud.pubsublite.v1.SubscriberService/Subscribe" => {
                    #[allow(non_camel_case_types)]
                    struct SubscribeSvc<T: SubscriberService>(pub Arc<T>);
                    impl<
                        T: SubscriberService,
                    > tonic::server::StreamingService<super::SubscribeRequest>
                    for SubscribeSvc<T> {
                        type Response = super::SubscribeResponse;
                        type ResponseStream = T::SubscribeStream;
                        type Future = BoxFuture<
                            tonic::Response<Self::ResponseStream>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                tonic::Streaming<super::SubscribeRequest>,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as SubscriberService>::subscribe(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = SubscribeSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        Ok(
                            http::Response::builder()
                                .status(200)
                                .header("grpc-status", "12")
                                .header("content-type", "application/grpc")
                                .body(empty_body())
                                .unwrap(),
                        )
                    })
                }
            }
        }
    }
    impl<T: SubscriberService> Clone for SubscriberServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    impl<T: SubscriberService> Clone for _Inner<T> {
        fn clone(&self) -> Self {
            Self(Arc::clone(&self.0))
        }
    }
    impl<T: std::fmt::Debug> std::fmt::Debug for _Inner<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{:?}", self.0)
        }
    }
    impl<T: SubscriberService> tonic::server::NamedService
    for SubscriberServiceServer<T> {
        const NAME: &'static str = "google.cloud.pubsublite.v1.SubscriberService";
    }
}
/// Generated server implementations.
pub mod partition_assignment_service_server {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with PartitionAssignmentServiceServer.
    #[async_trait]
    pub trait PartitionAssignmentService: Send + Sync + 'static {
        /// Server streaming response type for the AssignPartitions method.
        type AssignPartitionsStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<super::PartitionAssignment, tonic::Status>,
            >
            + Send
            + 'static;
        /// Assign partitions for this client to handle for the specified subscription.
        ///
        /// The client must send an InitialPartitionAssignmentRequest first.
        /// The server will then send at most one unacknowledged PartitionAssignment
        /// outstanding on the stream at a time.
        /// The client should send a PartitionAssignmentAck after updating the
        /// partitions it is connected to to reflect the new assignment.
        async fn assign_partitions(
            &self,
            request: tonic::Request<tonic::Streaming<super::PartitionAssignmentRequest>>,
        ) -> std::result::Result<
            tonic::Response<Self::AssignPartitionsStream>,
            tonic::Status,
        >;
    }
    /// The service that a subscriber client application uses to determine which
    /// partitions it should connect to.
    #[derive(Debug)]
    pub struct PartitionAssignmentServiceServer<T: PartitionAssignmentService> {
        inner: _Inner<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    struct _Inner<T>(Arc<T>);
    impl<T: PartitionAssignmentService> PartitionAssignmentServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            let inner = _Inner(inner);
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>>
    for PartitionAssignmentServiceServer<T>
    where
        T: PartitionAssignmentService,
        B: Body + Send + 'static,
        B::Error: Into<StdError> + Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            let inner = self.inner.clone();
            match req.uri().path() {
                "/google.cloud.pubsublite.v1.PartitionAssignmentService/AssignPartitions" => {
                    #[allow(non_camel_case_types)]
                    struct AssignPartitionsSvc<T: PartitionAssignmentService>(
                        pub Arc<T>,
                    );
                    impl<
                        T: PartitionAssignmentService,
                    > tonic::server::StreamingService<super::PartitionAssignmentRequest>
                    for AssignPartitionsSvc<T> {
                        type Response = super::PartitionAssignment;
                        type ResponseStream = T::AssignPartitionsStream;
                        type Future = BoxFuture<
                            tonic::Response<Self::ResponseStream>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                tonic::Streaming<super::PartitionAssignmentRequest>,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as PartitionAssignmentService>::assign_partitions(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = AssignPartitionsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        Ok(
                            http::Response::builder()
                                .status(200)
                                .header("grpc-status", "12")
                                .header("content-type", "application/grpc")
                                .body(empty_body())
                                .unwrap(),
                        )
                    })
                }
            }
        }
    }
    impl<T: PartitionAssignmentService> Clone for PartitionAssignmentServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    impl<T: PartitionAssignmentService> Clone for _Inner<T> {
        fn clone(&self) -> Self {
            Self(Arc::clone(&self.0))
        }
    }
    impl<T: std::fmt::Debug> std::fmt::Debug for _Inner<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{:?}", self.0)
        }
    }
    impl<T: PartitionAssignmentService> tonic::server::NamedService
    for PartitionAssignmentServiceServer<T> {
        const NAME: &'static str = "google.cloud.pubsublite.v1.PartitionAssignmentService";
    }
}
/// Compute statistics about a range of messages in a given topic and partition.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ComputeMessageStatsRequest {
    /// Required. The topic for which we should compute message stats.
    #[prost(string, tag = "1")]
    pub topic: ::prost::alloc::string::String,
    /// Required. The partition for which we should compute message stats.
    #[prost(int64, tag = "2")]
    pub partition: i64,
    /// The inclusive start of the range.
    #[prost(message, optional, tag = "3")]
    pub start_cursor: ::core::option::Option<Cursor>,
    /// The exclusive end of the range. The range is empty if end_cursor <=
    /// start_cursor. Specifying a start_cursor before the first message and an
    /// end_cursor after the last message will retrieve all messages.
    #[prost(message, optional, tag = "4")]
    pub end_cursor: ::core::option::Option<Cursor>,
}
/// Response containing stats for messages in the requested topic and partition.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ComputeMessageStatsResponse {
    /// The count of messages.
    #[prost(int64, tag = "1")]
    pub message_count: i64,
    /// The number of quota bytes accounted to these messages.
    #[prost(int64, tag = "2")]
    pub message_bytes: i64,
    /// The minimum publish timestamp across these messages. Note that publish
    /// timestamps within a partition are not guaranteed to be non-decreasing. The
    /// timestamp will be unset if there are no messages.
    #[prost(message, optional, tag = "3")]
    pub minimum_publish_time: ::core::option::Option<::prost_types::Timestamp>,
    /// The minimum event timestamp across these messages. For the purposes of this
    /// computation, if a message does not have an event time, we use the publish
    /// time. The timestamp will be unset if there are no messages.
    #[prost(message, optional, tag = "4")]
    pub minimum_event_time: ::core::option::Option<::prost_types::Timestamp>,
}
/// Compute the current head cursor for a partition.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ComputeHeadCursorRequest {
    /// Required. The topic for which we should compute the head cursor.
    #[prost(string, tag = "1")]
    pub topic: ::prost::alloc::string::String,
    /// Required. The partition for which we should compute the head cursor.
    #[prost(int64, tag = "2")]
    pub partition: i64,
}
/// Response containing the head cursor for the requested topic and partition.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ComputeHeadCursorResponse {
    /// The head cursor.
    #[prost(message, optional, tag = "1")]
    pub head_cursor: ::core::option::Option<Cursor>,
}
/// Compute the corresponding cursor for a publish or event time in a topic
/// partition.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ComputeTimeCursorRequest {
    /// Required. The topic for which we should compute the cursor.
    #[prost(string, tag = "1")]
    pub topic: ::prost::alloc::string::String,
    /// Required. The partition for which we should compute the cursor.
    #[prost(int64, tag = "2")]
    pub partition: i64,
    /// Required. The target publish or event time. Specifying a future time will
    /// return an unset cursor.
    #[prost(message, optional, tag = "3")]
    pub target: ::core::option::Option<TimeTarget>,
}
/// Response containing the cursor corresponding to a publish or event time in a
/// topic partition.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ComputeTimeCursorResponse {
    /// If present, the cursor references the first message with time greater than
    /// or equal to the specified target time. If such a message cannot be found,
    /// the cursor will be unset (i.e. `cursor` is not present).
    #[prost(message, optional, tag = "1")]
    pub cursor: ::core::option::Option<Cursor>,
}
/// Generated server implementations.
pub mod topic_stats_service_server {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with TopicStatsServiceServer.
    #[async_trait]
    pub trait TopicStatsService: Send + Sync + 'static {
        /// Compute statistics about a range of messages in a given topic and
        /// partition.
        async fn compute_message_stats(
            &self,
            request: tonic::Request<super::ComputeMessageStatsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ComputeMessageStatsResponse>,
            tonic::Status,
        >;
        /// Compute the head cursor for the partition.
        /// The head cursor's offset is guaranteed to be less than or equal to all
        /// messages which have not yet been acknowledged as published, and
        /// greater than the offset of any message whose publish has already
        /// been acknowledged. It is zero if there have never been messages in the
        /// partition.
        async fn compute_head_cursor(
            &self,
            request: tonic::Request<super::ComputeHeadCursorRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ComputeHeadCursorResponse>,
            tonic::Status,
        >;
        /// Compute the corresponding cursor for a publish or event time in a topic
        /// partition.
        async fn compute_time_cursor(
            &self,
            request: tonic::Request<super::ComputeTimeCursorRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ComputeTimeCursorResponse>,
            tonic::Status,
        >;
    }
    /// This service allows users to get stats about messages in their topic.
    #[derive(Debug)]
    pub struct TopicStatsServiceServer<T: TopicStatsService> {
        inner: _Inner<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    struct _Inner<T>(Arc<T>);
    impl<T: TopicStatsService> TopicStatsServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            let inner = _Inner(inner);
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for TopicStatsServiceServer<T>
    where
        T: TopicStatsService,
        B: Body + Send + 'static,
        B::Error: Into<StdError> + Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            let inner = self.inner.clone();
            match req.uri().path() {
                "/google.cloud.pubsublite.v1.TopicStatsService/ComputeMessageStats" => {
                    #[allow(non_camel_case_types)]
                    struct ComputeMessageStatsSvc<T: TopicStatsService>(pub Arc<T>);
                    impl<
                        T: TopicStatsService,
                    > tonic::server::UnaryService<super::ComputeMessageStatsRequest>
                    for ComputeMessageStatsSvc<T> {
                        type Response = super::ComputeMessageStatsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ComputeMessageStatsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as TopicStatsService>::compute_message_stats(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = ComputeMessageStatsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.pubsublite.v1.TopicStatsService/ComputeHeadCursor" => {
                    #[allow(non_camel_case_types)]
                    struct ComputeHeadCursorSvc<T: TopicStatsService>(pub Arc<T>);
                    impl<
                        T: TopicStatsService,
                    > tonic::server::UnaryService<super::ComputeHeadCursorRequest>
                    for ComputeHeadCursorSvc<T> {
                        type Response = super::ComputeHeadCursorResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ComputeHeadCursorRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as TopicStatsService>::compute_head_cursor(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = ComputeHeadCursorSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.pubsublite.v1.TopicStatsService/ComputeTimeCursor" => {
                    #[allow(non_camel_case_types)]
                    struct ComputeTimeCursorSvc<T: TopicStatsService>(pub Arc<T>);
                    impl<
                        T: TopicStatsService,
                    > tonic::server::UnaryService<super::ComputeTimeCursorRequest>
                    for ComputeTimeCursorSvc<T> {
                        type Response = super::ComputeTimeCursorResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ComputeTimeCursorRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as TopicStatsService>::compute_time_cursor(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = ComputeTimeCursorSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        Ok(
                            http::Response::builder()
                                .status(200)
                                .header("grpc-status", "12")
                                .header("content-type", "application/grpc")
                                .body(empty_body())
                                .unwrap(),
                        )
                    })
                }
            }
        }
    }
    impl<T: TopicStatsService> Clone for TopicStatsServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    impl<T: TopicStatsService> Clone for _Inner<T> {
        fn clone(&self) -> Self {
            Self(Arc::clone(&self.0))
        }
    }
    impl<T: std::fmt::Debug> std::fmt::Debug for _Inner<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{:?}", self.0)
        }
    }
    impl<T: TopicStatsService> tonic::server::NamedService
    for TopicStatsServiceServer<T> {
        const NAME: &'static str = "google.cloud.pubsublite.v1.TopicStatsService";
    }
}
