// This file is @generated by prost-build.
/// Represents a Dataform Git repository.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Repository {
    /// Output only. The repository's name.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. The repository's user-friendly name.
    #[prost(string, tag = "8")]
    pub display_name: ::prost::alloc::string::String,
    /// Optional. If set, configures this repository to be linked to a Git remote.
    #[prost(message, optional, tag = "2")]
    pub git_remote_settings: ::core::option::Option<repository::GitRemoteSettings>,
    /// Optional. The name of the Secret Manager secret version to be used to
    /// interpolate variables into the .npmrc file for package installation
    /// operations. Must be in the format `projects/*/secrets/*/versions/*`. The
    /// file itself must be in a JSON format.
    #[prost(string, tag = "3")]
    pub npmrc_environment_variables_secret_version: ::prost::alloc::string::String,
    /// Optional. If set, fields of `workspace_compilation_overrides` override the
    /// default compilation settings that are specified in dataform.json when
    /// creating workspace-scoped compilation results. See documentation for
    /// `WorkspaceCompilationOverrides` for more information.
    #[prost(message, optional, tag = "4")]
    pub workspace_compilation_overrides: ::core::option::Option<
        repository::WorkspaceCompilationOverrides,
    >,
    /// Optional. Repository user labels.
    #[prost(map = "string, string", tag = "5")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Optional. Input only. If set to true, the authenticated user will be
    /// granted the roles/dataform.admin role on the created repository. To modify
    /// access to the created repository later apply setIamPolicy from
    /// <https://cloud.google.com/dataform/reference/rest#rest-resource:-v1beta1.projects.locations.repositories>
    #[prost(bool, tag = "9")]
    pub set_authenticated_user_admin: bool,
    /// Optional. The service account to run workflow invocations under.
    #[prost(string, tag = "10")]
    pub service_account: ::prost::alloc::string::String,
}
/// Nested message and enum types in `Repository`.
pub mod repository {
    /// Controls Git remote configuration for a repository.
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct GitRemoteSettings {
        /// Required. The Git remote's URL.
        #[prost(string, tag = "1")]
        pub url: ::prost::alloc::string::String,
        /// Required. The Git remote's default branch name.
        #[prost(string, tag = "2")]
        pub default_branch: ::prost::alloc::string::String,
        /// Optional. The name of the Secret Manager secret version to use as an
        /// authentication token for Git operations. Must be in the format
        /// `projects/*/secrets/*/versions/*`.
        #[prost(string, tag = "3")]
        pub authentication_token_secret_version: ::prost::alloc::string::String,
        /// Optional. Authentication fields for remote uris using SSH protocol.
        #[prost(message, optional, tag = "5")]
        pub ssh_authentication_config: ::core::option::Option<
            git_remote_settings::SshAuthenticationConfig,
        >,
        /// Output only. Deprecated: The field does not contain any token status
        /// information. Instead use
        /// <https://cloud.google.com/dataform/reference/rest/v1beta1/projects.locations.repositories/computeAccessTokenStatus>
        #[deprecated]
        #[prost(enumeration = "git_remote_settings::TokenStatus", tag = "4")]
        pub token_status: i32,
    }
    /// Nested message and enum types in `GitRemoteSettings`.
    pub mod git_remote_settings {
        /// Configures fields for performing SSH authentication.
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct SshAuthenticationConfig {
            /// Required. The name of the Secret Manager secret version to use as a
            /// ssh private key for Git operations.
            /// Must be in the format `projects/*/secrets/*/versions/*`.
            #[prost(string, tag = "1")]
            pub user_private_key_secret_version: ::prost::alloc::string::String,
            /// Required. Content of a public SSH key to verify an identity of a remote
            /// Git host.
            #[prost(string, tag = "2")]
            pub host_public_key: ::prost::alloc::string::String,
        }
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum TokenStatus {
            /// Default value. This value is unused.
            Unspecified = 0,
            /// The token could not be found in Secret Manager (or the Dataform
            /// Service Account did not have permission to access it).
            NotFound = 1,
            /// The token could not be used to authenticate against the Git remote.
            Invalid = 2,
            /// The token was used successfully to authenticate against the Git remote.
            Valid = 3,
        }
        impl TokenStatus {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    TokenStatus::Unspecified => "TOKEN_STATUS_UNSPECIFIED",
                    TokenStatus::NotFound => "NOT_FOUND",
                    TokenStatus::Invalid => "INVALID",
                    TokenStatus::Valid => "VALID",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "TOKEN_STATUS_UNSPECIFIED" => Some(Self::Unspecified),
                    "NOT_FOUND" => Some(Self::NotFound),
                    "INVALID" => Some(Self::Invalid),
                    "VALID" => Some(Self::Valid),
                    _ => None,
                }
            }
        }
    }
    /// Configures workspace compilation overrides for a repository.
    /// Primarily used by the UI (`console.cloud.google.com`).
    /// `schema_suffix` and `table_prefix` can have a special expression -
    /// `${workspaceName}`, which refers to the workspace name from which the
    /// compilation results will be created. API callers are expected to resolve
    /// the expression in these overrides and provide them explicitly in
    /// `code_compilation_config`
    /// (<https://cloud.google.com/dataform/reference/rest/v1beta1/projects.locations.repositories.compilationResults#codecompilationconfig>)
    /// when creating workspace-scoped compilation results.
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct WorkspaceCompilationOverrides {
        /// Optional. The default database (Google Cloud project ID).
        #[prost(string, tag = "1")]
        pub default_database: ::prost::alloc::string::String,
        /// Optional. The suffix that should be appended to all schema (BigQuery
        /// dataset ID) names.
        #[prost(string, tag = "2")]
        pub schema_suffix: ::prost::alloc::string::String,
        /// Optional. The prefix that should be prepended to all table names.
        #[prost(string, tag = "3")]
        pub table_prefix: ::prost::alloc::string::String,
    }
}
/// `ListRepositories` request message.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListRepositoriesRequest {
    /// Required. The location in which to list repositories. Must be in the format
    /// `projects/*/locations/*`.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. Maximum number of repositories to return. The server may return
    /// fewer items than requested. If unspecified, the server will pick an
    /// appropriate default.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. Page token received from a previous `ListRepositories` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to `ListRepositories`
    /// must match the call that provided the page token.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. This field only supports ordering by `name`. If unspecified, the
    /// server will choose the ordering. If specified, the default order is
    /// ascending for the `name` field.
    #[prost(string, tag = "4")]
    pub order_by: ::prost::alloc::string::String,
    /// Optional. Filter for the returned list.
    #[prost(string, tag = "5")]
    pub filter: ::prost::alloc::string::String,
}
/// `ListRepositories` response message.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListRepositoriesResponse {
    /// List of repositories.
    #[prost(message, repeated, tag = "1")]
    pub repositories: ::prost::alloc::vec::Vec<Repository>,
    /// A token which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    /// Locations which could not be reached.
    #[prost(string, repeated, tag = "3")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// `GetRepository` request message.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetRepositoryRequest {
    /// Required. The repository's name.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// `CreateRepository` request message.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateRepositoryRequest {
    /// Required. The location in which to create the repository. Must be in the
    /// format `projects/*/locations/*`.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The repository to create.
    #[prost(message, optional, tag = "2")]
    pub repository: ::core::option::Option<Repository>,
    /// Required. The ID to use for the repository, which will become the final
    /// component of the repository's resource name.
    #[prost(string, tag = "3")]
    pub repository_id: ::prost::alloc::string::String,
}
/// `UpdateRepository` request message.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateRepositoryRequest {
    /// Optional. Specifies the fields to be updated in the repository. If left
    /// unset, all fields will be updated.
    #[prost(message, optional, tag = "1")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// Required. The repository to update.
    #[prost(message, optional, tag = "2")]
    pub repository: ::core::option::Option<Repository>,
}
/// `DeleteRepository` request message.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteRepositoryRequest {
    /// Required. The repository's name.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// If set to true, any child resources of this repository will also be
    /// deleted. (Otherwise, the request will only succeed if the repository has no
    /// child resources.)
    #[prost(bool, tag = "2")]
    pub force: bool,
}
/// `CommitRepositoryChanges` request message.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CommitRepositoryChangesRequest {
    /// Required. The repository's name.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Required. The changes to commit to the repository.
    #[prost(message, optional, tag = "2")]
    pub commit_metadata: ::core::option::Option<CommitMetadata>,
    /// Optional. The commit SHA which must be the repository's current HEAD before
    /// applying this commit; otherwise this request will fail. If unset, no
    /// validation on the current HEAD commit SHA is performed.
    #[prost(string, tag = "4")]
    pub required_head_commit_sha: ::prost::alloc::string::String,
    /// A map to the path of the file to the operation. The path is the full file
    /// path including filename, from repository root.
    #[prost(map = "string, message", tag = "3")]
    pub file_operations: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        commit_repository_changes_request::FileOperation,
    >,
}
/// Nested message and enum types in `CommitRepositoryChangesRequest`.
pub mod commit_repository_changes_request {
    /// Represents a single file operation to the repository.
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct FileOperation {
        #[prost(oneof = "file_operation::Operation", tags = "1, 2")]
        pub operation: ::core::option::Option<file_operation::Operation>,
    }
    /// Nested message and enum types in `FileOperation`.
    pub mod file_operation {
        /// Represents the write file operation (for files added or modified).
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct WriteFile {
            /// The file's contents.
            #[prost(bytes = "vec", tag = "1")]
            pub contents: ::prost::alloc::vec::Vec<u8>,
        }
        /// Represents the delete file operation.
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct DeleteFile {}
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Operation {
            /// Represents the write operation.
            #[prost(message, tag = "1")]
            WriteFile(WriteFile),
            /// Represents the delete operation.
            #[prost(message, tag = "2")]
            DeleteFile(DeleteFile),
        }
    }
}
/// `ReadRepositoryFile` request message.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReadRepositoryFileRequest {
    /// Required. The repository's name.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. The commit SHA for the commit to read from. If unset, the file
    /// will be read from HEAD.
    #[prost(string, tag = "2")]
    pub commit_sha: ::prost::alloc::string::String,
    /// Required. Full file path to read including filename, from repository root.
    #[prost(string, tag = "3")]
    pub path: ::prost::alloc::string::String,
}
/// `ReadRepositoryFile` response message.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReadRepositoryFileResponse {
    /// The file's contents.
    #[prost(bytes = "vec", tag = "1")]
    pub contents: ::prost::alloc::vec::Vec<u8>,
}
/// `QueryRepositoryDirectoryContents` request message.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryRepositoryDirectoryContentsRequest {
    /// Required. The repository's name.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. The Commit SHA for the commit to query from. If unset, the
    /// directory will be queried from HEAD.
    #[prost(string, tag = "2")]
    pub commit_sha: ::prost::alloc::string::String,
    /// Optional. The directory's full path including directory name, relative to
    /// root. If left unset, the root is used.
    #[prost(string, tag = "3")]
    pub path: ::prost::alloc::string::String,
    /// Optional. Maximum number of paths to return. The server may return fewer
    /// items than requested. If unspecified, the server will pick an appropriate
    /// default.
    #[prost(int32, tag = "4")]
    pub page_size: i32,
    /// Optional. Page token received from a previous
    /// `QueryRepositoryDirectoryContents` call. Provide this to retrieve the
    /// subsequent page.
    ///
    /// When paginating, all other parameters provided to
    /// `QueryRepositoryDirectoryContents` must match the call that provided the
    /// page token.
    #[prost(string, tag = "5")]
    pub page_token: ::prost::alloc::string::String,
}
/// `QueryRepositoryDirectoryContents` response message.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryRepositoryDirectoryContentsResponse {
    /// List of entries in the directory.
    #[prost(message, repeated, tag = "1")]
    pub directory_entries: ::prost::alloc::vec::Vec<DirectoryEntry>,
    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// `FetchRepositoryHistory` request message.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FetchRepositoryHistoryRequest {
    /// Required. The repository's name.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. Maximum number of commits to return. The server may return fewer
    /// items than requested. If unspecified, the server will pick an appropriate
    /// default.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. Page token received from a previous `FetchRepositoryHistory`
    /// call. Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to `FetchRepositoryHistory`
    /// must match the call that provided the page token.
    #[prost(string, tag = "5")]
    pub page_token: ::prost::alloc::string::String,
}
/// `FetchRepositoryHistory` response message.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FetchRepositoryHistoryResponse {
    /// A list of commit logs, ordered by 'git log' default order.
    #[prost(message, repeated, tag = "1")]
    pub commits: ::prost::alloc::vec::Vec<CommitLogEntry>,
    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// Represents a single commit log.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CommitLogEntry {
    /// Commit timestamp.
    #[prost(message, optional, tag = "1")]
    pub commit_time: ::core::option::Option<::prost_types::Timestamp>,
    /// The commit SHA for this commit log entry.
    #[prost(string, tag = "2")]
    pub commit_sha: ::prost::alloc::string::String,
    /// The commit author for this commit log entry.
    #[prost(message, optional, tag = "3")]
    pub author: ::core::option::Option<CommitAuthor>,
    /// The commit message for this commit log entry.
    #[prost(string, tag = "4")]
    pub commit_message: ::prost::alloc::string::String,
}
/// Represents a Dataform Git commit.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CommitMetadata {
    /// Required. The commit's author.
    #[prost(message, optional, tag = "1")]
    pub author: ::core::option::Option<CommitAuthor>,
    /// Optional. The commit's message.
    #[prost(string, tag = "2")]
    pub commit_message: ::prost::alloc::string::String,
}
/// `ComputeRepositoryAccessTokenStatus` request message.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ComputeRepositoryAccessTokenStatusRequest {
    /// Required. The repository's name.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// `ComputeRepositoryAccessTokenStatus` response message.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ComputeRepositoryAccessTokenStatusResponse {
    /// Indicates the status of the Git access token.
    #[prost(
        enumeration = "compute_repository_access_token_status_response::TokenStatus",
        tag = "1"
    )]
    pub token_status: i32,
}
/// Nested message and enum types in `ComputeRepositoryAccessTokenStatusResponse`.
pub mod compute_repository_access_token_status_response {
    /// Indicates the status of a Git authentication token.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum TokenStatus {
        /// Default value. This value is unused.
        Unspecified = 0,
        /// The token could not be found in Secret Manager (or the Dataform
        /// Service Account did not have permission to access it).
        NotFound = 1,
        /// The token could not be used to authenticate against the Git remote.
        Invalid = 2,
        /// The token was used successfully to authenticate against the Git remote.
        Valid = 3,
    }
    impl TokenStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                TokenStatus::Unspecified => "TOKEN_STATUS_UNSPECIFIED",
                TokenStatus::NotFound => "NOT_FOUND",
                TokenStatus::Invalid => "INVALID",
                TokenStatus::Valid => "VALID",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TOKEN_STATUS_UNSPECIFIED" => Some(Self::Unspecified),
                "NOT_FOUND" => Some(Self::NotFound),
                "INVALID" => Some(Self::Invalid),
                "VALID" => Some(Self::Valid),
                _ => None,
            }
        }
    }
}
/// `FetchRemoteBranches` request message.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FetchRemoteBranchesRequest {
    /// Required. The repository's name.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// `FetchRemoteBranches` response message.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FetchRemoteBranchesResponse {
    /// The remote repository's branch names.
    #[prost(string, repeated, tag = "1")]
    pub branches: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Represents a Dataform Git workspace.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Workspace {
    /// Output only. The workspace's name.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// `ListWorkspaces` request message.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListWorkspacesRequest {
    /// Required. The repository in which to list workspaces. Must be in the
    /// format `projects/*/locations/*/repositories/*`.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. Maximum number of workspaces to return. The server may return
    /// fewer items than requested. If unspecified, the server will pick an
    /// appropriate default.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. Page token received from a previous `ListWorkspaces` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to `ListWorkspaces`
    /// must match the call that provided the page token.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. This field only supports ordering by `name`. If unspecified, the
    /// server will choose the ordering. If specified, the default order is
    /// ascending for the `name` field.
    #[prost(string, tag = "4")]
    pub order_by: ::prost::alloc::string::String,
    /// Optional. Filter for the returned list.
    #[prost(string, tag = "5")]
    pub filter: ::prost::alloc::string::String,
}
/// `ListWorkspaces` response message.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListWorkspacesResponse {
    /// List of workspaces.
    #[prost(message, repeated, tag = "1")]
    pub workspaces: ::prost::alloc::vec::Vec<Workspace>,
    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    /// Locations which could not be reached.
    #[prost(string, repeated, tag = "3")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// `GetWorkspace` request message.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetWorkspaceRequest {
    /// Required. The workspace's name.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// `CreateWorkspace` request message.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateWorkspaceRequest {
    /// Required. The repository in which to create the workspace. Must be in the
    /// format `projects/*/locations/*/repositories/*`.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The workspace to create.
    #[prost(message, optional, tag = "2")]
    pub workspace: ::core::option::Option<Workspace>,
    /// Required. The ID to use for the workspace, which will become the final
    /// component of the workspace's resource name.
    #[prost(string, tag = "3")]
    pub workspace_id: ::prost::alloc::string::String,
}
/// `DeleteWorkspace` request message.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteWorkspaceRequest {
    /// Required. The workspace resource's name.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Represents the author of a Git commit.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CommitAuthor {
    /// Required. The commit author's name.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Required. The commit author's email address.
    #[prost(string, tag = "2")]
    pub email_address: ::prost::alloc::string::String,
}
/// `PullGitCommits` request message.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PullGitCommitsRequest {
    /// Required. The workspace's name.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. The name of the branch in the Git remote from which to pull
    /// commits. If left unset, the repository's default branch name will be used.
    #[prost(string, tag = "2")]
    pub remote_branch: ::prost::alloc::string::String,
    /// Required. The author of any merge commit which may be created as a result
    /// of merging fetched Git commits into this workspace.
    #[prost(message, optional, tag = "3")]
    pub author: ::core::option::Option<CommitAuthor>,
}
/// `PushGitCommits` request message.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PushGitCommitsRequest {
    /// Required. The workspace's name.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. The name of the branch in the Git remote to which commits should
    /// be pushed. If left unset, the repository's default branch name will be
    /// used.
    #[prost(string, tag = "2")]
    pub remote_branch: ::prost::alloc::string::String,
}
/// `FetchFileGitStatuses` request message.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FetchFileGitStatusesRequest {
    /// Required. The workspace's name.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// `FetchFileGitStatuses` response message.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FetchFileGitStatusesResponse {
    /// A list of all files which have uncommitted Git changes. There will only be
    /// a single entry for any given file.
    #[prost(message, repeated, tag = "1")]
    pub uncommitted_file_changes: ::prost::alloc::vec::Vec<
        fetch_file_git_statuses_response::UncommittedFileChange,
    >,
}
/// Nested message and enum types in `FetchFileGitStatusesResponse`.
pub mod fetch_file_git_statuses_response {
    /// Represents the Git state of a file with uncommitted changes.
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct UncommittedFileChange {
        /// The file's full path including filename, relative to the workspace root.
        #[prost(string, tag = "1")]
        pub path: ::prost::alloc::string::String,
        /// Indicates the status of the file.
        #[prost(enumeration = "uncommitted_file_change::State", tag = "2")]
        pub state: i32,
    }
    /// Nested message and enum types in `UncommittedFileChange`.
    pub mod uncommitted_file_change {
        /// Indicates the status of an uncommitted file change.
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum State {
            /// Default value. This value is unused.
            Unspecified = 0,
            /// The file has been newly added.
            Added = 1,
            /// The file has been deleted.
            Deleted = 2,
            /// The file has been modified.
            Modified = 3,
            /// The file contains merge conflicts.
            HasConflicts = 4,
        }
        impl State {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    State::Unspecified => "STATE_UNSPECIFIED",
                    State::Added => "ADDED",
                    State::Deleted => "DELETED",
                    State::Modified => "MODIFIED",
                    State::HasConflicts => "HAS_CONFLICTS",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                    "ADDED" => Some(Self::Added),
                    "DELETED" => Some(Self::Deleted),
                    "MODIFIED" => Some(Self::Modified),
                    "HAS_CONFLICTS" => Some(Self::HasConflicts),
                    _ => None,
                }
            }
        }
    }
}
/// `FetchGitAheadBehind` request message.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FetchGitAheadBehindRequest {
    /// Required. The workspace's name.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. The name of the branch in the Git remote against which this
    /// workspace should be compared. If left unset, the repository's default
    /// branch name will be used.
    #[prost(string, tag = "2")]
    pub remote_branch: ::prost::alloc::string::String,
}
/// `FetchGitAheadBehind` response message.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FetchGitAheadBehindResponse {
    /// The number of commits in the remote branch that are not in the workspace.
    #[prost(int32, tag = "1")]
    pub commits_ahead: i32,
    /// The number of commits in the workspace that are not in the remote branch.
    #[prost(int32, tag = "2")]
    pub commits_behind: i32,
}
/// `CommitWorkspaceChanges` request message.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CommitWorkspaceChangesRequest {
    /// Required. The workspace's name.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Required. The commit's author.
    #[prost(message, optional, tag = "4")]
    pub author: ::core::option::Option<CommitAuthor>,
    /// Optional. The commit's message.
    #[prost(string, tag = "2")]
    pub commit_message: ::prost::alloc::string::String,
    /// Optional. Full file paths to commit including filename, rooted at workspace
    /// root. If left empty, all files will be committed.
    #[prost(string, repeated, tag = "3")]
    pub paths: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// `ResetWorkspaceChanges` request message.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResetWorkspaceChangesRequest {
    /// Required. The workspace's name.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. Full file paths to reset back to their committed state including
    /// filename, rooted at workspace root. If left empty, all files will be reset.
    #[prost(string, repeated, tag = "2")]
    pub paths: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Optional. If set to true, untracked files will be deleted.
    #[prost(bool, tag = "3")]
    pub clean: bool,
}
/// `FetchFileDiff` request message.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FetchFileDiffRequest {
    /// Required. The workspace's name.
    #[prost(string, tag = "1")]
    pub workspace: ::prost::alloc::string::String,
    /// Required. The file's full path including filename, relative to the
    /// workspace root.
    #[prost(string, tag = "2")]
    pub path: ::prost::alloc::string::String,
}
/// `FetchFileDiff` response message.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FetchFileDiffResponse {
    /// The raw formatted Git diff for the file.
    #[prost(string, tag = "1")]
    pub formatted_diff: ::prost::alloc::string::String,
}
/// `QueryDirectoryContents` request message.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryDirectoryContentsRequest {
    /// Required. The workspace's name.
    #[prost(string, tag = "1")]
    pub workspace: ::prost::alloc::string::String,
    /// Optional. The directory's full path including directory name, relative to
    /// the workspace root. If left unset, the workspace root is used.
    #[prost(string, tag = "2")]
    pub path: ::prost::alloc::string::String,
    /// Optional. Maximum number of paths to return. The server may return fewer
    /// items than requested. If unspecified, the server will pick an appropriate
    /// default.
    #[prost(int32, tag = "3")]
    pub page_size: i32,
    /// Optional. Page token received from a previous `QueryDirectoryContents`
    /// call. Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to
    /// `QueryDirectoryContents` must match the call that provided the page
    /// token.
    #[prost(string, tag = "4")]
    pub page_token: ::prost::alloc::string::String,
}
/// `QueryDirectoryContents` response message.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryDirectoryContentsResponse {
    /// List of entries in the directory.
    #[prost(message, repeated, tag = "1")]
    pub directory_entries: ::prost::alloc::vec::Vec<DirectoryEntry>,
    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// Represents a single entry in a directory.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DirectoryEntry {
    #[prost(oneof = "directory_entry::Entry", tags = "1, 2")]
    pub entry: ::core::option::Option<directory_entry::Entry>,
}
/// Nested message and enum types in `DirectoryEntry`.
pub mod directory_entry {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Entry {
        /// A file in the directory.
        #[prost(string, tag = "1")]
        File(::prost::alloc::string::String),
        /// A child directory in the directory.
        #[prost(string, tag = "2")]
        Directory(::prost::alloc::string::String),
    }
}
/// `MakeDirectory` request message.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MakeDirectoryRequest {
    /// Required. The workspace's name.
    #[prost(string, tag = "1")]
    pub workspace: ::prost::alloc::string::String,
    /// Required. The directory's full path including directory name, relative to
    /// the workspace root.
    #[prost(string, tag = "2")]
    pub path: ::prost::alloc::string::String,
}
/// `MakeDirectory` response message.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MakeDirectoryResponse {}
/// `RemoveDirectory` request message.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RemoveDirectoryRequest {
    /// Required. The workspace's name.
    #[prost(string, tag = "1")]
    pub workspace: ::prost::alloc::string::String,
    /// Required. The directory's full path including directory name, relative to
    /// the workspace root.
    #[prost(string, tag = "2")]
    pub path: ::prost::alloc::string::String,
}
/// `MoveDirectory` request message.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MoveDirectoryRequest {
    /// Required. The workspace's name.
    #[prost(string, tag = "1")]
    pub workspace: ::prost::alloc::string::String,
    /// Required. The directory's full path including directory name, relative to
    /// the workspace root.
    #[prost(string, tag = "2")]
    pub path: ::prost::alloc::string::String,
    /// Required. The new path for the directory including directory name, rooted
    /// at workspace root.
    #[prost(string, tag = "3")]
    pub new_path: ::prost::alloc::string::String,
}
/// `MoveDirectory` response message.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MoveDirectoryResponse {}
/// `ReadFile` request message.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReadFileRequest {
    /// Required. The workspace's name.
    #[prost(string, tag = "1")]
    pub workspace: ::prost::alloc::string::String,
    /// Required. The file's full path including filename, relative to the
    /// workspace root.
    #[prost(string, tag = "2")]
    pub path: ::prost::alloc::string::String,
}
/// `ReadFile` response message.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReadFileResponse {
    /// The file's contents.
    #[prost(bytes = "vec", tag = "1")]
    pub file_contents: ::prost::alloc::vec::Vec<u8>,
}
/// `RemoveFile` request message.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RemoveFileRequest {
    /// Required. The workspace's name.
    #[prost(string, tag = "1")]
    pub workspace: ::prost::alloc::string::String,
    /// Required. The file's full path including filename, relative to the
    /// workspace root.
    #[prost(string, tag = "2")]
    pub path: ::prost::alloc::string::String,
}
/// `MoveFile` request message.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MoveFileRequest {
    /// Required. The workspace's name.
    #[prost(string, tag = "1")]
    pub workspace: ::prost::alloc::string::String,
    /// Required. The file's full path including filename, relative to the
    /// workspace root.
    #[prost(string, tag = "2")]
    pub path: ::prost::alloc::string::String,
    /// Required. The file's new path including filename, relative to the workspace
    /// root.
    #[prost(string, tag = "3")]
    pub new_path: ::prost::alloc::string::String,
}
/// `MoveFile` response message.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MoveFileResponse {}
/// `WriteFile` request message.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WriteFileRequest {
    /// Required. The workspace's name.
    #[prost(string, tag = "1")]
    pub workspace: ::prost::alloc::string::String,
    /// Required. The file.
    #[prost(string, tag = "2")]
    pub path: ::prost::alloc::string::String,
    /// Required. The file's contents.
    #[prost(bytes = "vec", tag = "3")]
    pub contents: ::prost::alloc::vec::Vec<u8>,
}
/// `WriteFile` response message.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WriteFileResponse {}
/// `InstallNpmPackages` request message.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InstallNpmPackagesRequest {
    /// Required. The workspace's name.
    #[prost(string, tag = "1")]
    pub workspace: ::prost::alloc::string::String,
}
/// `InstallNpmPackages` response message.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InstallNpmPackagesResponse {}
/// Represents a Dataform release configuration.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReleaseConfig {
    /// Output only. The release config's name.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Required. Git commit/tag/branch name at which the repository should be
    /// compiled. Must exist in the remote repository. Examples:
    /// - a commit SHA: `12ade345`
    /// - a tag: `tag1`
    /// - a branch name: `branch1`
    #[prost(string, tag = "2")]
    pub git_commitish: ::prost::alloc::string::String,
    /// Optional. If set, fields of `code_compilation_config` override the default
    /// compilation settings that are specified in dataform.json.
    #[prost(message, optional, tag = "3")]
    pub code_compilation_config: ::core::option::Option<CodeCompilationConfig>,
    /// Optional. Optional schedule (in cron format) for automatic creation of
    /// compilation results.
    #[prost(string, tag = "4")]
    pub cron_schedule: ::prost::alloc::string::String,
    /// Optional. Specifies the time zone to be used when interpreting
    /// cron_schedule. Must be a time zone name from the time zone database
    /// (<https://en.wikipedia.org/wiki/List_of_tz_database_time_zones>). If left
    /// unspecified, the default is UTC.
    #[prost(string, tag = "7")]
    pub time_zone: ::prost::alloc::string::String,
    /// Output only. Records of the 10 most recent scheduled release attempts,
    /// ordered in in descending order of `release_time`. Updated whenever
    /// automatic creation of a compilation result is triggered by cron_schedule.
    #[prost(message, repeated, tag = "5")]
    pub recent_scheduled_release_records: ::prost::alloc::vec::Vec<
        release_config::ScheduledReleaseRecord,
    >,
    /// Optional. The name of the currently released compilation result for this
    /// release config. This value is updated when a compilation result is created
    /// from this release config, or when this resource is updated by API call
    /// (perhaps to roll back to an earlier release). The compilation result must
    /// have been created using this release config. Must be in the format
    /// `projects/*/locations/*/repositories/*/compilationResults/*`.
    #[prost(string, tag = "6")]
    pub release_compilation_result: ::prost::alloc::string::String,
}
/// Nested message and enum types in `ReleaseConfig`.
pub mod release_config {
    /// A record of an attempt to create a compilation result for this release
    /// config.
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ScheduledReleaseRecord {
        /// The timestamp of this release attempt.
        #[prost(message, optional, tag = "1")]
        pub release_time: ::core::option::Option<::prost_types::Timestamp>,
        #[prost(oneof = "scheduled_release_record::Result", tags = "2, 3")]
        pub result: ::core::option::Option<scheduled_release_record::Result>,
    }
    /// Nested message and enum types in `ScheduledReleaseRecord`.
    pub mod scheduled_release_record {
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Result {
            /// The name of the created compilation result, if one was successfully
            /// created. Must be in the format
            /// `projects/*/locations/*/repositories/*/compilationResults/*`.
            #[prost(string, tag = "2")]
            CompilationResult(::prost::alloc::string::String),
            /// The error status encountered upon this attempt to create the
            /// compilation result, if the attempt was unsuccessful.
            #[prost(message, tag = "3")]
            ErrorStatus(super::super::super::super::super::rpc::Status),
        }
    }
}
/// `ListReleaseConfigs` request message.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListReleaseConfigsRequest {
    /// Required. The repository in which to list release configs. Must be in the
    /// format `projects/*/locations/*/repositories/*`.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. Maximum number of release configs to return. The server may
    /// return fewer items than requested. If unspecified, the server will pick an
    /// appropriate default.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. Page token received from a previous `ListReleaseConfigs` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to `ListReleaseConfigs`
    /// must match the call that provided the page token.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
/// `ListReleaseConfigs` response message.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListReleaseConfigsResponse {
    /// List of release configs.
    #[prost(message, repeated, tag = "1")]
    pub release_configs: ::prost::alloc::vec::Vec<ReleaseConfig>,
    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    /// Locations which could not be reached.
    #[prost(string, repeated, tag = "3")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// `GetReleaseConfig` request message.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetReleaseConfigRequest {
    /// Required. The release config's name.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// `CreateReleaseConfig` request message.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateReleaseConfigRequest {
    /// Required. The repository in which to create the release config. Must be in
    /// the format `projects/*/locations/*/repositories/*`.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The release config to create.
    #[prost(message, optional, tag = "2")]
    pub release_config: ::core::option::Option<ReleaseConfig>,
    /// Required. The ID to use for the release config, which will become the final
    /// component of the release config's resource name.
    #[prost(string, tag = "3")]
    pub release_config_id: ::prost::alloc::string::String,
}
/// `UpdateReleaseConfig` request message.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateReleaseConfigRequest {
    /// Optional. Specifies the fields to be updated in the release config. If left
    /// unset, all fields will be updated.
    #[prost(message, optional, tag = "1")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// Required. The release config to update.
    #[prost(message, optional, tag = "2")]
    pub release_config: ::core::option::Option<ReleaseConfig>,
}
/// `DeleteReleaseConfig` request message.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteReleaseConfigRequest {
    /// Required. The release config's name.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Represents the result of compiling a Dataform project.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CompilationResult {
    /// Output only. The compilation result's name.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Immutable. If set, fields of `code_compilation_config` override the default
    /// compilation settings that are specified in dataform.json.
    #[prost(message, optional, tag = "4")]
    pub code_compilation_config: ::core::option::Option<CodeCompilationConfig>,
    /// Output only. The fully resolved Git commit SHA of the code that was
    /// compiled. Not set for compilation results whose source is a workspace.
    #[prost(string, tag = "8")]
    pub resolved_git_commit_sha: ::prost::alloc::string::String,
    /// Output only. The version of `@dataform/core` that was used for compilation.
    #[prost(string, tag = "5")]
    pub dataform_core_version: ::prost::alloc::string::String,
    /// Output only. Errors encountered during project compilation.
    #[prost(message, repeated, tag = "6")]
    pub compilation_errors: ::prost::alloc::vec::Vec<
        compilation_result::CompilationError,
    >,
    #[prost(oneof = "compilation_result::Source", tags = "2, 3, 7")]
    pub source: ::core::option::Option<compilation_result::Source>,
}
/// Nested message and enum types in `CompilationResult`.
pub mod compilation_result {
    /// An error encountered when attempting to compile a Dataform project.
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct CompilationError {
        /// Output only. The error's top level message.
        #[prost(string, tag = "1")]
        pub message: ::prost::alloc::string::String,
        /// Output only. The error's full stack trace.
        #[prost(string, tag = "2")]
        pub stack: ::prost::alloc::string::String,
        /// Output only. The path of the file where this error occurred, if
        /// available, relative to the project root.
        #[prost(string, tag = "3")]
        pub path: ::prost::alloc::string::String,
        /// Output only. The identifier of the action where this error occurred, if
        /// available.
        #[prost(message, optional, tag = "4")]
        pub action_target: ::core::option::Option<super::Target>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Source {
        /// Immutable. Git commit/tag/branch name at which the repository should be
        /// compiled. Must exist in the remote repository. Examples:
        /// - a commit SHA: `12ade345`
        /// - a tag: `tag1`
        /// - a branch name: `branch1`
        #[prost(string, tag = "2")]
        GitCommitish(::prost::alloc::string::String),
        /// Immutable. The name of the workspace to compile. Must be in the format
        /// `projects/*/locations/*/repositories/*/workspaces/*`.
        #[prost(string, tag = "3")]
        Workspace(::prost::alloc::string::String),
        /// Immutable. The name of the release config to compile. The release
        /// config's 'current_compilation_result' field will be updated to this
        /// compilation result. Must be in the format
        /// `projects/*/locations/*/repositories/*/releaseConfigs/*`.
        #[prost(string, tag = "7")]
        ReleaseConfig(::prost::alloc::string::String),
    }
}
/// Configures various aspects of Dataform code compilation.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CodeCompilationConfig {
    /// Optional. The default database (Google Cloud project ID).
    #[prost(string, tag = "1")]
    pub default_database: ::prost::alloc::string::String,
    /// Optional. The default schema (BigQuery dataset ID).
    #[prost(string, tag = "2")]
    pub default_schema: ::prost::alloc::string::String,
    /// Optional. The default BigQuery location to use. Defaults to "US".
    /// See the BigQuery docs for a full list of locations:
    /// <https://cloud.google.com/bigquery/docs/locations.>
    #[prost(string, tag = "8")]
    pub default_location: ::prost::alloc::string::String,
    /// Optional. The default schema (BigQuery dataset ID) for assertions.
    #[prost(string, tag = "3")]
    pub assertion_schema: ::prost::alloc::string::String,
    /// Optional. User-defined variables that are made available to project code
    /// during compilation.
    #[prost(map = "string, string", tag = "4")]
    pub vars: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Optional. The suffix that should be appended to all database (Google Cloud
    /// project ID) names.
    #[prost(string, tag = "5")]
    pub database_suffix: ::prost::alloc::string::String,
    /// Optional. The suffix that should be appended to all schema (BigQuery
    /// dataset ID) names.
    #[prost(string, tag = "6")]
    pub schema_suffix: ::prost::alloc::string::String,
    /// Optional. The prefix that should be prepended to all table names.
    #[prost(string, tag = "7")]
    pub table_prefix: ::prost::alloc::string::String,
}
/// `ListCompilationResults` request message.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListCompilationResultsRequest {
    /// Required. The repository in which to list compilation results. Must be in
    /// the format `projects/*/locations/*/repositories/*`.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. Maximum number of compilation results to return. The server may
    /// return fewer items than requested. If unspecified, the server will pick an
    /// appropriate default.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. Page token received from a previous `ListCompilationResults`
    /// call. Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to `ListCompilationResults`
    /// must match the call that provided the page token.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
/// `ListCompilationResults` response message.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListCompilationResultsResponse {
    /// List of compilation results.
    #[prost(message, repeated, tag = "1")]
    pub compilation_results: ::prost::alloc::vec::Vec<CompilationResult>,
    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    /// Locations which could not be reached.
    #[prost(string, repeated, tag = "3")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// `GetCompilationResult` request message.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetCompilationResultRequest {
    /// Required. The compilation result's name.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// `CreateCompilationResult` request message.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateCompilationResultRequest {
    /// Required. The repository in which to create the compilation result. Must be
    /// in the format `projects/*/locations/*/repositories/*`.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The compilation result to create.
    #[prost(message, optional, tag = "2")]
    pub compilation_result: ::core::option::Option<CompilationResult>,
}
/// Represents an action identifier. If the action writes output, the output
/// will be written to the referenced database object.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Target {
    /// The action's database (Google Cloud project ID) .
    #[prost(string, tag = "1")]
    pub database: ::prost::alloc::string::String,
    /// The action's schema (BigQuery dataset ID), within `database`.
    #[prost(string, tag = "2")]
    pub schema: ::prost::alloc::string::String,
    /// The action's name, within `database` and `schema`.
    #[prost(string, tag = "3")]
    pub name: ::prost::alloc::string::String,
}
/// Describes a relation and its columns.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RelationDescriptor {
    /// A text description of the relation.
    #[prost(string, tag = "1")]
    pub description: ::prost::alloc::string::String,
    /// A list of descriptions of columns within the relation.
    #[prost(message, repeated, tag = "2")]
    pub columns: ::prost::alloc::vec::Vec<relation_descriptor::ColumnDescriptor>,
    /// A set of BigQuery labels that should be applied to the relation.
    #[prost(map = "string, string", tag = "3")]
    pub bigquery_labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
/// Nested message and enum types in `RelationDescriptor`.
pub mod relation_descriptor {
    /// Describes a column.
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ColumnDescriptor {
        /// The identifier for the column. Each entry in `path` represents one level
        /// of nesting.
        #[prost(string, repeated, tag = "1")]
        pub path: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        /// A textual description of the column.
        #[prost(string, tag = "2")]
        pub description: ::prost::alloc::string::String,
        /// A list of BigQuery policy tags that will be applied to the column.
        #[prost(string, repeated, tag = "3")]
        pub bigquery_policy_tags: ::prost::alloc::vec::Vec<
            ::prost::alloc::string::String,
        >,
    }
}
/// Represents a single Dataform action in a compilation result.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CompilationResultAction {
    /// This action's identifier. Unique within the compilation result.
    #[prost(message, optional, tag = "1")]
    pub target: ::core::option::Option<Target>,
    /// The action's identifier if the project had been compiled without any
    /// overrides configured. Unique within the compilation result.
    #[prost(message, optional, tag = "2")]
    pub canonical_target: ::core::option::Option<Target>,
    /// The full path including filename in which this action is located, relative
    /// to the workspace root.
    #[prost(string, tag = "3")]
    pub file_path: ::prost::alloc::string::String,
    #[prost(oneof = "compilation_result_action::CompiledObject", tags = "4, 5, 6, 7")]
    pub compiled_object: ::core::option::Option<
        compilation_result_action::CompiledObject,
    >,
}
/// Nested message and enum types in `CompilationResultAction`.
pub mod compilation_result_action {
    /// Represents a database relation.
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Relation {
        /// A list of actions that this action depends on.
        #[prost(message, repeated, tag = "1")]
        pub dependency_targets: ::prost::alloc::vec::Vec<super::Target>,
        /// Whether this action is disabled (i.e. should not be run).
        #[prost(bool, tag = "2")]
        pub disabled: bool,
        /// Arbitrary, user-defined tags on this action.
        #[prost(string, repeated, tag = "3")]
        pub tags: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        /// Descriptor for the relation and its columns.
        #[prost(message, optional, tag = "4")]
        pub relation_descriptor: ::core::option::Option<super::RelationDescriptor>,
        /// The type of this relation.
        #[prost(enumeration = "relation::RelationType", tag = "5")]
        pub relation_type: i32,
        /// The SELECT query which returns rows which this relation should contain.
        #[prost(string, tag = "6")]
        pub select_query: ::prost::alloc::string::String,
        /// SQL statements to be executed before creating the relation.
        #[prost(string, repeated, tag = "7")]
        pub pre_operations: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        /// SQL statements to be executed after creating the relation.
        #[prost(string, repeated, tag = "8")]
        pub post_operations: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        /// Configures `INCREMENTAL_TABLE` settings for this relation. Only set if
        /// `relation_type` is `INCREMENTAL_TABLE`.
        #[prost(message, optional, tag = "9")]
        pub incremental_table_config: ::core::option::Option<
            relation::IncrementalTableConfig,
        >,
        /// The SQL expression used to partition the relation.
        #[prost(string, tag = "10")]
        pub partition_expression: ::prost::alloc::string::String,
        /// A list of columns or SQL expressions used to cluster the table.
        #[prost(string, repeated, tag = "11")]
        pub cluster_expressions: ::prost::alloc::vec::Vec<
            ::prost::alloc::string::String,
        >,
        /// Sets the partition expiration in days.
        #[prost(int32, tag = "12")]
        pub partition_expiration_days: i32,
        /// Specifies whether queries on this table must include a predicate filter
        /// that filters on the partitioning column.
        #[prost(bool, tag = "13")]
        pub require_partition_filter: bool,
        /// Additional options that will be provided as key/value pairs into the
        /// options clause of a create table/view statement. See
        /// <https://cloud.google.com/bigquery/docs/reference/standard-sql/data-definition-language>
        /// for more information on which options are supported.
        #[prost(map = "string, string", tag = "14")]
        pub additional_options: ::std::collections::HashMap<
            ::prost::alloc::string::String,
            ::prost::alloc::string::String,
        >,
    }
    /// Nested message and enum types in `Relation`.
    pub mod relation {
        /// Contains settings for relations of type `INCREMENTAL_TABLE`.
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct IncrementalTableConfig {
            /// The SELECT query which returns rows which should be inserted into the
            /// relation if it already exists and is not being refreshed.
            #[prost(string, tag = "1")]
            pub incremental_select_query: ::prost::alloc::string::String,
            /// Whether this table should be protected from being refreshed.
            #[prost(bool, tag = "2")]
            pub refresh_disabled: bool,
            /// A set of columns or SQL expressions used to define row uniqueness.
            /// If any duplicates are discovered (as defined by `unique_key_parts`),
            /// only the newly selected rows (as defined by `incremental_select_query`)
            /// will be included in the relation.
            #[prost(string, repeated, tag = "3")]
            pub unique_key_parts: ::prost::alloc::vec::Vec<
                ::prost::alloc::string::String,
            >,
            /// A SQL expression conditional used to limit the set of existing rows
            /// considered for a merge operation (see `unique_key_parts` for more
            /// information).
            #[prost(string, tag = "4")]
            pub update_partition_filter: ::prost::alloc::string::String,
            /// SQL statements to be executed before inserting new rows into the
            /// relation.
            #[prost(string, repeated, tag = "5")]
            pub incremental_pre_operations: ::prost::alloc::vec::Vec<
                ::prost::alloc::string::String,
            >,
            /// SQL statements to be executed after inserting new rows into the
            /// relation.
            #[prost(string, repeated, tag = "6")]
            pub incremental_post_operations: ::prost::alloc::vec::Vec<
                ::prost::alloc::string::String,
            >,
        }
        /// Indicates the type of this relation.
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum RelationType {
            /// Default value. This value is unused.
            Unspecified = 0,
            /// The relation is a table.
            Table = 1,
            /// The relation is a view.
            View = 2,
            /// The relation is an incrementalized table.
            IncrementalTable = 3,
            /// The relation is a materialized view.
            MaterializedView = 4,
        }
        impl RelationType {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    RelationType::Unspecified => "RELATION_TYPE_UNSPECIFIED",
                    RelationType::Table => "TABLE",
                    RelationType::View => "VIEW",
                    RelationType::IncrementalTable => "INCREMENTAL_TABLE",
                    RelationType::MaterializedView => "MATERIALIZED_VIEW",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "RELATION_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                    "TABLE" => Some(Self::Table),
                    "VIEW" => Some(Self::View),
                    "INCREMENTAL_TABLE" => Some(Self::IncrementalTable),
                    "MATERIALIZED_VIEW" => Some(Self::MaterializedView),
                    _ => None,
                }
            }
        }
    }
    /// Represents a list of arbitrary database operations.
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Operations {
        /// A list of actions that this action depends on.
        #[prost(message, repeated, tag = "1")]
        pub dependency_targets: ::prost::alloc::vec::Vec<super::Target>,
        /// Whether this action is disabled (i.e. should not be run).
        #[prost(bool, tag = "2")]
        pub disabled: bool,
        /// Arbitrary, user-defined tags on this action.
        #[prost(string, repeated, tag = "3")]
        pub tags: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        /// Descriptor for any output relation and its columns. Only set if
        /// `has_output` is true.
        #[prost(message, optional, tag = "6")]
        pub relation_descriptor: ::core::option::Option<super::RelationDescriptor>,
        /// A list of arbitrary SQL statements that will be executed without
        /// alteration.
        #[prost(string, repeated, tag = "4")]
        pub queries: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        /// Whether these operations produce an output relation.
        #[prost(bool, tag = "5")]
        pub has_output: bool,
    }
    /// Represents an assertion upon a SQL query which is required return zero
    /// rows.
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Assertion {
        /// A list of actions that this action depends on.
        #[prost(message, repeated, tag = "1")]
        pub dependency_targets: ::prost::alloc::vec::Vec<super::Target>,
        /// The parent action of this assertion. Only set if this assertion was
        /// automatically generated.
        #[prost(message, optional, tag = "5")]
        pub parent_action: ::core::option::Option<super::Target>,
        /// Whether this action is disabled (i.e. should not be run).
        #[prost(bool, tag = "2")]
        pub disabled: bool,
        /// Arbitrary, user-defined tags on this action.
        #[prost(string, repeated, tag = "3")]
        pub tags: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        /// The SELECT query which must return zero rows in order for this assertion
        /// to succeed.
        #[prost(string, tag = "4")]
        pub select_query: ::prost::alloc::string::String,
        /// Descriptor for the assertion's automatically-generated view and its
        /// columns.
        #[prost(message, optional, tag = "6")]
        pub relation_descriptor: ::core::option::Option<super::RelationDescriptor>,
    }
    /// Represents a relation which is not managed by Dataform but which may be
    /// referenced by Dataform actions.
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Declaration {
        /// Descriptor for the relation and its columns. Used as documentation only,
        /// i.e. values here will result in no changes to the relation's metadata.
        #[prost(message, optional, tag = "1")]
        pub relation_descriptor: ::core::option::Option<super::RelationDescriptor>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum CompiledObject {
        /// The database relation created/updated by this action.
        #[prost(message, tag = "4")]
        Relation(Relation),
        /// The database operations executed by this action.
        #[prost(message, tag = "5")]
        Operations(Operations),
        /// The assertion executed by this action.
        #[prost(message, tag = "6")]
        Assertion(Assertion),
        /// The declaration declared by this action.
        #[prost(message, tag = "7")]
        Declaration(Declaration),
    }
}
/// `QueryCompilationResultActions` request message.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryCompilationResultActionsRequest {
    /// Required. The compilation result's name.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. Maximum number of compilation results to return. The server may
    /// return fewer items than requested. If unspecified, the server will pick an
    /// appropriate default.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. Page token received from a previous
    /// `QueryCompilationResultActions` call. Provide this to retrieve the
    /// subsequent page.
    ///
    /// When paginating, all other parameters provided to
    /// `QueryCompilationResultActions` must match the call that provided the page
    /// token.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. Optional filter for the returned list. Filtering is only
    /// currently supported on the `file_path` field.
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
}
/// `QueryCompilationResultActions` response message.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryCompilationResultActionsResponse {
    /// List of compilation result actions.
    #[prost(message, repeated, tag = "1")]
    pub compilation_result_actions: ::prost::alloc::vec::Vec<CompilationResultAction>,
    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// Represents a Dataform workflow configuration.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorkflowConfig {
    /// Output only. The workflow config's name.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Required. The name of the release config whose release_compilation_result
    /// should be executed. Must be in the format
    /// `projects/*/locations/*/repositories/*/releaseConfigs/*`.
    #[prost(string, tag = "2")]
    pub release_config: ::prost::alloc::string::String,
    /// Optional. If left unset, a default InvocationConfig will be used.
    #[prost(message, optional, tag = "3")]
    pub invocation_config: ::core::option::Option<InvocationConfig>,
    /// Optional. Optional schedule (in cron format) for automatic execution of
    /// this workflow config.
    #[prost(string, tag = "4")]
    pub cron_schedule: ::prost::alloc::string::String,
    /// Optional. Specifies the time zone to be used when interpreting
    /// cron_schedule. Must be a time zone name from the time zone database
    /// (<https://en.wikipedia.org/wiki/List_of_tz_database_time_zones>). If left
    /// unspecified, the default is UTC.
    #[prost(string, tag = "7")]
    pub time_zone: ::prost::alloc::string::String,
    /// Output only. Records of the 10 most recent scheduled execution attempts,
    /// ordered in in descending order of `execution_time`. Updated whenever
    /// automatic creation of a workflow invocation is triggered by cron_schedule.
    #[prost(message, repeated, tag = "5")]
    pub recent_scheduled_execution_records: ::prost::alloc::vec::Vec<
        workflow_config::ScheduledExecutionRecord,
    >,
}
/// Nested message and enum types in `WorkflowConfig`.
pub mod workflow_config {
    /// A record of an attempt to create a workflow invocation for this workflow
    /// config.
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ScheduledExecutionRecord {
        /// The timestamp of this execution attempt.
        #[prost(message, optional, tag = "1")]
        pub execution_time: ::core::option::Option<::prost_types::Timestamp>,
        #[prost(oneof = "scheduled_execution_record::Result", tags = "2, 3")]
        pub result: ::core::option::Option<scheduled_execution_record::Result>,
    }
    /// Nested message and enum types in `ScheduledExecutionRecord`.
    pub mod scheduled_execution_record {
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Result {
            /// The name of the created workflow invocation, if one was successfully
            /// created. Must be in the format
            /// `projects/*/locations/*/repositories/*/workflowInvocations/*`.
            #[prost(string, tag = "2")]
            WorkflowInvocation(::prost::alloc::string::String),
            /// The error status encountered upon this attempt to create the
            /// workflow invocation, if the attempt was unsuccessful.
            #[prost(message, tag = "3")]
            ErrorStatus(super::super::super::super::super::rpc::Status),
        }
    }
}
/// Includes various configuration options for a workflow invocation.
/// If both `included_targets` and `included_tags` are unset, all actions
/// will be included.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InvocationConfig {
    /// Optional. The set of action identifiers to include.
    #[prost(message, repeated, tag = "1")]
    pub included_targets: ::prost::alloc::vec::Vec<Target>,
    /// Optional. The set of tags to include.
    #[prost(string, repeated, tag = "2")]
    pub included_tags: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Optional. When set to true, transitive dependencies of included actions
    /// will be executed.
    #[prost(bool, tag = "3")]
    pub transitive_dependencies_included: bool,
    /// Optional. When set to true, transitive dependents of included actions will
    /// be executed.
    #[prost(bool, tag = "4")]
    pub transitive_dependents_included: bool,
    /// Optional. When set to true, any incremental tables will be fully refreshed.
    #[prost(bool, tag = "5")]
    pub fully_refresh_incremental_tables_enabled: bool,
    /// Optional. The service account to run workflow invocations under.
    #[prost(string, tag = "6")]
    pub service_account: ::prost::alloc::string::String,
}
/// `ListWorkflowConfigs` request message.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListWorkflowConfigsRequest {
    /// Required. The repository in which to list workflow configs. Must be in the
    /// format `projects/*/locations/*/repositories/*`.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. Maximum number of workflow configs to return. The server may
    /// return fewer items than requested. If unspecified, the server will pick an
    /// appropriate default.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. Page token received from a previous `ListWorkflowConfigs` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to `ListWorkflowConfigs`
    /// must match the call that provided the page token.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
/// `ListWorkflowConfigs` response message.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListWorkflowConfigsResponse {
    /// List of workflow configs.
    #[prost(message, repeated, tag = "1")]
    pub workflow_configs: ::prost::alloc::vec::Vec<WorkflowConfig>,
    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    /// Locations which could not be reached.
    #[prost(string, repeated, tag = "3")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// `GetWorkflowConfig` request message.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetWorkflowConfigRequest {
    /// Required. The workflow config's name.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// `CreateWorkflowConfig` request message.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateWorkflowConfigRequest {
    /// Required. The repository in which to create the workflow config. Must be in
    /// the format `projects/*/locations/*/repositories/*`.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The workflow config to create.
    #[prost(message, optional, tag = "2")]
    pub workflow_config: ::core::option::Option<WorkflowConfig>,
    /// Required. The ID to use for the workflow config, which will become the
    /// final component of the workflow config's resource name.
    #[prost(string, tag = "3")]
    pub workflow_config_id: ::prost::alloc::string::String,
}
/// `UpdateWorkflowConfig` request message.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateWorkflowConfigRequest {
    /// Optional. Specifies the fields to be updated in the workflow config. If
    /// left unset, all fields will be updated.
    #[prost(message, optional, tag = "1")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// Required. The workflow config to update.
    #[prost(message, optional, tag = "2")]
    pub workflow_config: ::core::option::Option<WorkflowConfig>,
}
/// `DeleteWorkflowConfig` request message.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteWorkflowConfigRequest {
    /// Required. The workflow config's name.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Represents a single invocation of a compilation result.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorkflowInvocation {
    /// Output only. The workflow invocation's name.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Immutable. If left unset, a default InvocationConfig will be used.
    #[prost(message, optional, tag = "3")]
    pub invocation_config: ::core::option::Option<InvocationConfig>,
    /// Output only. This workflow invocation's current state.
    #[prost(enumeration = "workflow_invocation::State", tag = "4")]
    pub state: i32,
    /// Output only. This workflow invocation's timing details.
    #[prost(message, optional, tag = "5")]
    pub invocation_timing: ::core::option::Option<super::super::super::r#type::Interval>,
    #[prost(oneof = "workflow_invocation::CompilationSource", tags = "2, 6")]
    pub compilation_source: ::core::option::Option<
        workflow_invocation::CompilationSource,
    >,
}
/// Nested message and enum types in `WorkflowInvocation`.
pub mod workflow_invocation {
    /// Represents the current state of a workflow invocation.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        /// Default value. This value is unused.
        Unspecified = 0,
        /// The workflow invocation is currently running.
        Running = 1,
        /// The workflow invocation succeeded. A terminal state.
        Succeeded = 2,
        /// The workflow invocation was cancelled. A terminal state.
        Cancelled = 3,
        /// The workflow invocation failed. A terminal state.
        Failed = 4,
        /// The workflow invocation is being cancelled, but some actions are still
        /// running.
        Canceling = 5,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                State::Unspecified => "STATE_UNSPECIFIED",
                State::Running => "RUNNING",
                State::Succeeded => "SUCCEEDED",
                State::Cancelled => "CANCELLED",
                State::Failed => "FAILED",
                State::Canceling => "CANCELING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "RUNNING" => Some(Self::Running),
                "SUCCEEDED" => Some(Self::Succeeded),
                "CANCELLED" => Some(Self::Cancelled),
                "FAILED" => Some(Self::Failed),
                "CANCELING" => Some(Self::Canceling),
                _ => None,
            }
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum CompilationSource {
        /// Immutable. The name of the compilation result to use for this invocation.
        /// Must be in the format
        /// `projects/*/locations/*/repositories/*/compilationResults/*`.
        #[prost(string, tag = "2")]
        CompilationResult(::prost::alloc::string::String),
        /// Immutable. The name of the workflow config to invoke. Must be in the
        /// format `projects/*/locations/*/repositories/*/workflowConfigs/*`.
        #[prost(string, tag = "6")]
        WorkflowConfig(::prost::alloc::string::String),
    }
}
/// `ListWorkflowInvocations` request message.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListWorkflowInvocationsRequest {
    /// Required. The parent resource of the WorkflowInvocation type. Must be in
    /// the format `projects/*/locations/*/repositories/*`.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. Maximum number of workflow invocations to return. The server may
    /// return fewer items than requested. If unspecified, the server will pick an
    /// appropriate default.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. Page token received from a previous `ListWorkflowInvocations`
    /// call. Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to `ListWorkflowInvocations`
    /// must match the call that provided the page token.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. This field only supports ordering by `name`. If unspecified, the
    /// server will choose the ordering. If specified, the default order is
    /// ascending for the `name` field.
    #[prost(string, tag = "4")]
    pub order_by: ::prost::alloc::string::String,
    /// Optional. Filter for the returned list.
    #[prost(string, tag = "5")]
    pub filter: ::prost::alloc::string::String,
}
/// `ListWorkflowInvocations` response message.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListWorkflowInvocationsResponse {
    /// List of workflow invocations.
    #[prost(message, repeated, tag = "1")]
    pub workflow_invocations: ::prost::alloc::vec::Vec<WorkflowInvocation>,
    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    /// Locations which could not be reached.
    #[prost(string, repeated, tag = "3")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// `GetWorkflowInvocation` request message.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetWorkflowInvocationRequest {
    /// Required. The workflow invocation resource's name.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// `CreateWorkflowInvocation` request message.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateWorkflowInvocationRequest {
    /// Required. The repository in which to create the workflow invocation. Must
    /// be in the format `projects/*/locations/*/repositories/*`.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The workflow invocation resource to create.
    #[prost(message, optional, tag = "2")]
    pub workflow_invocation: ::core::option::Option<WorkflowInvocation>,
}
/// `DeleteWorkflowInvocation` request message.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteWorkflowInvocationRequest {
    /// Required. The workflow invocation resource's name.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// `CancelWorkflowInvocation` request message.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CancelWorkflowInvocationRequest {
    /// Required. The workflow invocation resource's name.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Represents a single action in a workflow invocation.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorkflowInvocationAction {
    /// Output only. This action's identifier. Unique within the workflow
    /// invocation.
    #[prost(message, optional, tag = "1")]
    pub target: ::core::option::Option<Target>,
    /// Output only. The action's identifier if the project had been compiled
    /// without any overrides configured. Unique within the compilation result.
    #[prost(message, optional, tag = "2")]
    pub canonical_target: ::core::option::Option<Target>,
    /// Output only. This action's current state.
    #[prost(enumeration = "workflow_invocation_action::State", tag = "4")]
    pub state: i32,
    /// Output only. If and only if action's state is FAILED a failure reason is
    /// set.
    #[prost(string, tag = "7")]
    pub failure_reason: ::prost::alloc::string::String,
    /// Output only. This action's timing details.
    /// `start_time` will be set if the action is in [RUNNING, SUCCEEDED,
    /// CANCELLED, FAILED] state.
    /// `end_time` will be set if the action is in \[SUCCEEDED, CANCELLED, FAILED\]
    /// state.
    #[prost(message, optional, tag = "5")]
    pub invocation_timing: ::core::option::Option<super::super::super::r#type::Interval>,
    /// Output only. The workflow action's bigquery action details.
    #[prost(message, optional, tag = "6")]
    pub bigquery_action: ::core::option::Option<
        workflow_invocation_action::BigQueryAction,
    >,
}
/// Nested message and enum types in `WorkflowInvocationAction`.
pub mod workflow_invocation_action {
    /// Represents a workflow action that will run against BigQuery.
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct BigQueryAction {
        /// Output only. The generated BigQuery SQL script that will be executed.
        #[prost(string, tag = "1")]
        pub sql_script: ::prost::alloc::string::String,
    }
    /// Represents the current state of a workflow invocation action.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        /// The action has not yet been considered for invocation.
        Pending = 0,
        /// The action is currently running.
        Running = 1,
        /// Execution of the action was skipped because upstream dependencies did not
        /// all complete successfully. A terminal state.
        Skipped = 2,
        /// Execution of the action was disabled as per the configuration of the
        /// corresponding compilation result action. A terminal state.
        Disabled = 3,
        /// The action succeeded. A terminal state.
        Succeeded = 4,
        /// The action was cancelled. A terminal state.
        Cancelled = 5,
        /// The action failed. A terminal state.
        Failed = 6,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                State::Pending => "PENDING",
                State::Running => "RUNNING",
                State::Skipped => "SKIPPED",
                State::Disabled => "DISABLED",
                State::Succeeded => "SUCCEEDED",
                State::Cancelled => "CANCELLED",
                State::Failed => "FAILED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "PENDING" => Some(Self::Pending),
                "RUNNING" => Some(Self::Running),
                "SKIPPED" => Some(Self::Skipped),
                "DISABLED" => Some(Self::Disabled),
                "SUCCEEDED" => Some(Self::Succeeded),
                "CANCELLED" => Some(Self::Cancelled),
                "FAILED" => Some(Self::Failed),
                _ => None,
            }
        }
    }
}
/// `QueryWorkflowInvocationActions` request message.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryWorkflowInvocationActionsRequest {
    /// Required. The workflow invocation's name.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. Maximum number of workflow invocations to return. The server may
    /// return fewer items than requested. If unspecified, the server will pick an
    /// appropriate default.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. Page token received from a previous
    /// `QueryWorkflowInvocationActions` call. Provide this to retrieve the
    /// subsequent page.
    ///
    /// When paginating, all other parameters provided to
    /// `QueryWorkflowInvocationActions` must match the call that provided the page
    /// token.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
/// `QueryWorkflowInvocationActions` response message.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryWorkflowInvocationActionsResponse {
    /// List of workflow invocation actions.
    #[prost(message, repeated, tag = "1")]
    pub workflow_invocation_actions: ::prost::alloc::vec::Vec<WorkflowInvocationAction>,
    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// Generated server implementations.
pub mod dataform_server {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with DataformServer.
    #[async_trait]
    pub trait Dataform: Send + Sync + 'static {
        /// Lists Repositories in a given project and location.
        async fn list_repositories(
            &self,
            request: tonic::Request<super::ListRepositoriesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListRepositoriesResponse>,
            tonic::Status,
        >;
        /// Fetches a single Repository.
        async fn get_repository(
            &self,
            request: tonic::Request<super::GetRepositoryRequest>,
        ) -> std::result::Result<tonic::Response<super::Repository>, tonic::Status>;
        /// Creates a new Repository in a given project and location.
        async fn create_repository(
            &self,
            request: tonic::Request<super::CreateRepositoryRequest>,
        ) -> std::result::Result<tonic::Response<super::Repository>, tonic::Status>;
        /// Updates a single Repository.
        async fn update_repository(
            &self,
            request: tonic::Request<super::UpdateRepositoryRequest>,
        ) -> std::result::Result<tonic::Response<super::Repository>, tonic::Status>;
        /// Deletes a single Repository.
        async fn delete_repository(
            &self,
            request: tonic::Request<super::DeleteRepositoryRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status>;
        /// Applies a Git commit to a Repository. The Repository must not have a value
        /// for `git_remote_settings.url`.
        async fn commit_repository_changes(
            &self,
            request: tonic::Request<super::CommitRepositoryChangesRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status>;
        /// Returns the contents of a file (inside a Repository). The Repository
        /// must not have a value for `git_remote_settings.url`.
        async fn read_repository_file(
            &self,
            request: tonic::Request<super::ReadRepositoryFileRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ReadRepositoryFileResponse>,
            tonic::Status,
        >;
        /// Returns the contents of a given Repository directory. The Repository must
        /// not have a value for `git_remote_settings.url`.
        async fn query_repository_directory_contents(
            &self,
            request: tonic::Request<super::QueryRepositoryDirectoryContentsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryRepositoryDirectoryContentsResponse>,
            tonic::Status,
        >;
        /// Fetches a Repository's history of commits.  The Repository must not have a
        /// value for `git_remote_settings.url`.
        async fn fetch_repository_history(
            &self,
            request: tonic::Request<super::FetchRepositoryHistoryRequest>,
        ) -> std::result::Result<
            tonic::Response<super::FetchRepositoryHistoryResponse>,
            tonic::Status,
        >;
        /// Computes a Repository's Git access token status.
        async fn compute_repository_access_token_status(
            &self,
            request: tonic::Request<super::ComputeRepositoryAccessTokenStatusRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ComputeRepositoryAccessTokenStatusResponse>,
            tonic::Status,
        >;
        /// Fetches a Repository's remote branches.
        async fn fetch_remote_branches(
            &self,
            request: tonic::Request<super::FetchRemoteBranchesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::FetchRemoteBranchesResponse>,
            tonic::Status,
        >;
        /// Lists Workspaces in a given Repository.
        async fn list_workspaces(
            &self,
            request: tonic::Request<super::ListWorkspacesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListWorkspacesResponse>,
            tonic::Status,
        >;
        /// Fetches a single Workspace.
        async fn get_workspace(
            &self,
            request: tonic::Request<super::GetWorkspaceRequest>,
        ) -> std::result::Result<tonic::Response<super::Workspace>, tonic::Status>;
        /// Creates a new Workspace in a given Repository.
        async fn create_workspace(
            &self,
            request: tonic::Request<super::CreateWorkspaceRequest>,
        ) -> std::result::Result<tonic::Response<super::Workspace>, tonic::Status>;
        /// Deletes a single Workspace.
        async fn delete_workspace(
            &self,
            request: tonic::Request<super::DeleteWorkspaceRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status>;
        /// Installs dependency NPM packages (inside a Workspace).
        async fn install_npm_packages(
            &self,
            request: tonic::Request<super::InstallNpmPackagesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::InstallNpmPackagesResponse>,
            tonic::Status,
        >;
        /// Pulls Git commits from the Repository's remote into a Workspace.
        async fn pull_git_commits(
            &self,
            request: tonic::Request<super::PullGitCommitsRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status>;
        /// Pushes Git commits from a Workspace to the Repository's remote.
        async fn push_git_commits(
            &self,
            request: tonic::Request<super::PushGitCommitsRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status>;
        /// Fetches Git statuses for the files in a Workspace.
        async fn fetch_file_git_statuses(
            &self,
            request: tonic::Request<super::FetchFileGitStatusesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::FetchFileGitStatusesResponse>,
            tonic::Status,
        >;
        /// Fetches Git ahead/behind against a remote branch.
        async fn fetch_git_ahead_behind(
            &self,
            request: tonic::Request<super::FetchGitAheadBehindRequest>,
        ) -> std::result::Result<
            tonic::Response<super::FetchGitAheadBehindResponse>,
            tonic::Status,
        >;
        /// Applies a Git commit for uncommitted files in a Workspace.
        async fn commit_workspace_changes(
            &self,
            request: tonic::Request<super::CommitWorkspaceChangesRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status>;
        /// Performs a Git reset for uncommitted files in a Workspace.
        async fn reset_workspace_changes(
            &self,
            request: tonic::Request<super::ResetWorkspaceChangesRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status>;
        /// Fetches Git diff for an uncommitted file in a Workspace.
        async fn fetch_file_diff(
            &self,
            request: tonic::Request<super::FetchFileDiffRequest>,
        ) -> std::result::Result<
            tonic::Response<super::FetchFileDiffResponse>,
            tonic::Status,
        >;
        /// Returns the contents of a given Workspace directory.
        async fn query_directory_contents(
            &self,
            request: tonic::Request<super::QueryDirectoryContentsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryDirectoryContentsResponse>,
            tonic::Status,
        >;
        /// Creates a directory inside a Workspace.
        async fn make_directory(
            &self,
            request: tonic::Request<super::MakeDirectoryRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MakeDirectoryResponse>,
            tonic::Status,
        >;
        /// Deletes a directory (inside a Workspace) and all of its contents.
        async fn remove_directory(
            &self,
            request: tonic::Request<super::RemoveDirectoryRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status>;
        /// Moves a directory (inside a Workspace), and all of its contents, to a new
        /// location.
        async fn move_directory(
            &self,
            request: tonic::Request<super::MoveDirectoryRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MoveDirectoryResponse>,
            tonic::Status,
        >;
        /// Returns the contents of a file (inside a Workspace).
        async fn read_file(
            &self,
            request: tonic::Request<super::ReadFileRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ReadFileResponse>,
            tonic::Status,
        >;
        /// Deletes a file (inside a Workspace).
        async fn remove_file(
            &self,
            request: tonic::Request<super::RemoveFileRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status>;
        /// Moves a file (inside a Workspace) to a new location.
        async fn move_file(
            &self,
            request: tonic::Request<super::MoveFileRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MoveFileResponse>,
            tonic::Status,
        >;
        /// Writes to a file (inside a Workspace).
        async fn write_file(
            &self,
            request: tonic::Request<super::WriteFileRequest>,
        ) -> std::result::Result<
            tonic::Response<super::WriteFileResponse>,
            tonic::Status,
        >;
        /// Lists ReleaseConfigs in a given Repository.
        async fn list_release_configs(
            &self,
            request: tonic::Request<super::ListReleaseConfigsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListReleaseConfigsResponse>,
            tonic::Status,
        >;
        /// Fetches a single ReleaseConfig.
        async fn get_release_config(
            &self,
            request: tonic::Request<super::GetReleaseConfigRequest>,
        ) -> std::result::Result<tonic::Response<super::ReleaseConfig>, tonic::Status>;
        /// Creates a new ReleaseConfig in a given Repository.
        async fn create_release_config(
            &self,
            request: tonic::Request<super::CreateReleaseConfigRequest>,
        ) -> std::result::Result<tonic::Response<super::ReleaseConfig>, tonic::Status>;
        /// Updates a single ReleaseConfig.
        async fn update_release_config(
            &self,
            request: tonic::Request<super::UpdateReleaseConfigRequest>,
        ) -> std::result::Result<tonic::Response<super::ReleaseConfig>, tonic::Status>;
        /// Deletes a single ReleaseConfig.
        async fn delete_release_config(
            &self,
            request: tonic::Request<super::DeleteReleaseConfigRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status>;
        /// Lists CompilationResults in a given Repository.
        async fn list_compilation_results(
            &self,
            request: tonic::Request<super::ListCompilationResultsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListCompilationResultsResponse>,
            tonic::Status,
        >;
        /// Fetches a single CompilationResult.
        async fn get_compilation_result(
            &self,
            request: tonic::Request<super::GetCompilationResultRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CompilationResult>,
            tonic::Status,
        >;
        /// Creates a new CompilationResult in a given project and location.
        async fn create_compilation_result(
            &self,
            request: tonic::Request<super::CreateCompilationResultRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CompilationResult>,
            tonic::Status,
        >;
        /// Returns CompilationResultActions in a given CompilationResult.
        async fn query_compilation_result_actions(
            &self,
            request: tonic::Request<super::QueryCompilationResultActionsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryCompilationResultActionsResponse>,
            tonic::Status,
        >;
        /// Lists WorkflowConfigs in a given Repository.
        async fn list_workflow_configs(
            &self,
            request: tonic::Request<super::ListWorkflowConfigsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListWorkflowConfigsResponse>,
            tonic::Status,
        >;
        /// Fetches a single WorkflowConfig.
        async fn get_workflow_config(
            &self,
            request: tonic::Request<super::GetWorkflowConfigRequest>,
        ) -> std::result::Result<tonic::Response<super::WorkflowConfig>, tonic::Status>;
        /// Creates a new WorkflowConfig in a given Repository.
        async fn create_workflow_config(
            &self,
            request: tonic::Request<super::CreateWorkflowConfigRequest>,
        ) -> std::result::Result<tonic::Response<super::WorkflowConfig>, tonic::Status>;
        /// Updates a single WorkflowConfig.
        async fn update_workflow_config(
            &self,
            request: tonic::Request<super::UpdateWorkflowConfigRequest>,
        ) -> std::result::Result<tonic::Response<super::WorkflowConfig>, tonic::Status>;
        /// Deletes a single WorkflowConfig.
        async fn delete_workflow_config(
            &self,
            request: tonic::Request<super::DeleteWorkflowConfigRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status>;
        /// Lists WorkflowInvocations in a given Repository.
        async fn list_workflow_invocations(
            &self,
            request: tonic::Request<super::ListWorkflowInvocationsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListWorkflowInvocationsResponse>,
            tonic::Status,
        >;
        /// Fetches a single WorkflowInvocation.
        async fn get_workflow_invocation(
            &self,
            request: tonic::Request<super::GetWorkflowInvocationRequest>,
        ) -> std::result::Result<
            tonic::Response<super::WorkflowInvocation>,
            tonic::Status,
        >;
        /// Creates a new WorkflowInvocation in a given Repository.
        async fn create_workflow_invocation(
            &self,
            request: tonic::Request<super::CreateWorkflowInvocationRequest>,
        ) -> std::result::Result<
            tonic::Response<super::WorkflowInvocation>,
            tonic::Status,
        >;
        /// Deletes a single WorkflowInvocation.
        async fn delete_workflow_invocation(
            &self,
            request: tonic::Request<super::DeleteWorkflowInvocationRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status>;
        /// Requests cancellation of a running WorkflowInvocation.
        async fn cancel_workflow_invocation(
            &self,
            request: tonic::Request<super::CancelWorkflowInvocationRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status>;
        /// Returns WorkflowInvocationActions in a given WorkflowInvocation.
        async fn query_workflow_invocation_actions(
            &self,
            request: tonic::Request<super::QueryWorkflowInvocationActionsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryWorkflowInvocationActionsResponse>,
            tonic::Status,
        >;
    }
    /// Dataform is a service to develop, create, document, test, and update curated
    /// tables in BigQuery.
    #[derive(Debug)]
    pub struct DataformServer<T: Dataform> {
        inner: _Inner<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    struct _Inner<T>(Arc<T>);
    impl<T: Dataform> DataformServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            let inner = _Inner(inner);
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for DataformServer<T>
    where
        T: Dataform,
        B: Body + Send + 'static,
        B::Error: Into<StdError> + Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            let inner = self.inner.clone();
            match req.uri().path() {
                "/google.cloud.dataform.v1beta1.Dataform/ListRepositories" => {
                    #[allow(non_camel_case_types)]
                    struct ListRepositoriesSvc<T: Dataform>(pub Arc<T>);
                    impl<
                        T: Dataform,
                    > tonic::server::UnaryService<super::ListRepositoriesRequest>
                    for ListRepositoriesSvc<T> {
                        type Response = super::ListRepositoriesResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ListRepositoriesRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dataform>::list_repositories(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = ListRepositoriesSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.dataform.v1beta1.Dataform/GetRepository" => {
                    #[allow(non_camel_case_types)]
                    struct GetRepositorySvc<T: Dataform>(pub Arc<T>);
                    impl<
                        T: Dataform,
                    > tonic::server::UnaryService<super::GetRepositoryRequest>
                    for GetRepositorySvc<T> {
                        type Response = super::Repository;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetRepositoryRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dataform>::get_repository(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = GetRepositorySvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.dataform.v1beta1.Dataform/CreateRepository" => {
                    #[allow(non_camel_case_types)]
                    struct CreateRepositorySvc<T: Dataform>(pub Arc<T>);
                    impl<
                        T: Dataform,
                    > tonic::server::UnaryService<super::CreateRepositoryRequest>
                    for CreateRepositorySvc<T> {
                        type Response = super::Repository;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::CreateRepositoryRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dataform>::create_repository(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = CreateRepositorySvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.dataform.v1beta1.Dataform/UpdateRepository" => {
                    #[allow(non_camel_case_types)]
                    struct UpdateRepositorySvc<T: Dataform>(pub Arc<T>);
                    impl<
                        T: Dataform,
                    > tonic::server::UnaryService<super::UpdateRepositoryRequest>
                    for UpdateRepositorySvc<T> {
                        type Response = super::Repository;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::UpdateRepositoryRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dataform>::update_repository(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = UpdateRepositorySvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.dataform.v1beta1.Dataform/DeleteRepository" => {
                    #[allow(non_camel_case_types)]
                    struct DeleteRepositorySvc<T: Dataform>(pub Arc<T>);
                    impl<
                        T: Dataform,
                    > tonic::server::UnaryService<super::DeleteRepositoryRequest>
                    for DeleteRepositorySvc<T> {
                        type Response = ();
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DeleteRepositoryRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dataform>::delete_repository(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = DeleteRepositorySvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.dataform.v1beta1.Dataform/CommitRepositoryChanges" => {
                    #[allow(non_camel_case_types)]
                    struct CommitRepositoryChangesSvc<T: Dataform>(pub Arc<T>);
                    impl<
                        T: Dataform,
                    > tonic::server::UnaryService<super::CommitRepositoryChangesRequest>
                    for CommitRepositoryChangesSvc<T> {
                        type Response = ();
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::CommitRepositoryChangesRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dataform>::commit_repository_changes(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = CommitRepositoryChangesSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.dataform.v1beta1.Dataform/ReadRepositoryFile" => {
                    #[allow(non_camel_case_types)]
                    struct ReadRepositoryFileSvc<T: Dataform>(pub Arc<T>);
                    impl<
                        T: Dataform,
                    > tonic::server::UnaryService<super::ReadRepositoryFileRequest>
                    for ReadRepositoryFileSvc<T> {
                        type Response = super::ReadRepositoryFileResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ReadRepositoryFileRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dataform>::read_repository_file(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = ReadRepositoryFileSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.dataform.v1beta1.Dataform/QueryRepositoryDirectoryContents" => {
                    #[allow(non_camel_case_types)]
                    struct QueryRepositoryDirectoryContentsSvc<T: Dataform>(pub Arc<T>);
                    impl<
                        T: Dataform,
                    > tonic::server::UnaryService<
                        super::QueryRepositoryDirectoryContentsRequest,
                    > for QueryRepositoryDirectoryContentsSvc<T> {
                        type Response = super::QueryRepositoryDirectoryContentsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::QueryRepositoryDirectoryContentsRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dataform>::query_repository_directory_contents(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = QueryRepositoryDirectoryContentsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.dataform.v1beta1.Dataform/FetchRepositoryHistory" => {
                    #[allow(non_camel_case_types)]
                    struct FetchRepositoryHistorySvc<T: Dataform>(pub Arc<T>);
                    impl<
                        T: Dataform,
                    > tonic::server::UnaryService<super::FetchRepositoryHistoryRequest>
                    for FetchRepositoryHistorySvc<T> {
                        type Response = super::FetchRepositoryHistoryResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::FetchRepositoryHistoryRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dataform>::fetch_repository_history(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = FetchRepositoryHistorySvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.dataform.v1beta1.Dataform/ComputeRepositoryAccessTokenStatus" => {
                    #[allow(non_camel_case_types)]
                    struct ComputeRepositoryAccessTokenStatusSvc<T: Dataform>(
                        pub Arc<T>,
                    );
                    impl<
                        T: Dataform,
                    > tonic::server::UnaryService<
                        super::ComputeRepositoryAccessTokenStatusRequest,
                    > for ComputeRepositoryAccessTokenStatusSvc<T> {
                        type Response = super::ComputeRepositoryAccessTokenStatusResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::ComputeRepositoryAccessTokenStatusRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dataform>::compute_repository_access_token_status(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = ComputeRepositoryAccessTokenStatusSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.dataform.v1beta1.Dataform/FetchRemoteBranches" => {
                    #[allow(non_camel_case_types)]
                    struct FetchRemoteBranchesSvc<T: Dataform>(pub Arc<T>);
                    impl<
                        T: Dataform,
                    > tonic::server::UnaryService<super::FetchRemoteBranchesRequest>
                    for FetchRemoteBranchesSvc<T> {
                        type Response = super::FetchRemoteBranchesResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::FetchRemoteBranchesRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dataform>::fetch_remote_branches(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = FetchRemoteBranchesSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.dataform.v1beta1.Dataform/ListWorkspaces" => {
                    #[allow(non_camel_case_types)]
                    struct ListWorkspacesSvc<T: Dataform>(pub Arc<T>);
                    impl<
                        T: Dataform,
                    > tonic::server::UnaryService<super::ListWorkspacesRequest>
                    for ListWorkspacesSvc<T> {
                        type Response = super::ListWorkspacesResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ListWorkspacesRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dataform>::list_workspaces(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = ListWorkspacesSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.dataform.v1beta1.Dataform/GetWorkspace" => {
                    #[allow(non_camel_case_types)]
                    struct GetWorkspaceSvc<T: Dataform>(pub Arc<T>);
                    impl<
                        T: Dataform,
                    > tonic::server::UnaryService<super::GetWorkspaceRequest>
                    for GetWorkspaceSvc<T> {
                        type Response = super::Workspace;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetWorkspaceRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dataform>::get_workspace(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = GetWorkspaceSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.dataform.v1beta1.Dataform/CreateWorkspace" => {
                    #[allow(non_camel_case_types)]
                    struct CreateWorkspaceSvc<T: Dataform>(pub Arc<T>);
                    impl<
                        T: Dataform,
                    > tonic::server::UnaryService<super::CreateWorkspaceRequest>
                    for CreateWorkspaceSvc<T> {
                        type Response = super::Workspace;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::CreateWorkspaceRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dataform>::create_workspace(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = CreateWorkspaceSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.dataform.v1beta1.Dataform/DeleteWorkspace" => {
                    #[allow(non_camel_case_types)]
                    struct DeleteWorkspaceSvc<T: Dataform>(pub Arc<T>);
                    impl<
                        T: Dataform,
                    > tonic::server::UnaryService<super::DeleteWorkspaceRequest>
                    for DeleteWorkspaceSvc<T> {
                        type Response = ();
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DeleteWorkspaceRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dataform>::delete_workspace(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = DeleteWorkspaceSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.dataform.v1beta1.Dataform/InstallNpmPackages" => {
                    #[allow(non_camel_case_types)]
                    struct InstallNpmPackagesSvc<T: Dataform>(pub Arc<T>);
                    impl<
                        T: Dataform,
                    > tonic::server::UnaryService<super::InstallNpmPackagesRequest>
                    for InstallNpmPackagesSvc<T> {
                        type Response = super::InstallNpmPackagesResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::InstallNpmPackagesRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dataform>::install_npm_packages(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = InstallNpmPackagesSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.dataform.v1beta1.Dataform/PullGitCommits" => {
                    #[allow(non_camel_case_types)]
                    struct PullGitCommitsSvc<T: Dataform>(pub Arc<T>);
                    impl<
                        T: Dataform,
                    > tonic::server::UnaryService<super::PullGitCommitsRequest>
                    for PullGitCommitsSvc<T> {
                        type Response = ();
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::PullGitCommitsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dataform>::pull_git_commits(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = PullGitCommitsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.dataform.v1beta1.Dataform/PushGitCommits" => {
                    #[allow(non_camel_case_types)]
                    struct PushGitCommitsSvc<T: Dataform>(pub Arc<T>);
                    impl<
                        T: Dataform,
                    > tonic::server::UnaryService<super::PushGitCommitsRequest>
                    for PushGitCommitsSvc<T> {
                        type Response = ();
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::PushGitCommitsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dataform>::push_git_commits(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = PushGitCommitsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.dataform.v1beta1.Dataform/FetchFileGitStatuses" => {
                    #[allow(non_camel_case_types)]
                    struct FetchFileGitStatusesSvc<T: Dataform>(pub Arc<T>);
                    impl<
                        T: Dataform,
                    > tonic::server::UnaryService<super::FetchFileGitStatusesRequest>
                    for FetchFileGitStatusesSvc<T> {
                        type Response = super::FetchFileGitStatusesResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::FetchFileGitStatusesRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dataform>::fetch_file_git_statuses(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = FetchFileGitStatusesSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.dataform.v1beta1.Dataform/FetchGitAheadBehind" => {
                    #[allow(non_camel_case_types)]
                    struct FetchGitAheadBehindSvc<T: Dataform>(pub Arc<T>);
                    impl<
                        T: Dataform,
                    > tonic::server::UnaryService<super::FetchGitAheadBehindRequest>
                    for FetchGitAheadBehindSvc<T> {
                        type Response = super::FetchGitAheadBehindResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::FetchGitAheadBehindRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dataform>::fetch_git_ahead_behind(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = FetchGitAheadBehindSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.dataform.v1beta1.Dataform/CommitWorkspaceChanges" => {
                    #[allow(non_camel_case_types)]
                    struct CommitWorkspaceChangesSvc<T: Dataform>(pub Arc<T>);
                    impl<
                        T: Dataform,
                    > tonic::server::UnaryService<super::CommitWorkspaceChangesRequest>
                    for CommitWorkspaceChangesSvc<T> {
                        type Response = ();
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::CommitWorkspaceChangesRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dataform>::commit_workspace_changes(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = CommitWorkspaceChangesSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.dataform.v1beta1.Dataform/ResetWorkspaceChanges" => {
                    #[allow(non_camel_case_types)]
                    struct ResetWorkspaceChangesSvc<T: Dataform>(pub Arc<T>);
                    impl<
                        T: Dataform,
                    > tonic::server::UnaryService<super::ResetWorkspaceChangesRequest>
                    for ResetWorkspaceChangesSvc<T> {
                        type Response = ();
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ResetWorkspaceChangesRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dataform>::reset_workspace_changes(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = ResetWorkspaceChangesSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.dataform.v1beta1.Dataform/FetchFileDiff" => {
                    #[allow(non_camel_case_types)]
                    struct FetchFileDiffSvc<T: Dataform>(pub Arc<T>);
                    impl<
                        T: Dataform,
                    > tonic::server::UnaryService<super::FetchFileDiffRequest>
                    for FetchFileDiffSvc<T> {
                        type Response = super::FetchFileDiffResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::FetchFileDiffRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dataform>::fetch_file_diff(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = FetchFileDiffSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.dataform.v1beta1.Dataform/QueryDirectoryContents" => {
                    #[allow(non_camel_case_types)]
                    struct QueryDirectoryContentsSvc<T: Dataform>(pub Arc<T>);
                    impl<
                        T: Dataform,
                    > tonic::server::UnaryService<super::QueryDirectoryContentsRequest>
                    for QueryDirectoryContentsSvc<T> {
                        type Response = super::QueryDirectoryContentsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::QueryDirectoryContentsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dataform>::query_directory_contents(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = QueryDirectoryContentsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.dataform.v1beta1.Dataform/MakeDirectory" => {
                    #[allow(non_camel_case_types)]
                    struct MakeDirectorySvc<T: Dataform>(pub Arc<T>);
                    impl<
                        T: Dataform,
                    > tonic::server::UnaryService<super::MakeDirectoryRequest>
                    for MakeDirectorySvc<T> {
                        type Response = super::MakeDirectoryResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::MakeDirectoryRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dataform>::make_directory(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = MakeDirectorySvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.dataform.v1beta1.Dataform/RemoveDirectory" => {
                    #[allow(non_camel_case_types)]
                    struct RemoveDirectorySvc<T: Dataform>(pub Arc<T>);
                    impl<
                        T: Dataform,
                    > tonic::server::UnaryService<super::RemoveDirectoryRequest>
                    for RemoveDirectorySvc<T> {
                        type Response = ();
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::RemoveDirectoryRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dataform>::remove_directory(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = RemoveDirectorySvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.dataform.v1beta1.Dataform/MoveDirectory" => {
                    #[allow(non_camel_case_types)]
                    struct MoveDirectorySvc<T: Dataform>(pub Arc<T>);
                    impl<
                        T: Dataform,
                    > tonic::server::UnaryService<super::MoveDirectoryRequest>
                    for MoveDirectorySvc<T> {
                        type Response = super::MoveDirectoryResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::MoveDirectoryRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dataform>::move_directory(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = MoveDirectorySvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.dataform.v1beta1.Dataform/ReadFile" => {
                    #[allow(non_camel_case_types)]
                    struct ReadFileSvc<T: Dataform>(pub Arc<T>);
                    impl<T: Dataform> tonic::server::UnaryService<super::ReadFileRequest>
                    for ReadFileSvc<T> {
                        type Response = super::ReadFileResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ReadFileRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dataform>::read_file(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = ReadFileSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.dataform.v1beta1.Dataform/RemoveFile" => {
                    #[allow(non_camel_case_types)]
                    struct RemoveFileSvc<T: Dataform>(pub Arc<T>);
                    impl<
                        T: Dataform,
                    > tonic::server::UnaryService<super::RemoveFileRequest>
                    for RemoveFileSvc<T> {
                        type Response = ();
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::RemoveFileRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dataform>::remove_file(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = RemoveFileSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.dataform.v1beta1.Dataform/MoveFile" => {
                    #[allow(non_camel_case_types)]
                    struct MoveFileSvc<T: Dataform>(pub Arc<T>);
                    impl<T: Dataform> tonic::server::UnaryService<super::MoveFileRequest>
                    for MoveFileSvc<T> {
                        type Response = super::MoveFileResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::MoveFileRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dataform>::move_file(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = MoveFileSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.dataform.v1beta1.Dataform/WriteFile" => {
                    #[allow(non_camel_case_types)]
                    struct WriteFileSvc<T: Dataform>(pub Arc<T>);
                    impl<
                        T: Dataform,
                    > tonic::server::UnaryService<super::WriteFileRequest>
                    for WriteFileSvc<T> {
                        type Response = super::WriteFileResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::WriteFileRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dataform>::write_file(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = WriteFileSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.dataform.v1beta1.Dataform/ListReleaseConfigs" => {
                    #[allow(non_camel_case_types)]
                    struct ListReleaseConfigsSvc<T: Dataform>(pub Arc<T>);
                    impl<
                        T: Dataform,
                    > tonic::server::UnaryService<super::ListReleaseConfigsRequest>
                    for ListReleaseConfigsSvc<T> {
                        type Response = super::ListReleaseConfigsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ListReleaseConfigsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dataform>::list_release_configs(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = ListReleaseConfigsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.dataform.v1beta1.Dataform/GetReleaseConfig" => {
                    #[allow(non_camel_case_types)]
                    struct GetReleaseConfigSvc<T: Dataform>(pub Arc<T>);
                    impl<
                        T: Dataform,
                    > tonic::server::UnaryService<super::GetReleaseConfigRequest>
                    for GetReleaseConfigSvc<T> {
                        type Response = super::ReleaseConfig;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetReleaseConfigRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dataform>::get_release_config(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = GetReleaseConfigSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.dataform.v1beta1.Dataform/CreateReleaseConfig" => {
                    #[allow(non_camel_case_types)]
                    struct CreateReleaseConfigSvc<T: Dataform>(pub Arc<T>);
                    impl<
                        T: Dataform,
                    > tonic::server::UnaryService<super::CreateReleaseConfigRequest>
                    for CreateReleaseConfigSvc<T> {
                        type Response = super::ReleaseConfig;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::CreateReleaseConfigRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dataform>::create_release_config(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = CreateReleaseConfigSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.dataform.v1beta1.Dataform/UpdateReleaseConfig" => {
                    #[allow(non_camel_case_types)]
                    struct UpdateReleaseConfigSvc<T: Dataform>(pub Arc<T>);
                    impl<
                        T: Dataform,
                    > tonic::server::UnaryService<super::UpdateReleaseConfigRequest>
                    for UpdateReleaseConfigSvc<T> {
                        type Response = super::ReleaseConfig;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::UpdateReleaseConfigRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dataform>::update_release_config(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = UpdateReleaseConfigSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.dataform.v1beta1.Dataform/DeleteReleaseConfig" => {
                    #[allow(non_camel_case_types)]
                    struct DeleteReleaseConfigSvc<T: Dataform>(pub Arc<T>);
                    impl<
                        T: Dataform,
                    > tonic::server::UnaryService<super::DeleteReleaseConfigRequest>
                    for DeleteReleaseConfigSvc<T> {
                        type Response = ();
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DeleteReleaseConfigRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dataform>::delete_release_config(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = DeleteReleaseConfigSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.dataform.v1beta1.Dataform/ListCompilationResults" => {
                    #[allow(non_camel_case_types)]
                    struct ListCompilationResultsSvc<T: Dataform>(pub Arc<T>);
                    impl<
                        T: Dataform,
                    > tonic::server::UnaryService<super::ListCompilationResultsRequest>
                    for ListCompilationResultsSvc<T> {
                        type Response = super::ListCompilationResultsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ListCompilationResultsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dataform>::list_compilation_results(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = ListCompilationResultsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.dataform.v1beta1.Dataform/GetCompilationResult" => {
                    #[allow(non_camel_case_types)]
                    struct GetCompilationResultSvc<T: Dataform>(pub Arc<T>);
                    impl<
                        T: Dataform,
                    > tonic::server::UnaryService<super::GetCompilationResultRequest>
                    for GetCompilationResultSvc<T> {
                        type Response = super::CompilationResult;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetCompilationResultRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dataform>::get_compilation_result(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = GetCompilationResultSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.dataform.v1beta1.Dataform/CreateCompilationResult" => {
                    #[allow(non_camel_case_types)]
                    struct CreateCompilationResultSvc<T: Dataform>(pub Arc<T>);
                    impl<
                        T: Dataform,
                    > tonic::server::UnaryService<super::CreateCompilationResultRequest>
                    for CreateCompilationResultSvc<T> {
                        type Response = super::CompilationResult;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::CreateCompilationResultRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dataform>::create_compilation_result(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = CreateCompilationResultSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.dataform.v1beta1.Dataform/QueryCompilationResultActions" => {
                    #[allow(non_camel_case_types)]
                    struct QueryCompilationResultActionsSvc<T: Dataform>(pub Arc<T>);
                    impl<
                        T: Dataform,
                    > tonic::server::UnaryService<
                        super::QueryCompilationResultActionsRequest,
                    > for QueryCompilationResultActionsSvc<T> {
                        type Response = super::QueryCompilationResultActionsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::QueryCompilationResultActionsRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dataform>::query_compilation_result_actions(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = QueryCompilationResultActionsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.dataform.v1beta1.Dataform/ListWorkflowConfigs" => {
                    #[allow(non_camel_case_types)]
                    struct ListWorkflowConfigsSvc<T: Dataform>(pub Arc<T>);
                    impl<
                        T: Dataform,
                    > tonic::server::UnaryService<super::ListWorkflowConfigsRequest>
                    for ListWorkflowConfigsSvc<T> {
                        type Response = super::ListWorkflowConfigsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ListWorkflowConfigsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dataform>::list_workflow_configs(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = ListWorkflowConfigsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.dataform.v1beta1.Dataform/GetWorkflowConfig" => {
                    #[allow(non_camel_case_types)]
                    struct GetWorkflowConfigSvc<T: Dataform>(pub Arc<T>);
                    impl<
                        T: Dataform,
                    > tonic::server::UnaryService<super::GetWorkflowConfigRequest>
                    for GetWorkflowConfigSvc<T> {
                        type Response = super::WorkflowConfig;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetWorkflowConfigRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dataform>::get_workflow_config(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = GetWorkflowConfigSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.dataform.v1beta1.Dataform/CreateWorkflowConfig" => {
                    #[allow(non_camel_case_types)]
                    struct CreateWorkflowConfigSvc<T: Dataform>(pub Arc<T>);
                    impl<
                        T: Dataform,
                    > tonic::server::UnaryService<super::CreateWorkflowConfigRequest>
                    for CreateWorkflowConfigSvc<T> {
                        type Response = super::WorkflowConfig;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::CreateWorkflowConfigRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dataform>::create_workflow_config(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = CreateWorkflowConfigSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.dataform.v1beta1.Dataform/UpdateWorkflowConfig" => {
                    #[allow(non_camel_case_types)]
                    struct UpdateWorkflowConfigSvc<T: Dataform>(pub Arc<T>);
                    impl<
                        T: Dataform,
                    > tonic::server::UnaryService<super::UpdateWorkflowConfigRequest>
                    for UpdateWorkflowConfigSvc<T> {
                        type Response = super::WorkflowConfig;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::UpdateWorkflowConfigRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dataform>::update_workflow_config(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = UpdateWorkflowConfigSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.dataform.v1beta1.Dataform/DeleteWorkflowConfig" => {
                    #[allow(non_camel_case_types)]
                    struct DeleteWorkflowConfigSvc<T: Dataform>(pub Arc<T>);
                    impl<
                        T: Dataform,
                    > tonic::server::UnaryService<super::DeleteWorkflowConfigRequest>
                    for DeleteWorkflowConfigSvc<T> {
                        type Response = ();
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DeleteWorkflowConfigRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dataform>::delete_workflow_config(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = DeleteWorkflowConfigSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.dataform.v1beta1.Dataform/ListWorkflowInvocations" => {
                    #[allow(non_camel_case_types)]
                    struct ListWorkflowInvocationsSvc<T: Dataform>(pub Arc<T>);
                    impl<
                        T: Dataform,
                    > tonic::server::UnaryService<super::ListWorkflowInvocationsRequest>
                    for ListWorkflowInvocationsSvc<T> {
                        type Response = super::ListWorkflowInvocationsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::ListWorkflowInvocationsRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dataform>::list_workflow_invocations(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = ListWorkflowInvocationsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.dataform.v1beta1.Dataform/GetWorkflowInvocation" => {
                    #[allow(non_camel_case_types)]
                    struct GetWorkflowInvocationSvc<T: Dataform>(pub Arc<T>);
                    impl<
                        T: Dataform,
                    > tonic::server::UnaryService<super::GetWorkflowInvocationRequest>
                    for GetWorkflowInvocationSvc<T> {
                        type Response = super::WorkflowInvocation;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetWorkflowInvocationRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dataform>::get_workflow_invocation(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = GetWorkflowInvocationSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.dataform.v1beta1.Dataform/CreateWorkflowInvocation" => {
                    #[allow(non_camel_case_types)]
                    struct CreateWorkflowInvocationSvc<T: Dataform>(pub Arc<T>);
                    impl<
                        T: Dataform,
                    > tonic::server::UnaryService<super::CreateWorkflowInvocationRequest>
                    for CreateWorkflowInvocationSvc<T> {
                        type Response = super::WorkflowInvocation;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::CreateWorkflowInvocationRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dataform>::create_workflow_invocation(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = CreateWorkflowInvocationSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.dataform.v1beta1.Dataform/DeleteWorkflowInvocation" => {
                    #[allow(non_camel_case_types)]
                    struct DeleteWorkflowInvocationSvc<T: Dataform>(pub Arc<T>);
                    impl<
                        T: Dataform,
                    > tonic::server::UnaryService<super::DeleteWorkflowInvocationRequest>
                    for DeleteWorkflowInvocationSvc<T> {
                        type Response = ();
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::DeleteWorkflowInvocationRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dataform>::delete_workflow_invocation(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = DeleteWorkflowInvocationSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.dataform.v1beta1.Dataform/CancelWorkflowInvocation" => {
                    #[allow(non_camel_case_types)]
                    struct CancelWorkflowInvocationSvc<T: Dataform>(pub Arc<T>);
                    impl<
                        T: Dataform,
                    > tonic::server::UnaryService<super::CancelWorkflowInvocationRequest>
                    for CancelWorkflowInvocationSvc<T> {
                        type Response = ();
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::CancelWorkflowInvocationRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dataform>::cancel_workflow_invocation(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = CancelWorkflowInvocationSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.dataform.v1beta1.Dataform/QueryWorkflowInvocationActions" => {
                    #[allow(non_camel_case_types)]
                    struct QueryWorkflowInvocationActionsSvc<T: Dataform>(pub Arc<T>);
                    impl<
                        T: Dataform,
                    > tonic::server::UnaryService<
                        super::QueryWorkflowInvocationActionsRequest,
                    > for QueryWorkflowInvocationActionsSvc<T> {
                        type Response = super::QueryWorkflowInvocationActionsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::QueryWorkflowInvocationActionsRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dataform>::query_workflow_invocation_actions(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = QueryWorkflowInvocationActionsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        Ok(
                            http::Response::builder()
                                .status(200)
                                .header("grpc-status", "12")
                                .header("content-type", "application/grpc")
                                .body(empty_body())
                                .unwrap(),
                        )
                    })
                }
            }
        }
    }
    impl<T: Dataform> Clone for DataformServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    impl<T: Dataform> Clone for _Inner<T> {
        fn clone(&self) -> Self {
            Self(Arc::clone(&self.0))
        }
    }
    impl<T: std::fmt::Debug> std::fmt::Debug for _Inner<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{:?}", self.0)
        }
    }
    impl<T: Dataform> tonic::server::NamedService for DataformServer<T> {
        const NAME: &'static str = "google.cloud.dataform.v1beta1.Dataform";
    }
}
